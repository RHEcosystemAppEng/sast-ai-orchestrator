# Detect OpenShift vs Kubernetes
KUBECTL_CMD := $(shell command -v oc 2>/dev/null || echo kubectl)

# Environment-specific settings
DEV_NAMESPACE := sast-ai-dev
PROD_NAMESPACE := sast-ai-prod

# Get current namespace from kubectl/oc, fallback to dev
CURRENT_NAMESPACE := $(shell $(KUBECTL_CMD) config view --minify --output 'jsonpath={..namespace}' 2>/dev/null)
NAMESPACE ?= $(if $(CURRENT_NAMESPACE),$(CURRENT_NAMESPACE),$(DEV_NAMESPACE))

RELEASE_NAME ?= sast-ai-orchestrator
CHART_PATH ?= ./sast-ai-chart
HELM_TIMEOUT ?= 300s

.DEFAULT_GOAL := help

.PHONY: deploy-dev
deploy-dev: ## Deploy to development environment (sast-ai-dev namespace)
	@echo "üöÄ Deploying SAST AI to DEVELOPMENT environment..."
	@echo "Namespace: $(DEV_NAMESPACE)"
	@echo "Release: $(RELEASE_NAME)-dev"
	@echo "Using: $(KUBECTL_CMD)"
	@$(MAKE) _deploy NAMESPACE=$(DEV_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-dev VALUES_FILE=values-dev.yaml

.PHONY: deploy-prod
deploy-prod: ## Deploy to production environment (sast-ai-prod namespace)
	@echo "üöÄ Deploying SAST AI to PRODUCTION environment..."
	@echo "Namespace: $(PROD_NAMESPACE)"
	@echo "Release: $(RELEASE_NAME)-prod"
	@echo "Using: $(KUBECTL_CMD)"
	@$(MAKE) _deploy NAMESPACE=$(PROD_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-prod VALUES_FILE=values-prod.yaml

.PHONY: _deploy
_deploy: ## Internal deployment target
	@helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
	@helm repo update >/dev/null 2>&1
	@cd $(CHART_PATH) && helm dependency update
	@helm install $(RELEASE_NAME) $(CHART_PATH) \
		-f $(CHART_PATH)/values.yaml \
		-f $(CHART_PATH)/$(VALUES_FILE) \
		-n $(NAMESPACE) \
		--create-namespace \
		--timeout=$(HELM_TIMEOUT) \
		--set app.env.SAST_AI_WORKFLOW_NAMESPACE=$(NAMESPACE)
	@echo "‚úÖ Deployment completed!"
	@$(MAKE) wait-pods NAMESPACE=$(NAMESPACE)
	@echo "üîç Checking for ArgoCD availability..."
	@if $(KUBECTL_CMD) get crd applications.argoproj.io >/dev/null 2>&1; then \
		echo "üì¶ ArgoCD detected! Creating ArgoCD Application..."; \
		$(MAKE) argocd NAMESPACE=$(NAMESPACE); \
	else \
		echo "‚ö†Ô∏è  ArgoCD not available in cluster, skipping ArgoCD Application creation."; \
	fi
	@$(MAKE) show-access NAMESPACE=$(NAMESPACE)

.PHONY: upgrade-dev
upgrade-dev: ## Upgrade development deployment
	@echo "‚¨ÜÔ∏è  Upgrading SAST AI DEVELOPMENT deployment..."
	@$(MAKE) _upgrade NAMESPACE=$(DEV_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-dev VALUES_FILE=values-dev.yaml

.PHONY: upgrade-prod
upgrade-prod: ## Upgrade production deployment
	@echo "‚¨ÜÔ∏è  Upgrading SAST AI PRODUCTION deployment..."
	@$(MAKE) _upgrade NAMESPACE=$(PROD_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-prod VALUES_FILE=values-prod.yaml

.PHONY: _upgrade
_upgrade: ## Internal upgrade target
	@helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
	@helm repo update >/dev/null 2>&1
	@cd $(CHART_PATH) && helm dependency update
	@helm upgrade $(RELEASE_NAME) $(CHART_PATH) \
		-f $(CHART_PATH)/values.yaml \
		-f $(CHART_PATH)/$(VALUES_FILE) \
		-n $(NAMESPACE) \
		--timeout=$(HELM_TIMEOUT) \
		--set app.env.SAST_AI_WORKFLOW_NAMESPACE=$(NAMESPACE)
	@echo "‚úÖ Upgrade completed!"
	@$(MAKE) wait-pods NAMESPACE=$(NAMESPACE)

.PHONY: clean-dev
clean-dev: ## Remove development deployment
	@echo "üßπ Removing SAST AI DEVELOPMENT deployment..."
	@$(MAKE) _clean NAMESPACE=$(DEV_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-dev

.PHONY: clean-prod
clean-prod: ## Remove production deployment
	@echo "üßπ Removing SAST AI PRODUCTION deployment..."
	@$(MAKE) _clean NAMESPACE=$(PROD_NAMESPACE) RELEASE_NAME=$(RELEASE_NAME)-prod

.PHONY: _clean
_clean: ## Internal clean target
	@if helm list -n $(NAMESPACE) | grep -q "^$(RELEASE_NAME)"; then \
		helm uninstall $(RELEASE_NAME) -n $(NAMESPACE) --timeout=$(HELM_TIMEOUT); \
		@echo "Cleaning up remaining resources by label..."
		@$(KUBECTL_CMD) delete all,pvc,secrets,configmaps,ingress,routes,networkpolicy,pdb,sa,role,rolebinding,job -n $(NAMESPACE) -l "app.kubernetes.io/instance=$(RELEASE_NAME)" --ignore-not-found=true 2>/dev/null || true
		@echo "Force cleaning any remaining resources with release name prefix..."
		@for resource_type in deployment replicaset pod service configmap secret pvc role rolebinding serviceaccount networkpolicy poddisruptionbudget job cronjob ingress route; do \
			$(KUBECTL_CMD) get $$resource_type -n $(NAMESPACE) -o name 2>/dev/null | grep "$(RELEASE_NAME)" | xargs -r $(KUBECTL_CMD) delete -n $(NAMESPACE) --ignore-not-found=true 2>/dev/null || true; \
		done
		@echo "Cleanup completed!"
		echo "‚úÖ Deployment removed from $(NAMESPACE)"; \
	else \
		echo "Release '$(RELEASE_NAME)' not found in namespace '$(NAMESPACE)'"; \
	fi

.PHONY: status
status: ## Show deployment status
	@echo "üìä SAST AI Deployment Status"
	@echo "============================"
	@echo ""
	@echo "üîç Development Environment ($(DEV_NAMESPACE)):"
	@helm status $(RELEASE_NAME)-dev -n $(DEV_NAMESPACE) 2>/dev/null || echo "  ‚ùå Not deployed"
	@echo ""
	@echo "üîç Production Environment ($(PROD_NAMESPACE)):"
	@helm status $(RELEASE_NAME)-prod -n $(PROD_NAMESPACE) 2>/dev/null || echo "  ‚ùå Not deployed"

.PHONY: wait-pods
wait-pods: ## Wait for pods to be ready
	@echo "Waiting for SAST AI to be ready..."
	@echo "Checking PostgreSQL database..."
	@$(KUBECTL_CMD) wait --for=condition=ready pod -l app.kubernetes.io/name=postgresql -n $(NAMESPACE) --timeout=300s
	@echo "Database is ready!"
	@echo "Checking SAST AI application..."
	@$(KUBECTL_CMD) wait --for=condition=ready pod -l app.kubernetes.io/name=sast-ai -n $(NAMESPACE) --timeout=300s
	@echo "Application is ready!"

.PHONY: show-access
show-access: ## Show access information
	@echo ""
	@echo "SAST AI is now fully ready to use!"
	@if [[ "$(KUBECTL_CMD)" == *"oc" ]]; then \
		echo ""; \
		echo "=== ACCESS INFORMATION ==="; \
		ROUTE_HOST=$$($(KUBECTL_CMD) get route $(RELEASE_NAME) -n $(NAMESPACE) -o jsonpath='{.spec.host}' 2>/dev/null); \
		if [ -n "$$ROUTE_HOST" ]; then \
			ROUTE_TLS=$$($(KUBECTL_CMD) get route $(RELEASE_NAME) -n $(NAMESPACE) -o jsonpath='{.spec.tls}' 2>/dev/null); \
			if [ -n "$$ROUTE_TLS" ]; then \
				echo "üåê Application URL: https://$$ROUTE_HOST"; \
			else \
				echo "üåê Application URL: http://$$ROUTE_HOST"; \
			fi; \
		else \
			echo "‚ö†Ô∏è  No route found. Check route configuration."; \
		fi; \
		echo "=========================="; \
	fi

.PHONY: wait
wait: wait-pods show-access ## Wait for deployment to be ready and show access info

.PHONY: dry-run
dry-run: ## Show what would be deployed (dry run)
	@echo "Dry run deployment preview"
	@helm install $(RELEASE_NAME) $(CHART_PATH) \
		-f $(CHART_PATH)/values.yaml \
		-n $(NAMESPACE) \
		--dry-run \
		--debug \
		--set app.env.SAST_AI_WORKFLOW_NAMESPACE=$(NAMESPACE)

.PHONY: template
template: ## Generate Kubernetes YAML templates
	@echo "Generating Kubernetes templates"
	@helm template $(RELEASE_NAME) $(CHART_PATH) \
		-f $(CHART_PATH)/values.yaml \
		-n $(NAMESPACE) \
		--set app.env.SAST_AI_WORKFLOW_NAMESPACE=$(NAMESPACE)

.PHONY: lint
lint: ## Lint the Helm chart
	@echo "Linting Helm chart"
	@helm lint $(CHART_PATH)

.PHONY: argocd
argocd: ## Deploy ArgoCD Application to current namespace
	@echo "Deploying ArgoCD Application..."
	@NAMESPACE=$(NAMESPACE) envsubst < ./argocd/application.yaml | $(KUBECTL_CMD) apply -f -
	@echo "ArgoCD Application deployed to namespace: $(NAMESPACE)"

.PHONY: help
help: ## Show this help message
	@echo "SAST AI Deployment Commands"
	@echo "============================"
	@echo ""
	@echo "Environment-specific deployments:"
	@echo "  deploy-dev     Deploy to development environment (sast-ai-dev namespace)"
	@echo "  deploy-prod    Deploy to production environment (sast-ai-prod namespace)"
	@echo "  upgrade-dev    Upgrade development deployment"
	@echo "  upgrade-prod   Upgrade production deployment"
	@echo "  clean-dev      Remove development deployment"
	@echo "  clean-prod     Remove production deployment"
	@echo ""
	@echo "Utility commands:"
	@echo "  status         Show deployment status for both environments"
	@echo "  argocd         Deploy ArgoCD Application"
	@echo ""
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-12s %s\n", $$1, $$2}' $(MAKEFILE_LIST)
