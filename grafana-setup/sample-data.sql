--
-- PostgreSQL database dump
--

\restrict YmCQje7rnIWNenrK8IEe1QayulRzxHuaC3qDxnHdbBpWi8wwmpDd2pFzDNnQG2b

-- Dumped from database version 14.20 (Debian 14.20-1.pgdg13+1)
-- Dumped by pg_dump version 14.20 (Debian 14.20-1.pgdg13+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: mlops_batch; Type: TABLE DATA; Schema: public; Owner: quarkus
--

INSERT INTO public.mlops_batch (id, testing_data_nvrs_version, prompts_version, known_non_issues_version, container_image, submitted_by, submitted_at, last_updated_at, status, total_jobs, completed_jobs, failed_jobs) VALUES (6, 'v1.0.1', 'v2.3.1', 'v1.1.1', 'quay.io/sast-ai/analyzer:v1.0', 'mock_user', '2025-11-13 15:40:16', '2025-11-14 00:05:00', 'completed', 23, 23, 0);


--
-- Data for Name: mlops_job; Type: TABLE DATA; Schema: public; Owner: quarkus
--

INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (93, 6, 'libksba-1.6.5-3', 'libksba', 'libksba', '1.6.5-3', 'https://src.fedoraproject.org/rpms/libksba', 'https://example.com/fp/libksba', 'https://tekton.example.com/runs/6-libksba', 'completed', '2025-11-13 15:40:16', '2025-11-13 15:40:16', '2025-11-13 15:40:16', NULL, '2025-11-13 15:40:16', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (94, 6, 'gzip-1.13-1', 'gzip', 'gzip', '1.13-1', 'https://src.fedoraproject.org/rpms/gzip', 'https://example.com/fp/gzip', 'https://tekton.example.com/runs/6-gzip', 'completed', '2025-11-13 15:47:06', '2025-11-13 15:47:06', '2025-11-13 15:47:06', NULL, '2025-11-13 15:47:06', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (95, 6, 'libconfig-1.7.3-8', 'libconfig', 'libconfig', '1.7.3-8', 'https://src.fedoraproject.org/rpms/libconfig', 'https://example.com/fp/libconfig', 'https://tekton.example.com/runs/6-libconfig', 'completed', '2025-11-13 15:49:03', '2025-11-13 15:49:03', '2025-11-13 15:49:03', NULL, '2025-11-13 15:49:03', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (96, 6, 'libpcap-1.10.4-4', 'libpcap', 'libpcap', '1.10.4-4', 'https://src.fedoraproject.org/rpms/libpcap', 'https://example.com/fp/libpcap', 'https://tekton.example.com/runs/6-libpcap', 'completed', '2025-11-13 16:55:04', '2025-11-13 16:55:04', '2025-11-13 16:55:04', NULL, '2025-11-13 16:55:04', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (97, 6, 'adcli-0.9.2-6', 'adcli', 'adcli', '0.9.2-6', 'https://src.fedoraproject.org/rpms/adcli', 'https://example.com/fp/adcli', 'https://tekton.example.com/runs/6-adcli', 'completed', '2025-11-13 17:06:19', '2025-11-13 17:06:19', '2025-11-13 17:06:19', NULL, '2025-11-13 17:06:19', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (98, 6, 'audit-4.0-8', 'audit', 'audit', '4.0-8', 'https://src.fedoraproject.org/rpms/audit', 'https://example.com/fp/audit', 'https://tekton.example.com/runs/6-audit', 'completed', '2025-11-13 17:08:10', '2025-11-13 17:08:10', '2025-11-13 17:08:10', NULL, '2025-11-13 17:08:10', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (99, 6, 'libpng-1.6.40-3', 'libpng', 'libpng', '1.6.40-3', 'https://src.fedoraproject.org/rpms/libpng', 'https://example.com/fp/libpng', 'https://tekton.example.com/runs/6-libpng', 'completed', '2025-11-13 17:17:39', '2025-11-13 17:17:39', '2025-11-13 17:17:39', NULL, '2025-11-13 17:17:39', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (100, 6, 'cpio-2.15-1', 'cpio', 'cpio', '2.15-1', 'https://src.fedoraproject.org/rpms/cpio', 'https://example.com/fp/cpio', 'https://tekton.example.com/runs/6-cpio', 'completed', '2025-11-13 17:23:42', '2025-11-13 17:23:42', '2025-11-13 17:23:42', NULL, '2025-11-13 17:23:42', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (101, 6, 'graphite2-1.3.14-15', 'graphite2', 'graphite2', '1.3.14-15', 'https://src.fedoraproject.org/rpms/graphite2', 'https://example.com/fp/graphite2', 'https://tekton.example.com/runs/6-graphite2', 'completed', '2025-11-13 18:26:25', '2025-11-13 18:26:25', '2025-11-13 18:26:25', NULL, '2025-11-13 18:26:25', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (102, 6, 'glibc-2.39-2', 'glibc', 'glibc', '2.39-2', 'https://src.fedoraproject.org/rpms/glibc', 'https://example.com/fp/glibc', 'https://tekton.example.com/runs/6-glibc', 'completed', '2025-11-13 18:37:20', '2025-11-13 18:37:20', '2025-11-13 18:37:20', NULL, '2025-11-13 18:37:20', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (103, 6, 'libtalloc-2.4.2-1', 'libtalloc', 'libtalloc', '2.4.2-1', 'https://src.fedoraproject.org/rpms/libtalloc', 'https://example.com/fp/libtalloc', 'https://tekton.example.com/runs/6-libtalloc', 'completed', '2025-11-13 18:43:36', '2025-11-13 18:43:36', '2025-11-13 18:43:36', NULL, '2025-11-13 18:43:36', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (104, 6, 'libuser-0.64-7', 'libuser', 'libuser', '0.64-7', 'https://src.fedoraproject.org/rpms/libuser', 'https://example.com/fp/libuser', 'https://tekton.example.com/runs/6-libuser', 'completed', '2025-11-13 18:47:35', '2025-11-13 18:47:35', '2025-11-13 18:47:35', NULL, '2025-11-13 18:47:35', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (105, 6, 'mpdecimal-2.5.1-9', 'mpdecimal', 'mpdecimal', '2.5.1-9', 'https://src.fedoraproject.org/rpms/mpdecimal', 'https://example.com/fp/mpdecimal', 'https://tekton.example.com/runs/6-mpdecimal', 'completed', '2025-11-13 19:13:47', '2025-11-13 19:13:47', '2025-11-13 19:13:47', NULL, '2025-11-13 19:13:47', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (106, 6, 'nano-7.2-6', 'nano', 'nano', '7.2-6', 'https://src.fedoraproject.org/rpms/nano', 'https://example.com/fp/nano', 'https://tekton.example.com/runs/6-nano', 'completed', '2025-11-13 19:21:25', '2025-11-13 19:21:25', '2025-11-13 19:21:25', NULL, '2025-11-13 19:21:25', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (107, 6, 'ncurses-6.4-12.20240127', 'ncurses', 'ncurses', '6.4-12.20240127', 'https://src.fedoraproject.org/rpms/ncurses', 'https://example.com/fp/ncurses', 'https://tekton.example.com/runs/6-ncurses', 'completed', '2025-11-13 19:25:52', '2025-11-13 19:25:52', '2025-11-13 19:25:52', NULL, '2025-11-13 19:25:52', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (108, 6, 'rpcbind-1.2.6-4.rc2', 'rpcbind', 'rpcbind', '1.2.6-4.rc2', 'https://src.fedoraproject.org/rpms/rpcbind', 'https://example.com/fp/rpcbind', 'https://tekton.example.com/runs/6-rpcbind', 'completed', '2025-11-13 19:28:40', '2025-11-13 19:28:40', '2025-11-13 19:28:40', NULL, '2025-11-13 19:28:40', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (109, 6, 'sqlite-3.45.1-2', 'sqlite', 'sqlite', '3.45.1-2', 'https://src.fedoraproject.org/rpms/sqlite', 'https://example.com/fp/sqlite', 'https://tekton.example.com/runs/6-sqlite', 'completed', '2025-11-13 20:38:41', '2025-11-13 20:38:41', '2025-11-13 20:38:41', NULL, '2025-11-13 20:38:41', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (110, 6, 'sysfsutils-2.1.1-7', 'sysfsutils', 'sysfsutils', '2.1.1-7', 'https://src.fedoraproject.org/rpms/sysfsutils', 'https://example.com/fp/sysfsutils', 'https://tekton.example.com/runs/6-sysfsutils', 'completed', '2025-11-13 20:44:22', '2025-11-13 20:44:22', '2025-11-13 20:44:22', NULL, '2025-11-13 20:44:22', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (111, 6, 'tpm2-tools-5.6-2', 'tpm2-tools', 'tpm2-tools', '5.6-2', 'https://src.fedoraproject.org/rpms/tpm2-tools', 'https://example.com/fp/tpm2-tools', 'https://tekton.example.com/runs/6-tpm2-tools', 'completed', '2025-11-13 21:46:47', '2025-11-13 21:46:47', '2025-11-13 21:46:47', NULL, '2025-11-13 21:46:47', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (112, 6, 'texinfo-7.1-2', 'texinfo', 'texinfo', '7.1-2', 'https://src.fedoraproject.org/rpms/texinfo', 'https://example.com/fp/texinfo', 'https://tekton.example.com/runs/6-texinfo', 'completed', '2025-11-13 22:28:59', '2025-11-13 22:28:59', '2025-11-13 22:28:59', NULL, '2025-11-13 22:28:59', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (113, 6, 'unzip-6.0-63', 'unzip', 'unzip', '6.0-63', 'https://src.fedoraproject.org/rpms/unzip', 'https://example.com/fp/unzip', 'https://tekton.example.com/runs/6-unzip', 'completed', '2025-11-13 23:11:56', '2025-11-13 23:11:56', '2025-11-13 23:11:56', NULL, '2025-11-13 23:11:56', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (114, 6, 'trace-cmd-3.2-2', 'trace-cmd', 'trace-cmd', '3.2-2', 'https://src.fedoraproject.org/rpms/trace-cmd', 'https://example.com/fp/trace-cmd', 'https://tekton.example.com/runs/6-trace-cmd', 'completed', '2025-11-13 23:13:01', '2025-11-13 23:13:01', '2025-11-13 23:13:01', NULL, '2025-11-13 23:13:01', 'mock_user', NULL, NULL, NULL);
INSERT INTO public.mlops_job (id, mlops_batch_id, package_nvr, package_name, project_name, project_version, package_source_code_url, known_false_positives_url, tekton_url, status, created_at, started_at, completed_at, cancelled_at, last_updated_at, submitted_by, hostname, osh_scan_id, jira_link) VALUES (115, 6, 'util-linux-2.40-0.8.rc1', 'util-linux', 'util-linux', '2.40-0.8.rc1', 'https://src.fedoraproject.org/rpms/util-linux', 'https://example.com/fp/util-linux', 'https://tekton.example.com/runs/6-util-linux', 'completed', '2025-11-14 00:05:00', '2025-11-14 00:05:00', '2025-11-14 00:05:00', NULL, '2025-11-14 00:05:00', 'mock_user', NULL, NULL, NULL);


--
-- Data for Name: mlops_issue_details; Type: TABLE DATA; Schema: public; Owner: quarkus
--

INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (1, 104, 'def1', 'INTEGER_OVERFLOW', 'libuser-0.64/lib/config.c:152: tainted_data_return: Called function "read(fd, dest, left)", and a possible return value may be less than zero.
libuser-0.64/lib/config.c:152: assign: Assigning: "res" = "read(fd, dest, left)".
libuser-0.64/lib/config.c:164: overflow: The expression "left -= res" might be negative, but is used in a context that treats it as unsigned.
libuser-0.64/lib/config.c:152: overflow_sink: "left", which might be negative, is passed to "read(fd, dest, left)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  150|   		ssize_t res;
#  151|   
#  152|-> 		res = read(fd, dest, left);
#  153|   		if (res == 0)
#  154|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/config.c:152: tainted_data_return: Called function "read(fd, dest, left)", and a possible return value may be less than zero.
libuser-0.64/lib/config.c:152: assign: Assigning: "res" = "read(fd, dest, left)".
libuser-0.64/lib/config.c:164: overflow: The expression "left -= res" might be negative, but is used in a context that treats it as unsigned.
libuser-0.64/lib/config.c:152: overflow_sink: "left", which might be negative, is passed to "read(fd, dest, left)".
#  150|    ssize_t res;
#  151|   
#  152|->     res = read(fd, dest, left);
#  153|    if (res == 0)
#  154|        break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/lib/config.c:152: tainted_data_return: Called function "read(fd, dest, left)", and a possible return value may be less than zero.
libuser-0.64/lib/config.c:152: assign: Assigning: "res" = "read(fd, dest, left)".
libuser-0.64/lib/config.c:164: overflow: The expression "left -= res" might be negative, but is used in a context that treats it as unsigned.
libuser-0.64/lib/config.c:152: overflow_sink: "left", which might be negative, is passed to "read(fd, dest, left)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  150|   		ssize_t res;
#  151|   
#  152|-> 		res = read(fd, dest, left);
#  153|   		if (res == 0)
#  154|   			break;
(Example-1) Reason Marked as False Positive:
Only negative number that can be returned from read() is -1 and that is explicetly handled.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/lib/fs.c:239: tainted_data_return: Called function "write(dest_fd, p, left)", and a possible return value may be less than zero.
libuser-0.64/lib/fs.c:239: assign: Assigning: "out" = "write(dest_fd, p, left)".
libuser-0.64/lib/fs.c:249: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/lib/fs.c:239: overflow_sink: "left", which might have overflowed, is passed to "write(dest_fd, p, left)".
#  237|   			ssize_t out;
#  238|   
#  239|-> 			out = write(dest_fd, p, left);
#  240|   			if (out == -1) {
#  241|   				if (errno == EINTR)
(Example-2) Reason Marked as False Positive:
Only negative number that can be returned from write() is -1 and that is explicetly handled.

', '2025-11-17 21:39:06.934266');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (2, 104, 'def2', 'UNINIT', 'libuser-0.64/lib/getdate.y:786: var_decl: Declaring variable "tm" without initializer.
libuser-0.64/lib/getdate.y:835: uninit_use: Using uninitialized value "tm". Field "tm.tm_wday" is uninitialized.
#  833|     tm.tm_sec += yy.RelSeconds;
#  834|     tm.tm_isdst = -1;
#  835|->   tm0 = tm;
#  836|   
#  837|     Start = mktime (&tm);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/getdate.y: var_decl: Declaring variable "tm" without initializer.
libuser-0.64/lib/getdate.y: uninit_use: Using uninitialized value "tm". Field "tm.tm_wday" is uninitialized.
#     tm.tm_sec += yy.RelSeconds;
#     tm.tm_isdst = -1;
#->   tm0 = tm;
#    
#     Start = mktime (&tm);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.y:786: var_decl: Declaring variable "tm" without initializer.
libuser-0.64/lib/getdate.y:835: uninit_use: Using uninitialized value "tm". Field "tm.tm_wday" is uninitialized.
#  833|     tm.tm_sec += yy.RelSeconds;
#  834|     tm.tm_isdst = -1;
#  835|->   tm0 = tm;
#  836|   
#  837|     Start = mktime (&tm);
(Example-1) Reason Marked as False Positive:
`tm0` is used just as backup and in partcular case (Start == -1 and yy.HaveZone) tm is assigned back to tm0 (tm = tm0). But after that mktime() is called a few lines later so the wday is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.c:1068: var_decl: Declaring variable "yylval" without initializer.
libuser-0.64/lib/getdate.c:1893: uninit_use: Using uninitialized value "yylval".
# 1891|   
# 1892|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1893|->   *++yyvsp = yylval;
# 1894|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1895|
(Example-2) Reason Marked as False Positive:
Bison generated code. LGTM

', '2025-11-17 21:39:06.93427');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (3, 104, 'def3', 'RESOURCE_LEAK', 'libuser-0.64/lib/config.c:480: alloc_fn: Storage is returned from allocation function "lu_cfg_read".
libuser-0.64/lib/config.c:480: var_assign: Assigning: "answers" = storage returned from "lu_cfg_read(context, key, NULL)".
libuser-0.64/lib/config.c:488: leaked_storage: Variable "answers" going out of scope leaks the storage it points to.
#  486|   		ret = context->scache->cache(context->scache, default_value);
#  487|   
#  488|-> 	return ret;
#  489|   }
#  490|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/config.c: alloc_fn: Storage is returned from allocation function "lu_cfg_read".
libuser-0.64/lib/config.c: var_assign: Assigning: "answers" = storage returned from "lu_cfg_read(context, key, NULL)".
libuser-0.64/lib/config.c: leaked_storage: Variable "answers" going out of scope leaks the storage it points to.
#  ... (rest of the trace, ignoring line numbers)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
libuser-0.64/lib/config.c:480: alloc_fn: Storage is returned from allocation function "lu_cfg_read".
libuser-0.64/lib/config.c:480: var_assign: Assigning: "answers" = storage returned from "lu_cfg_read(context, key, NULL)".
libuser-0.64/lib/config.c:488: leaked_storage: Variable "answers" going out of scope leaks the storage it points to.
#  486|   		ret = context->scache->cache(context->scache, default_value);
#  487|   
#  488|-> 	return ret;
#  489|   }
#  490|
(Example-1) Reason Marked as False Positive:
In our case checking answers is redundant. It can never happed that `answers` is not null and `answers->data` is. So the `answers` never leaks.

', '2025-11-17 21:39:06.934271');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (4, 104, 'def4', 'OVERRUN', 'libuser-0.64/lib/getdate.c:1081: assignment: Assigning: "yystacksize" = "200L".
libuser-0.64/lib/getdate.c:1168: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libuser-0.64/lib/getdate.c:1179: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 4 bytes).
libuser-0.64/lib/getdate.c:1195: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 4 bytes.
# 1193|         YY_IGNORE_USELESS_CAST_END
# 1194|   
# 1195|->       if (yyss + yystacksize - 1 <= yyssp)
# 1196|           YYABORT;
# 1197|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/getdate.c: assignment: Assigning: "yystacksize" = "200L".
libuser-0.64/lib/getdate.c: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libuser-0.64/lib/getdate.c: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 4 bytes).
libuser-0.64/lib/getdate.c: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 4 bytes.
#->       if (yyss + yystacksize - 1 <= yyssp)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libuser-0.64/lib/getdate.c:1081: assignment: Assigning: "yystacksize" = "200L".
libuser-0.64/lib/getdate.c:1168: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libuser-0.64/lib/getdate.c:1179: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 4 bytes).
libuser-0.64/lib/getdate.c:1195: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 4 bytes.
# 1193|         YY_IGNORE_USELESS_CAST_END
# 1194|   
# 1195|->       if (yyss + yystacksize - 1 <= yyssp)
# 1196|           YYABORT;
# 1197|       }
(Example-1) Reason Marked as False Positive:
Bison generated code. LGTM

', '2025-11-17 21:39:06.934271');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (9, 109, 'def1', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3_analyzer.c:95826: assign: Assigning: "pIn1" = "&aMem[pOp->p1]".
sqlite-src-3450100/sqlite3_analyzer.c:95865: equal: The address of "pIn1->u.r" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3_analyzer.c:95865: equal: The address of "pIn1->u.i" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3_analyzer.c:95865: overlapping_assignment: Assigning "pIn1->u.i" to "pIn1->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3_analyzer.c:95865: target_type: "pIn1->u.r" has type "double".
sqlite-src-3450100/sqlite3_analyzer.c:95865: source_type: "pIn1->u.i" has type "long long".
#95863|                 pIn1->flags &= ~MEM_Int;
#95864|               }else{
#95865|->               pIn1->u.r = (double)pIn1->u.i;
#95866|                 pIn1->flags |= MEM_Real;
#95867|                 pIn1->flags &= ~MEM_Int;', 'TRUE POSITIVE', 'Assignment at line 95865 (`pIn1->u.r = (double)pIn1->u.i;`) involves overlapping memory locations with different types (`double` and `long long`), indicating a potential type punning vulnerability (CWE-698), with no clear mitigating evidence in the provided code.', '**Overlapping Memory Locations with Different Types**'': The CVE report highlights that `pIn1->u.r` (type `double`) and `pIn1->u.i` (type `long long`) have overlapping memory locations (lines 95865, CVE report). This is confirmed by the assignment `pIn1->u.r = (double)pIn1->u.i;` (line 95865, source code), indicating a potential type punning vulnerability.

**Explicit Type Casting but Insufficient for Safety**'': Although the source code explicitly casts `pIn1->u.i` to `double` (line 95865), this does not mitigate the underlying issue of overlapping memory locations being used for different data types, which is a security concern (e.g., CWE-698: Data Type Problems).

**Direct Correlation with CWE Description**'': The identified behavior directly correlates with the description of a vulnerability involving overlapping assignments with different types, aligning with the reported CVE''s error trace and the provided source code context.

**No Clear False Positive Evidence**'': There is no definitive proof within the provided code that the described vulnerability cannot occur under any circumstances. The explicit operations performed (type casting and assignment) do not negate the potential vulnerability introduced by the overlapping memory use for different types.', 'Investigate the usage of `pIn1->u.r` and `pIn1->u.i` after the assignment to determine potential security impacts.

Analyze the memory management practices for `aMem` and `pOp->p1` to assess the likelihood of out-of-bounds access or other memory-related vulnerabilities.

Evaluate the compiler''s behavior regarding the overlapping memory locations, considering optimizations and target architectures.', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.949326');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (5, 104, 'def5', 'INTEGER_OVERFLOW', 'libuser-0.64/lib/fs.c:239: tainted_data_return: Called function "write(dest_fd, p, left)", and a possible return value may be less than zero.
libuser-0.64/lib/fs.c:239: assign: Assigning: "out" = "write(dest_fd, p, left)".
libuser-0.64/lib/fs.c:249: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/lib/fs.c:239: overflow_sink: "left", which might have overflowed, is passed to "write(dest_fd, p, left)".
#  237|   			ssize_t out;
#  238|   
#  239|-> 			out = write(dest_fd, p, left);
#  240|   			if (out == -1) {
#  241|   				if (errno == EINTR)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/fs.c:239: tainted_data_return: Called function "write(dest_fd, p, left)", and a possible return value may be less than zero.
libuser-0.64/lib/fs.c:239: assign: Assigning: "out" = "write(dest_fd, p, left)".
libuser-0.64/lib/fs.c:249: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/lib/fs.c:239: overflow_sink: "left", which might have overflowed, is passed to "write(dest_fd, p, left)".
#  237|    ssize_t out;
#  238|   
#  239|-> out = write(dest_fd, p, left);
#  240|    if (out == -1) {
#  241|    if (errno == EINTR)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/lib/fs.c:239: tainted_data_return: Called function "write(dest_fd, p, left)", and a possible return value may be less than zero.
libuser-0.64/lib/fs.c:239: assign: Assigning: "out" = "write(dest_fd, p, left)".
libuser-0.64/lib/fs.c:249: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/lib/fs.c:239: overflow_sink: "left", which might have overflowed, is passed to "write(dest_fd, p, left)".
#  237|   			ssize_t out;
#  238|   
#  239|-> 			out = write(dest_fd, p, left);
#  240|   			if (out == -1) {
#  241|   				if (errno == EINTR)
(Example-1) Reason Marked as False Positive:
Only negative number that can be returned from write() is -1 and that is explicetly handled.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/modules/files.c:201: tainted_data_return: Called function "write(ofd, p, left)", and a possible return value may be less than zero.
libuser-0.64/modules/files.c:201: assign: Assigning: "out" = "write(ofd, p, left)".
libuser-0.64/modules/files.c:211: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/modules/files.c:201: overflow_sink: "left", which might have overflowed, is passed to "write(ofd, p, left)".
#  199|   			ssize_t out;
#  200|   
#  201|-> 			out = write(ofd, p, left);
#  202|   			if (out == -1) {
#  203|   				if (errno == EINTR)
(Example-2) Reason Marked as False Positive:
Only negative number that can be returned from write() is -1 and that is explicetly handled.

', '2025-11-17 21:39:06.934271');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (6, 104, 'def6', 'UNINIT', 'libuser-0.64/lib/getdate.c:1089: var_decl: Declaring variable "yyvsa" without initializer.
libuser-0.64/lib/getdate.c:1090: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libuser-0.64/lib/getdate.c:1180: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1178|             YYNOMEM;
# 1179|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1180|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1181|   #  undef YYSTACK_RELOCATE
# 1182|           if (yyss1 != yyssa)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/getdate.c:1089: var_decl: Declaring variable "yyvsa" without initializer.
libuser-0.64/lib/getdate.c:1090: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libuser-0.64/lib/getdate.c:1180: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1178|             YYNOMEM;
# 1179|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1180|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1181|   #  undef YYSTACK_RELOCATE
# 1182|           if (yyss1 != yyssa)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.c:1089: var_decl: Declaring variable "yyvsa" without initializer.
libuser-0.64/lib/getdate.c:1090: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libuser-0.64/lib/getdate.c:1180: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1178|             YYNOMEM;
# 1179|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1180|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1181|   #  undef YYSTACK_RELOCATE
# 1182|           if (yyss1 != yyssa)
(Example-1) Reason Marked as False Positive:
Bison generated code. LGTM

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.c:1068: var_decl: Declaring variable "yylval" without initializer.
libuser-0.64/lib/getdate.c:1893: uninit_use: Using uninitialized value "yylval".
# 1891|   
# 1892|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1893|->   *++yyvsp = yylval;
# 1894|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1895|
(Example-2) Reason Marked as False Positive:
Bison generated code. LGTM

', '2025-11-17 21:39:06.934272');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (7, 104, 'def7', 'INTEGER_OVERFLOW', 'libuser-0.64/modules/files.c:201: tainted_data_return: Called function "write(ofd, p, left)", and a possible return value may be less than zero.
libuser-0.64/modules/files.c:201: assign: Assigning: "out" = "write(ofd, p, left)".
libuser-0.64/modules/files.c:211: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/modules/files.c:201: overflow_sink: "left", which might have overflowed, is passed to "write(ofd, p, left)".
#  199|   			ssize_t out;
#  200|   
#  201|-> 			out = write(ofd, p, left);
#  202|   			if (out == -1) {
#  203|   				if (errno == EINTR)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/modules/files.c:201: tainted_data_return: Called function "write(ofd, p, left)", and a possible return value may be less than zero.
libuser-0.64/modules/files.c:201: assign: Assigning: "out" = "write(ofd, p, left)".
libuser-0.64/modules/files.c:211: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/modules/files.c:201: overflow_sink: "left", which might have overflowed, is passed to "write(ofd, p, left)".
#  199|    ssize_t out;
#  200|   
#  201|-> out = write(ofd, p, left);
#  202|    if (out == -1) {
#  203|    if (errno == EINTR)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/modules/files.c:201: tainted_data_return: Called function "write(ofd, p, left)", and a possible return value may be less than zero.
libuser-0.64/modules/files.c:201: assign: Assigning: "out" = "write(ofd, p, left)".
libuser-0.64/modules/files.c:211: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/modules/files.c:201: overflow_sink: "left", which might have overflowed, is passed to "write(ofd, p, left)".
#  199|   			ssize_t out;
#  200|   
#  201|-> 			out = write(ofd, p, left);
#  202|   			if (out == -1) {
#  203|   				if (errno == EINTR)
(Example-1) Reason Marked as False Positive:
Only negative number that can be returned from write() is -1 and that is explicetly handled.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libuser-0.64/lib/fs.c:239: tainted_data_return: Called function "write(dest_fd, p, left)", and a possible return value may be less than zero.
libuser-0.64/lib/fs.c:239: assign: Assigning: "out" = "write(dest_fd, p, left)".
libuser-0.64/lib/fs.c:249: overflow: The expression "left" is considered to have possibly overflowed.
libuser-0.64/lib/fs.c:239: overflow_sink: "left", which might have overflowed, is passed to "write(dest_fd, p, left)".
#  237|   			ssize_t out;
#  238|   
#  239|-> 			out = write(dest_fd, p, left);
#  240|   			if (out == -1) {
#  241|   				if (errno == EINTR)
(Example-2) Reason Marked as False Positive:
Only negative number that can be returned from write() is -1 and that is explicetly handled.

', '2025-11-17 21:39:06.934272');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (8, 104, 'def8', 'UNINIT', 'libuser-0.64/lib/getdate.c:1068: var_decl: Declaring variable "yylval" without initializer.
libuser-0.64/lib/getdate.c:1893: uninit_use: Using uninitialized value "yylval".
# 1891|   
# 1892|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1893|->   *++yyvsp = yylval;
# 1894|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1895|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libuser-0.64/lib/getdate.c:1068: var_decl: Declaring variable "yylval" without initializer.
libuser-0.64/lib/getdate.c:1893: uninit_use: Using uninitialized value "yylval".
# 1891|   
# 1892|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1893|->   *++yyvsp = yylval;
# 1894|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1895|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.c:1068: var_decl: Declaring variable "yylval" without initializer.
libuser-0.64/lib/getdate.c:1893: uninit_use: Using uninitialized value "yylval".
# 1891|   
# 1892|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1893|->   *++yyvsp = yylval;
# 1894|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1895|
(Example-1) Reason Marked as False Positive:
Bison generated code. LGTM

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libuser-0.64/lib/getdate.c:1089: var_decl: Declaring variable "yyvsa" without initializer.
libuser-0.64/lib/getdate.c:1090: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libuser-0.64/lib/getdate.c:1180: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1178|             YYNOMEM;
# 1179|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1180|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1181|   #  undef YYSTACK_RELOCATE
# 1182|           if (yyss1 != yyssa)
(Example-2) Reason Marked as False Positive:
Bison generated code. LGTM

', '2025-11-17 21:39:06.934273');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (10, 109, 'def2', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#     if( iRound<0 ){
#       iRound = p->iDP - iRound;
#->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#         iRound = 1;
#         p->zBuf[i--] = ''0'';', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';
(Example-1) Reason Marked as False Positive:
There is while that decrements the i at elast once.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77693: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77691|       if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|->       pSrcEnd = pCArray->apEnd[k];
#77694|       }
#77695|     }
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug: https://sqlite.org/forum/forumpost/d0e144c233c7b286 Upstream also added some asserts to future releases so that static analysers are not confused. In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949329');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (11, 109, 'def3', 'BAD_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:150489: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150502: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150509: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150487|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150488|     if( (rc&0xff)==SQLITE_ABORT ){
#150489|->     sqlite3_free_table(&res.azResult[1]);
#150490|       if( res.zErrMsg ){
#150491|         if( pzErrMsg ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#     if( (rc&0xff)==SQLITE_ABORT ){
#->     sqlite3_free_table(&res.azResult[1]);
#       if( res.zErrMsg ){
#         if( pzErrMsg ){', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3_analyzer.c:150489: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150502: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150509: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150487|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150488|     if( (rc&0xff)==SQLITE_ABORT ){
#150489|->     sqlite3_free_table(&res.azResult[1]);
#150490|       if( res.zErrMsg ){
#150491|         if( pzErrMsg ){
(Example-1) Reason Marked as False Positive:
res.azResult is preoperly allocated by malloc in line n.140 (src/table.c)

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3.c:150465: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150478: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150485: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150463|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150464|     if( (rc&0xff)==SQLITE_ABORT ){
#150465|->     sqlite3_free_table(&res.azResult[1]);
#150466|       if( res.zErrMsg ){
#150467|         if( pzErrMsg ){
(Example-2) Reason Marked as False Positive:
res.azResult is preoperly allocated by malloc in line n.140 (src/table.c)

', '2025-11-17 21:39:06.94933');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (12, 109, 'def4', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78566: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78564|           }
#78565|         }
#78566|->       szNew[i+1] += sz;
#78567|         cntNew[i]--;
#78568|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78566: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78564|           }
#78565|         }
#78566|->       szNew[i+1] += sz;
#78567|         cntNew[i]--;
#78568|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78566: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78564|           }
#78565|         }
#78566|->       szNew[i+1] += sz;
#78567|         cntNew[i]--;
#78568|       }
(Example-1) Reason Marked as False Positive:
This is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78581: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78579|           }
#78580|         }
#78581|->       szNew[i+1] -= sz;
#78582|       }
#78583|       if( cntNew[i]>=b.nCell ){
(Example-2) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

', '2025-11-17 21:39:06.94933');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (13, 109, 'def5', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3.c:95886: assign: Assigning: "pIn1" = "&aMem[pOp->p1]".
sqlite-src-3450100/sqlite3.c:95904: equal: The address of "pIn1->u.r" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3.c:95904: equal: The address of "pIn1->u.i" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3.c:95904: overlapping_assignment: Assigning "pIn1->u.i" to "pIn1->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3.c:95904: target_type: "pIn1->u.r" has type "double".
sqlite-src-3450100/sqlite3.c:95904: source_type: "pIn1->u.i" has type "long long".
#95902|           pIn1->flags &= ~MEM_Int;
#95903|         }else{
#95904|->         pIn1->u.r = (double)pIn1->u.i;
#95905|           pIn1->flags |= MEM_Real;
#95906|           pIn1->flags &= ~(MEM_Int|MEM_Str);', 'TRUE POSITIVE', 'Overlapping assignment of different types (`double` and `long long`) at `sqlite-src-3450100/sqlite3.c:95904` occurs, despite explicit casting, with no evidence in the provided code snippet to suggest safe management of this memory overlap, aligning with the CVE''s described vulnerability.', 'Direct evidence of overlapping assignment with different types at `sqlite-src-3450100/sqlite3.c:95904`, where `pIn1->u.r` (type `double`) is assigned the value of `pIn1->u.i` (type `long long`) with overlapping memory locations.

Explicit type casting from `long long` to `double` at `#95904` (`pIn1->u.r = (double)pIn1->u.i;`), which, despite being an explicit cast, does not mitigate the fact that the memory locations overlap and are used for different data types, aligning with the CVE''s description of ''overlapping memory locations and different types''.

Immediate preceding and following operations (`#95902`, `#95905`, `#95906`) modify flags related to the type of `pIn1` (clearing `MEM_Int`, setting `MEM_Real`, and clearing `MEM_Int|MEM_Str`), indicating an intentional type change, but not altering the fact that the memory overlap with different types occurs.

No evidence within the provided code snippet suggests that the memory overlap is safely managed or that the type change mitigates the vulnerability described in the CVE, thus necessitating a TRUE POSITIVE conclusion based on the strict guidelines provided.', 'Verify the sizes of `double` and `long long` on the specific platform(s) the SQLite version is intended for or has been compiled on.

Investigate the memory allocation and management strategies for `aMem` and `pIn1` to determine if there are safeguards against type size mismatches.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/src/malloc.c file:
159| int sqlite3MallocInit(void){
160|   int rc;
161|   if( sqlite3GlobalConfig.m.xMalloc==0 ){
162|     sqlite3MemSetDefault();
163|   }
164|   mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
165|   if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512
166|       || sqlite3GlobalConfig.nPage<=0 ){
167|     sqlite3GlobalConfig.pPage = 0;
168|     sqlite3GlobalConfig.szPage = 0;
169|   }
170|   rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
171|   if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
172|   return rc;
173| }


346| int sqlite3MallocSize(const void *p){
347|   assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
348|   return sqlite3GlobalConfig.m.xSize((void*)p);
349| }

*** Examples ***
', '2025-11-17 21:39:06.949331');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (14, 109, 'def6', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:248896: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3_analyzer.c:249025: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#249023|         }else{
#249024|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249025|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249026|         }
#249027|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }
(Example-1) Reason Marked as False Positive:
There is a check, that check if pCsr->pExpr is not NULL.
Only when it is not NULL this is executed.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

', '2025-11-17 21:39:06.949331');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (15, 109, 'def7', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-1) Reason Marked as False Positive:
From sqlite''s comments:
Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.

sqlite3DbFree contains null pointer check.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-2) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

', '2025-11-17 21:39:06.949331');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (16, 109, 'def8', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3_analyzer.c:201059: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:201059: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3_analyzer.c:201066: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:201066: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3_analyzer.c:201066: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3_analyzer.c:201070: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201068|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201069|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201070|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201071|       }
#201072|     }', 'TRUE POSITIVE', 'Explicit 64-to-32-bit cast overflow on `pPhrase->iHead` (line #201069) propagates through arithmetic operations, causing potential overflows (`#201066`) and underflows (`#201066`), ultimately reaching a vulnerable sink (`fts3SnippetAdvance` at `#201070`) without explicit bounds checking.', '1. **Explicit Cast Overflow**: The CVE report highlights a `cast_overflow` at `sqlite-src-3450100/sqlite3_analyzer.c:201059`, indicating a truncation from 64 to 32 bits on `pPhrase->iHead`. This is a direct match with the provided code context, specifically at line `#201069` where `fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1)` is called, implying `iHead` (a 64-bit value) is potentially truncated when assigned to `iEnd` (implied to be 32-bit based on the error).

2. **Overflow Propagation**: The error at `#201066` mentions an `overflow` in the expression `iEnd - pIter->nSnippet` due to `iEnd` having overflowed. This suggests that the potential truncation error from `pPhrase->iHead` to `iEnd` has propagated, affecting subsequent arithmetic operations.

3. **Underflow and Assignment**: The same line `#201066` also reports an `underflow` for `iEnd - pIter->nSnippet + 1`, which is then assigned to `iStart`. This underflow, combined with the previous overflow, indicates a clear vulnerability in the arithmetic operations involving `iStart`.

4. **Vulnerable Sink**: The final error at `#201070` identifies `iStart`, which might have underflowed, being passed to `fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)`. This demonstrates a direct path from the initial cast overflow to a potentially vulnerable function call, leveraging the underflowed value.

5. **Lack of Explicit Bounds Checking**: Within the provided code context, there is no explicit bounds checking or handling for the scenarios described in the CVE report. This absence, combined with the direct evidence of potential overflows and underflows, supports the conclusion that this is not a false positive.', 'Investigate external constraints or conditions that might limit the range of `pPhrase->iHead` and `pIter->nSnippet`, potentially mitigating the overflow/underflow risks.

Analyze the calling context of the snippet to identify any implicit or explicit bounds checking on variables involved in the potentially vulnerable expressions.

Evaluate the functionality of `fts3SnippetAdvance` to determine its behavior with potentially underflowed input values, assessing if this mitigates the identified vulnerability.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/ext/fts3/fts3_snippet.c file:
249| static int fts3ExprIterate2(
250|   Fts3Expr *pExpr,                /* Expression to iterate phrases of */
251|   int *piPhrase,                  /* Pointer to phrase counter */
252|   int (*x)(Fts3Expr*,int,void*),  /* Callback function to invoke for phrases */
253|   void *pCtx                      /* Second argument to pass to callback */
254| ){
255|   int rc;                         /* Return code */
256|   int eType = pExpr->eType;     /* Type of expression node pExpr */
257| 
258|   if( eType!=FTSQUERY_PHRASE ){
259|     assert( pExpr->pLeft && pExpr->pRight );
260|     rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);
261|     if( rc==SQLITE_OK && eType!=FTSQUERY_NOT ){
262|       rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);
263|     }
264|   }else{
265|     rc = x(pExpr, *piPhrase, pCtx);
266|     (*piPhrase)++;
267|   }
268|   return rc;
269| }
270| 
271| /*
272| ** Iterate through all phrase nodes in an FTS3 query, except those that
273| ** are part of a sub-tree that is the right-hand-side of a NOT operator.
274| ** For each phrase node found, the supplied callback function is invoked.
275| **
276| ** If the callback function returns anything other than SQLITE_OK, 
277| ** the iteration is abandoned and the error code returned immediately.
278| ** Otherwise, SQLITE_OK is returned after a callback has been made for
279| ** all eligible phrase nodes.
280| */
281| int sqlite3Fts3ExprIterate(
282|   Fts3Expr *pExpr,                /* Expression to iterate phrases of */
283|   int (*x)(Fts3Expr*,int,void*),  /* Callback function to invoke for phrases */
284|   void *pCtx                      /* Second argument to pass to callback */
285| ){
286|   int iPhrase = 0;                /* Variable used as the phrase counter */
287|   return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx);
288| }
289| 
290| /*
291| ** This is an sqlite3Fts3ExprIterate() callback used while loading the 
292| ** doclists for each phrase into Fts3Expr.aDoclist[]/nDoclist. See also
293| ** fts3ExprLoadDoclists().
294| */
295| static int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
296|   int rc = SQLITE_OK;
297|   Fts3Phrase *pPhrase = pExpr->pPhrase;
298|   LoadDoclistCtx *p = (LoadDoclistCtx *)ctx;
299| 
300|   UNUSED_PARAMETER(iPhrase);
301| 
302|   p->nPhrase++;
303|   p->nToken += pPhrase->nToken;
304| 
305|   return rc;
306| }
307| 
308| /*
309| ** Load the doclists for each phrase in the query associated with FTS3 cursor
310| ** pCsr. 
311| **
312| ** If pnPhrase is not NULL, then *pnPhrase is set to the number of matchable 
313| ** phrases in the expression (all phrases except those directly or 
314| ** indirectly descended from the right-hand-side of a NOT operator). If 
315| ** pnToken is not NULL, then it is set to the number of tokens in all
316| ** matchable phrases of the expression.
317| */
318| static int fts3ExprLoadDoclists(
319|   Fts3Cursor *pCsr,               /* Fts3 cursor for current query */
320|   int *pnPhrase,                  /* OUT: Number of phrases in query */
321|   int *pnToken                    /* OUT: Number of tokens in query */
322| ){
323|   int rc;                         /* Return Code */
324|   LoadDoclistCtx sCtx = {0,0,0};  /* Context for sqlite3Fts3ExprIterate() */
325|   sCtx.pCsr = pCsr;
326|   rc = sqlite3Fts3ExprIterate(pCsr->pExpr,fts3ExprLoadDoclistsCb,(void*)&sCtx);
327|   if( pnPhrase ) *pnPhrase = sCtx.nPhrase;
328|   if( pnToken ) *pnToken = sCtx.nToken;
329|   return rc;
330| }
331| 
332| static int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
333|   (*(int *)ctx)++;
334|   pExpr->iPhrase = iPhrase;
335|   return SQLITE_OK;
336| }
337| static int fts3ExprPhraseCount(Fts3Expr *pExpr){
338|   int nPhrase = 0;
339|   (void)sqlite3Fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);
340|   return nPhrase;
341| }
342| 
343| /*
344| ** Advance the position list iterator specified by the first two 
345| ** arguments so that it points to the first element with a value greater
346| ** than or equal to parameter iNext.
347| */
348| static void fts3SnippetAdvance(char **ppIter, i64 *piIter, int iNext){
349|   char *pIter = *ppIter;
350|   if( pIter ){
351|     i64 iIter = *piIter;
352| 
353|     while( iIter<iNext ){
354|       if( 0==(*pIter & 0xFE) ){
355|         iIter = -1;
356|         pIter = 0;
357|         break;
358|       }
359|       fts3GetDeltaPosition(&pIter, &iIter);
360|     }
361| 
362|     *piIter = iIter;
363|     *ppIter = pIter;
364|   }
365| }
366| 
367| /*
368| ** Advance the snippet iterator to the next candidate snippet.
369| */
370| static int fts3SnippetNextCandidate(SnippetIter *pIter){
371|   int i;                          /* Loop counter */
372| 
373|   if( pIter->iCurrent<0 ){
374|     /* The SnippetIter object has just been initialized. The first snippet
375|     ** candidate always starts at offset 0 (even if this candidate has a
376|     ** score of 0.0).
377|     */
378|     pIter->iCurrent = 0;
379| 
380|     /* Advance the ''head'' iterator of each phrase to the first offset that
381|     ** is greater than or equal to (iNext+nSnippet).
382|     */
383|     for(i=0; i<pIter->nPhrase; i++){
384|       SnippetPhrase *pPhrase = &pIter->aPhrase[i];
385|       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);
386|     }
387|   }else{
388|     int iStart;
389|     int iEnd = 0x7FFFFFFF;
390| 
391|     for(i=0; i<pIter->nPhrase; i++){
392|       SnippetPhrase *pPhrase = &pIter->aPhrase[i];
393|       if( pPhrase->pHead && pPhrase->iHead<iEnd ){
394|         iEnd = pPhrase->iHead;
395|       }
396|     }
397|     if( iEnd==0x7FFFFFFF ){
398|       return 1;
399|     }
400| 
401|     pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;
402|     for(i=0; i<pIter->nPhrase; i++){
403|       SnippetPhrase *pPhrase = &pIter->aPhrase[i];
404|       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
405|       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
406|     }
407|   }
408| 
409|   return 0;
410| }
411| 
412| /*
413| ** Retrieve information about the current candidate snippet of snippet 
414| ** iterator pIter.
415| */
416| static void fts3SnippetDetails(
417|   SnippetIter *pIter,             /* Snippet iterator */
418|   u64 mCovered,                   /* Bitmask of phrases already covered */
419|   int *piToken,                   /* OUT: First token of proposed snippet */
420|   int *piScore,                   /* OUT: "Score" for this snippet */
421|   u64 *pmCover,                   /* OUT: Bitmask of phrases covered */
422|   u64 *pmHighlight                /* OUT: Bitmask of terms to highlight */
423| ){
424|   int iStart = pIter->iCurrent;   /* First token of snippet */
425|   int iScore = 0;                 /* Score of this snippet */
426|   int i;                          /* Loop counter */
427|   u64 mCover = 0;                 /* Mask of phrases covered by this snippet */
428|   u64 mHighlight = 0;             /* Mask of tokens to highlight in snippet */
429| 
430|   for(i=0; i<pIter->nPhrase; i++){
431|     SnippetPhrase *pPhrase = &pIter->aPhrase[i];
432|     if( pPhrase->pTail ){
433|       char *pCsr = pPhrase->pTail;
434|       i64 iCsr = pPhrase->iTail;
435| 
436|       while( iCsr<(iStart+pIter->nSnippet) && iCsr>=iStart ){
437|         int j;
438|         u64 mPhrase = (u64)1 << (i%64);
439|         u64 mPos = (u64)1 << (iCsr - iStart);
440|         assert( iCsr>=iStart && (iCsr - iStart)<=64 );
441|         assert( i>=0 );
442|         if( (mCover|mCovered)&mPhrase ){
443|           iScore++;
444|         }else{
445|           iScore += 1000;
446|         }
447|         mCover |= mPhrase;
448| 
449|         for(j=0; j<pPhrase->nToken; j++){

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3_analyzer.c:201059: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:201059: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201067|       for(i=0; i<pIter->nPhrase; i++){
#201068|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201069|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201070|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201071|       }
(Example-1) Reason Marked as False Positive:
iCol in this case can not be bigger that i16, as the condition in for loop look looks as follows:
for(iCol=0; iCol<pTab->nCol; iCol++){ and pTab->nCol is i16

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3.c:201042: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3.c:201046: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
#201048|     }
(Example-2) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

', '2025-11-17 21:39:06.949332');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (17, 109, 'def9', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:66006: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:66020: use_after_free: Using freed pointer "pWal->apWiData".
#66018|           }
#66019|         }
#66020|->       pWal->apWiData[iPg] = aShare;
#66021|         SEH_SET_ON_ERROR(0,0);
#66022|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:66006: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:66020: use_after_free: Using freed pointer "pWal->apWiData".
#66018|           }
#66019|         }
#66020|->       pWal->apWiData[iPg] = aShare;
#66021|         SEH_SET_ON_ERROR(0,0);
#66022|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:66006: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:66020: use_after_free: Using freed pointer "pWal->apWiData".
#66018|           }
#66019|         }
#66020|->       pWal->apWiData[iPg] = aShare;
#66021|         SEH_SET_ON_ERROR(0,0);
#66022|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);
(Example-1) Reason Marked as False Positive:
wallIndexAppend does not free pWal->apWiData, but reallocates it.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:66030: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:66044: use_after_free: Using freed pointer "pWal->apWiData".
#66042|           }
#66043|         }
#66044|->       pWal->apWiData[iPg] = aShare;
#66045|         SEH_SET_ON_ERROR(0,0);
#66046|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);
(Example-2) Reason Marked as False Positive:
It is realloc, not free.

', '2025-11-17 21:39:06.949332');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (23, 109, 'def15', 'UNINIT', 'sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204899: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204897|         j++;
#204898|       }
#204899|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204900|       return j+1;
#204901|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204899: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204897|         j++;
#204898|       }
#204899|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204900|       return j+1;
#204901|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204899: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204897|         j++;
#204898|       }
#204899|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204900|       return j+1;
#204901|     }
(Example-1) Reason Marked as False Positive:
The opcode is correctly initilized to JSONB_TEXT before jumping to the parse_string flag.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204923: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204921|         j++;
#204922|       }
#204923|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204924|       return j+1;
#204925|     }
(Example-2) Reason Marked as False Positive:
opcode is initialized everytime the code steps into parse_string.

', '2025-11-17 21:39:06.949334');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (18, 109, 'def10', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78581: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78579|           }
#78580|         }
#78581|->       szNew[i+1] -= sz;
#78582|       }
#78583|       if( cntNew[i]>=b.nCell ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78581: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78579|           }
#78580|         }
#78581|->       szNew[i+1] -= sz;
#78582|       }
#78583|       if( cntNew[i]>=b.nCell );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78581: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78579|           }
#78580|         }
#78581|->       szNew[i+1] -= sz;
#78582|       }
#78583|       if( cntNew[i]>=b.nCell ){
(Example-1) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78553: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78548: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:78566: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78564|           }
#78565|         }
#78566|->       szNew[i+1] += sz;
#78567|         cntNew[i]--;
#78568|       }
(Example-2) Reason Marked as False Positive:
This is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

', '2025-11-17 21:39:06.949332');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (19, 109, 'def11', 'BAD_FREE', 'sqlite-src-3450100/shell.c:15039: array_address: Taking address of array """".
sqlite-src-3450100/shell.c:15039: assign: Assigning: "zSchema" = """".
sqlite-src-3450100/shell.c:15069: incorrect_free: "sqlite3_bind_text" frees incorrect pointer "zSchema".
#15067|     }
#15068|     if( rc==SQLITE_OK ){
#15069|->     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);
#15070|     }
#15071|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c: array_address: Taking address of array """".
sqlite-src-3450100/shell.c: assign: Assigning: "zSchema" = """".
sqlite-src-3450100/shell.c: incorrect_free: "sqlite3_bind_text" frees incorrect pointer "zSchema".
#     }
#     if( rc==SQLITE_OK ){
#->     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);
#     }
#     ', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/shell.c:15039: array_address: Taking address of array """".
sqlite-src-3450100/shell.c:15039: assign: Assigning: "zSchema" = """".
sqlite-src-3450100/shell.c:15069: incorrect_free: "sqlite3_bind_text" frees incorrect pointer "zSchema".
#15067|     }
#15068|     if( rc==SQLITE_OK ){
#15069|->     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);
#15070|     }
#15071|
(Example-1) Reason Marked as False Positive:
setting SQLITE_TRANSIENT disables memory freeing

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/sqlite3.c:143889: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3.c:143889: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3.c:143898: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143896|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143897|         }else{
#143898|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143899|         }
#143900|       }else{
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.949333');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (20, 109, 'def12', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3_analyzer.c:201059: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:201059: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201067|       for(i=0; i<pIter->nPhrase; i++){
#201068|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201069|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201070|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201071|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3_analyzer.c: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1}".
#       for(i=0; i<pIter->nPhrase; i++){
#         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3_analyzer.c:201059: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:201059: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:201069: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201067|       for(i=0; i<pIter->nPhrase; i++){
#201068|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201069|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201070|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201071|       }
(Example-1) Reason Marked as False Positive:
iCol in this case can not be bigger that i16, as the condition in for loop look looks as follows:
for(iCol=0; iCol<pTab->nCol; iCol++){ and pTab->nCol is i16

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201045: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201045: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201043|       for(i=0; i<pIter->nPhrase; i++){
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
(Example-2) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

', '2025-11-17 21:39:06.949333');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (21, 109, 'def13', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116627: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116627: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116627: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-1) Reason Marked as False Positive:
memory is not freed when xDel is set to SQLITE_TRANSIENT, which it is.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949333');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (22, 109, 'def14', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3_analyzer.c:127646: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3_analyzer.c:127647: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127645|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127646|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127647|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127648|         }
#127649|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:127622: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3.c:127623: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127621|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127622|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127623|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127624|         }
#127625|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:127622: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3.c:127623: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127621|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127622|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127623|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127624|         }
#127625|       }
(Example-1) Reason Marked as False Positive:
iCol in this case can not be bigger that i16, as the condition in for loop look looks as follows:
for(iCol=0; iCol<pTab->nCol; iCol++){
and pTab->nCol is i16

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3_analyzer.c:31129: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3_analyzer.c:31129: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:31129: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3_analyzer.c:31723: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:31725: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31723|       width -= length;
#31724|       if( width>0 ){
#31725|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31726|         sqlite3_str_append(pAccum, bufpt, length);
#31727|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-2) Reason Marked as False Positive:
there is check if width is bigger than 0

', '2025-11-17 21:39:06.949334');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (24, 109, 'def16', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:78860: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78861: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78859|       assert( iOvflSpace <= (int)pBt->pageSize );
#78860|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78861|->     pSrcEnd = b.apEnd[k];
#78862|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78863|         rc = SQLITE_CORRUPT_BKPT;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#       assert( iOvflSpace <= (int)pBt->pageSize );
#       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#->     pSrcEnd = b.apEnd[k];
#       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#         rc = SQLITE_CORRUPT_BKPT;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78860: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78861: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78859|       assert( iOvflSpace <= (int)pBt->pageSize );
#78860|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78861|->     pSrcEnd = b.apEnd[k];
#78862|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78863|         rc = SQLITE_CORRUPT_BKPT;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78836: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:78837: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78835|       assert( iOvflSpace <= (int)pBt->pageSize );
#78836|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78837|->     pSrcEnd = b.apEnd[k];
#78838|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78839|         rc = SQLITE_CORRUPT_BKPT;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949334');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (25, 109, 'def17', 'VARARGS', 'sqlite-src-3450100/shell.c:15571: va_init: Initializing va_list "ap".
sqlite-src-3450100/shell.c:15579: missing_va_end: "va_end" was not called for "ap".
#15577|     p->zErrMsg = z;
#15578|     p->errCode = errCode;
#15579|->   return errCode;
#15580|   }
#15581|', 'TRUE POSITIVE', 'The code initializes ''va_list'' ''ap'' at line 15571 but lacks a corresponding ''va_end'' call, leading to a potential resource leak or undefined behavior, as it returns at line 15579 without cleanup.', 'The CVE report explicitly states a ''missing_va_end'' issue, indicating that ''va_end'' was not called for the initialized ''va_list'' ''ap'' (sqlite-src-3450100/shell.c:15579).

The provided code snippet shows the initialization of ''va_list'' ''ap'' at line 15571, but there is no visible call to ''va_end'' within the given code context.

The code execution path leads to a ''return'' statement at line 15579 without calling ''va_end'', directly correlating with the described vulnerability (missing ''va_end'' after ''va_init'').

The absence of ''va_end'' for the initialized ''va_list'' ''ap'' within the provided code context implies a potential resource leak or undefined behavior, aligning with the vulnerability described in the CVE.

No explicit ''va_end'' call is observed in the provided source code lines (#15577 to #15581), which encompasses the initialization and the return of the function, leaving no room for ''va_end'' to be called within this execution path.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.949335');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (26, 109, 'def18', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:11204: freed_arg: "sqlite3_result_text" frees "zRes".
sqlite-src-3450100/shell.c:11205: double_free: Calling "sqlite3_free" frees pointer "zRes" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#11203|       }else{
#11204|         sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
#11205|->       sqlite3_free(zRes);
#11206|       }
#11207|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:11204: freed_arg: "sqlite3_result_text" frees "zRes".
sqlite-src-3450100/shell.c:11205: double_free: Calling "sqlite3_free" frees pointer "zRes" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#11203|       }else{
#11204|         sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
#11205|->       sqlite3_free(zRes);
#11206|       }
#11207|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:11204: freed_arg: "sqlite3_result_text" frees "zRes".
sqlite-src-3450100/shell.c:11205: double_free: Calling "sqlite3_free" frees pointer "zRes" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#11203|       }else{
#11204|         sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
#11205|->       sqlite3_free(zRes);
#11206|       }
#11207|     }
(Example-1) Reason Marked as False Positive:
sqlite3_result_text does not free zRes, when SQLITE_TRANSIENT is set.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:16035: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/shell.c:16036: double_free: Calling "sqlite3_free" frees pointer "zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#16034|   
#16035|         sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
#16036|->       sqlite3_free(zOut);
#16037|         return;
#16038|       }
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

', '2025-11-17 21:39:06.949335');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (27, 109, 'def19', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:210526: cond_const: Checking "iIdx < 40" implies that "iIdx" is 41 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:210585: overrun-buffer-arg: Overrunning array "zIdxStr" of 41 bytes by passing it to a function which accesses it at byte offset 41 using argument "iIdx + 1" (which evaluates to 42). [Note: The source code implementation of the function has been overridden by a builtin model.]
#210583|         return SQLITE_NOMEM;
#210584|       }
#210585|->     memcpy(pIdxInfo->idxStr, zIdxStr, iIdx+1);
#210586|     }
#210587|', 'TRUE POSITIVE', 'iIdx is implied to be 41 when `iIdx < 40` is false, and using `iIdx+1` (42) as the length in `memcpy` at line 210585 would overrun the 41-byte `zIdxStr` array, with no intervening code modifications to prevent this.', 'The CVE report explicitly states that the condition `iIdx < 40` implies `iIdx` is 41 on the false branch (line 210526), setting the stage for a potential buffer overrun.

Immediately following this condition (though not directly shown in the snippet, implied by the line numbers), the code executes `memcpy(pIdxInfo->idxStr, zIdxStr, iIdx+1)` at line 210585.

Given `iIdx` is implied to be 41 when the condition `iIdx < 40` is false, using `iIdx+1` (which equals 42) as the length in `memcpy` would indeed overrun the `zIdxStr` array, which is stated to be of 41 bytes.

There is no explicit code provided within the snippet that increments, decrements, or otherwise modifies `iIdx` between the condition check and the `memcpy` operation to prevent the overrun, given the stated implication of `iIdx` being 41.

The implementation of `memcpy` is noted to be overridden by a builtin model, but the analysis focuses on the explicit arguments passed (`iIdx+1`), which, based on the provided condition, would lead to an overrun.

No definitive proof is provided within the snippet to suggest that all execution paths avoid the described vulnerability, aligning with the guideline that lack of clear false positive evidence implies a TRUE POSITIVE finding.', 'Provide the complete code snippet including the condition check `iIdx < 40` and any intervening code to assess potential modifications to `iIdx`.

Verify if there are any implicit or explicit bounds checks on `iIdx` before the `memcpy` operation that could prevent the overrun.

Confirm the size of `zIdxStr` is consistently 41 bytes across all execution paths leading to the `memcpy` call.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';
(Example-1) Reason Marked as False Positive:
There is while that decrements the i at elast once.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:186463: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c:186463: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3_analyzer.c:186468: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186471: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186469|       }
#186470|       assert( zBuffer );
#186471|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186472|       nBuffer = nPrefix + nSuffix;
#186473|       zCsr += nSuffix;
(Example-2) Reason Marked as False Positive:
length of zBuffer is always bigger that nPrefix.

', '2025-11-17 21:39:06.949336');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (28, 109, 'def20', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:67013: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:67046: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67044|       }
#67045|       WALTRACE(("WAL%p: closed\n", pWal));
#67046|->     sqlite3_free((void *)pWal->apWiData);
#67047|       sqlite3_free(pWal);
#67048|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:67013: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:67046: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67044|       }
#67045|       WALTRACE(("WAL%p: closed\n", pWal));
#67046|->     sqlite3_free((void *)pWal->apWiData);
#67047|       sqlite3_free(pWal);
#67048|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:67013: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:67046: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67044|       }
#67045|       WALTRACE(("WAL%p: closed
", pWal));
#67046|->     sqlite3_free((void *)pWal->apWiData);
#67047|       sqlite3_free(pWal);
#67048|     }
(Example-1) Reason Marked as False Positive:
Its calling realloc, not free.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed
", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }
(Example-2) Reason Marked as False Positive:
members of apWiData is set set to 0 after freeing. Second Freeing will be NOOP

', '2025-11-17 21:39:06.949336');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (29, 109, 'def21', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }
(Example-1) Reason Marked as False Positive:
There is a check, that check if pCsr->pExpr is not NULL.
Only when it is not NULL this is executed.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

', '2025-11-17 21:39:06.949336');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (30, 109, 'def22', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:191091: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:191127: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191125|     pCsr->iLangid = iLangVal;
#191126|   
#191127|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191128|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191129|     );', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm".
sqlite-src-3450100/sqlite3.c: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#     pCsr->iLangid = iLangVal;
#     
#->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#     );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:191091: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:191127: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191125|     pCsr->iLangid = iLangVal;
#191126|   
#191127|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191128|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191129|     );
(Example-1) Reason Marked as False Positive:
pCsr.filter is set to NULL and nTerm is set to zero to avoid invalid access.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

', '2025-11-17 21:39:06.949337');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (31, 109, 'def23', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:78836: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:78837: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78835|       assert( iOvflSpace <= (int)pBt->pageSize );
#78836|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78837|->     pSrcEnd = b.apEnd[k];
#78838|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78839|         rc = SQLITE_CORRUPT_BKPT;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:78836: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:78837: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78835|       assert( iOvflSpace <= (int)pBt->pageSize );
#78836|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78837|->     pSrcEnd = b.apEnd[k];
#78838|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78839|         rc = SQLITE_CORRUPT_BKPT;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78836: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:78837: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78835|       assert( iOvflSpace <= (int)pBt->pageSize );
#78836|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78837|->     pSrcEnd = b.apEnd[k];
#78838|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78839|         rc = SQLITE_CORRUPT_BKPT;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78860: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78861: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78859|       assert( iOvflSpace <= (int)pBt->pageSize );
#78860|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78861|->     pSrcEnd = b.apEnd[k];
#78862|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78863|         rc = SQLITE_CORRUPT_BKPT;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949337');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (32, 109, 'def24', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:82578: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3_analyzer.c:82582: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3_analyzer.c:82583: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82581|       }else{
#82582|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82583|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82584|         pMem->z = pMem->zMalloc;
#82585|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:82578: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3_analyzer.c:82582: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3_analyzer.c:82583: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82581|       }else{
#82582|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82583|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82584|         pMem->z = pMem->zMalloc;
#82585|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:82578: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3_analyzer.c:82582: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3_analyzer.c:82583: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82581|       }else{
#82582|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82583|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82584|         pMem->z = pMem->zMalloc;
#82585|       }
(Example-1) Reason Marked as False Positive:
pMem->z is freed only when something during realloc goes wrong, which is valid.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.949338');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (33, 109, 'def25', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:186302: overrun-local: Overrunning array of 8 bytes at byte offset 8 by dereferencing pointer "&&pCsr->base[1]". [Note: The source code implementation of the function has been overridden by a builtin model.]
#186300|     sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
#186301|     sqlite3Fts3ExprFree(pCsr->pExpr);
#186302|->   memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
#186303|   }
#186304|', 'TRUE POSITIVE', 'Insufficient evidence to rule out buffer overrun due to uncertain structure layout and missing definitions for `Fts3Cursor` and `sqlite3_vtab_cursor`, despite syntactically valid `memset` operation at line #186302.', 'The reported issue is an **overrun-local** error, specifically warning about overrunning an array of 8 bytes at byte offset 8.

The problematic line is `memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));` (#186302).

The `memset` function is attempting to set a memory block to zero, starting from the address of `&pCsr->base[1]`, with a size of `sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor)` bytes.

The warning suggests that this operation may overrun the bounds of an array, implying that the calculated size might exceed the allocated space for `pCsr->base` and its surrounding structure.

**Uncertainty regarding structure layout:** Without explicit information on the layout and sizes of `Fts3Cursor` and `sqlite3_vtab_cursor` within the provided source code context, it''s uncertain whether the subtraction of sizes accurately prevents buffer overflow.

**Provided source code does not define these structures:** The definitions of `Fts3Cursor` and `sqlite3_vtab_cursor` are not provided in the given source code snippets, making it impossible to definitively calculate the memory layout and verify the safety of the `memset` operation.

**Lack of definitive proof against the vulnerability:** Given the missing structural definitions and the potential for miscalculation in the `memset` size, there is insufficient evidence to conclusively rule out the possibility of a buffer overrun.

**Syntax and operation are valid but safety is unverified:** The syntax of the operation is correct, but without more information on the structure sizes, the safety of this operation cannot be guaranteed.', 'Obtain and examine the implementation details of the builtin model overriding the function at `sqlite-src-3450100/sqlite3_analyzer.c:186302` to assess its impact on the reported vulnerability.

Verify the definition and allocation of `pCsr->base` to determine its expected size and bounds, potentially within the `sqlite3Fts3MIBufferFree` or `sqlite3Fts3ExprFree` functions, or in the broader context of the `Fts3Cursor` structure.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/ext/fts3/fts3Int.h file:
521| # define sqlite3Fts3FreeDeferredDoclists(x)
522| # define sqlite3Fts3DeferredTokenList(x,y,z) SQLITE_OK
523| #endif
524| 
525| void sqlite3Fts3SegmentsClose(Fts3Table *);
526| int sqlite3Fts3MaxLevel(Fts3Table *, int *);
527| 
528| /* Special values interpreted by sqlite3SegReaderCursor() */
529| #define FTS3_SEGCURSOR_PENDING        -1
530| #define FTS3_SEGCURSOR_ALL            -2
531| 
532| int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3MultiSegReader*, Fts3SegFilter*);
533| int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3MultiSegReader *);
534| void sqlite3Fts3SegReaderFinish(Fts3MultiSegReader *);
535| 
536| int sqlite3Fts3SegReaderCursor(Fts3Table *, 
537|     int, int, int, const char *, int, int, int, Fts3MultiSegReader *);
538| 
539| /* Flags allowed as part of the 4th argument to SegmentReaderIterate() */
540| #define FTS3_SEGMENT_REQUIRE_POS   0x00000001
541| #define FTS3_SEGMENT_IGNORE_EMPTY  0x00000002
542| #define FTS3_SEGMENT_COLUMN_FILTER 0x00000004
543| #define FTS3_SEGMENT_PREFIX        0x00000008
544| #define FTS3_SEGMENT_SCAN          0x00000010
545| #define FTS3_SEGMENT_FIRST         0x00000020
546| 
547| /* Type passed as 4th argument to SegmentReaderIterate() */
548| struct Fts3SegFilter {
549|   const char *zTerm;
550|   int nTerm;
551|   int iCol;
552|   int flags;
553| };
554| 
555| struct Fts3MultiSegReader {
556|   /* Used internally by sqlite3Fts3SegReaderXXX() calls */
557|   Fts3SegReader **apSegment;      /* Array of Fts3SegReader objects */
558|   int nSegment;                   /* Size of apSegment array */
559|   int nAdvance;                   /* How many seg-readers to advance */
560|   Fts3SegFilter *pFilter;         /* Pointer to filter object */
561|   char *aBuffer;                  /* Buffer to merge doclists in */
562|   i64 nBuffer;                    /* Allocated size of aBuffer[] in bytes */
563| 
564|   int iColFilter;                 /* If >=0, filter for this column */
565|   int bRestart;
566| 
567|   /* Used by fts3.c only. */
568|   int nCost;                      /* Cost of running iterator */
569|   int bLookup;                    /* True if a lookup of a single entry. */
570| 
571|   /* Output values. Valid only after Fts3SegReaderStep() returns SQLITE_ROW. */
572|   char *zTerm;                    /* Pointer to term buffer */
573|   int nTerm;                      /* Size of zTerm in bytes */
574|   char *aDoclist;                 /* Pointer to doclist buffer */
575|   int nDoclist;                   /* Size of aDoclist[] in bytes */
576| };
577| 
578| int sqlite3Fts3Incrmerge(Fts3Table*,int,int);
579| 
580| #define fts3GetVarint32(p, piVal) (                                           \
581|   (*(u8*)(p)&0x80) ? sqlite3Fts3GetVarint32(p, piVal) : (*piVal=*(u8*)(p), 1) \
582| )
583| 
584| /* fts3.c */
585| void sqlite3Fts3ErrMsg(char**,const char*,...);
586| int sqlite3Fts3PutVarint(char *, sqlite3_int64);
587| int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);
588| int sqlite3Fts3GetVarintU(const char *, sqlite_uint64 *);
589| int sqlite3Fts3GetVarintBounded(const char*,const char*,sqlite3_int64*);
590| int sqlite3Fts3GetVarint32(const char *, int *);
591| int sqlite3Fts3VarintLen(sqlite3_uint64);
592| void sqlite3Fts3Dequote(char *);
593| void sqlite3Fts3DoclistPrev(int,char*,int,char**,sqlite3_int64*,int*,u8*);
594| int sqlite3Fts3EvalPhraseStats(Fts3Cursor *, Fts3Expr *, u32 *);
595| int sqlite3Fts3FirstFilter(sqlite3_int64, char *, int, char *);
596| void sqlite3Fts3CreateStatTable(int*, Fts3Table*);
597| int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc);
598| int sqlite3Fts3ReadInt(const char *z, int *pnOut);
599| 
600| /* fts3_tokenizer.c */
601| const char *sqlite3Fts3NextToken(const char *, int *);
602| int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);
603| int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *, 
604|     sqlite3_tokenizer **, char **
605| );
606| int sqlite3Fts3IsIdChar(char);
607| 
608| /* fts3_snippet.c */
609| void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*);
610| void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,
611|   const char *, const char *, int, int
612| );
613| void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *);
614| void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p);
615| 
616| /* fts3_expr.c */
617| int sqlite3Fts3ExprParse(sqlite3_tokenizer *, int,
618|   char **, int, int, int, const char *, int, Fts3Expr **, char **
619| );
620| void sqlite3Fts3ExprFree(Fts3Expr *);
621| #ifdef SQLITE_TEST
622| int sqlite3Fts3ExprInitTestInterface(sqlite3 *db, Fts3Hash*);
623| int sqlite3Fts3InitTerm(sqlite3 *db);
624| #endif
625| void *sqlite3Fts3MallocZero(i64 nByte);
626| 
627| int sqlite3Fts3OpenTokenizer(sqlite3_tokenizer *, int, const char *, int,
628|   sqlite3_tokenizer_cursor **
629| );
630| 
631| /* fts3_aux.c */
632| int sqlite3Fts3InitAux(sqlite3 *db);
633| 
634| void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *);
635| 
636| int sqlite3Fts3MsrIncrStart(
637|     Fts3Table*, Fts3MultiSegReader*, int, const char*, int);
638| int sqlite3Fts3MsrIncrNext(
639|     Fts3Table *, Fts3MultiSegReader *, sqlite3_int64 *, char **, int *);
640| int sqlite3Fts3EvalPhrasePoslist(Fts3Cursor *, Fts3Expr *, int iCol, char **); 
641| int sqlite3Fts3MsrOvfl(Fts3Cursor *, Fts3MultiSegReader *, int *);
642| int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr);
643| 
644| /* fts3_tokenize_vtab.c */
645| int sqlite3Fts3InitTok(sqlite3*, Fts3Hash *, void(*xDestroy)(void*));
646| 
647| /* fts3_unicode2.c (functions generated by parsing unicode text files) */
648| #ifndef SQLITE_DISABLE_FTS3_UNICODE
649| int sqlite3FtsUnicodeFold(int, int);
650| int sqlite3FtsUnicodeIsalnum(int);
651| int sqlite3FtsUnicodeIsdiacritic(int);
652| #endif
653| 
654| int sqlite3Fts3ExprIterate(Fts3Expr*, int (*x)(Fts3Expr*,int,void*), void*);
655| 
656| int sqlite3Fts3IntegrityCheck(Fts3Table *p, int *pbOk);
657| 
658| #endif /* !SQLITE_CORE || SQLITE_ENABLE_FTS3 */
659| #endif /* _FTSINT_H */


515| void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *);
516| int sqlite3Fts3DeferredTokenList(Fts3DeferredToken *, char **, int *);
517| #else
518| # define sqlite3Fts3FreeDeferredTokens(x)
519| # define sqlite3Fts3DeferToken(x,y,z) SQLITE_OK
520| # define sqlite3Fts3CacheDeferredDoclists(x) SQLITE_OK
521| # define sqlite3Fts3FreeDeferredDoclists(x)
522| # define sqlite3Fts3DeferredTokenList(x,y,z) SQLITE_OK
523| #endif
524| 
525| void sqlite3Fts3SegmentsClose(Fts3Table *);
526| int sqlite3Fts3MaxLevel(Fts3Table *, int *);
527| 
528| /* Special values interpreted by sqlite3SegReaderCursor() */
529| #define FTS3_SEGCURSOR_PENDING        -1
530| #define FTS3_SEGCURSOR_ALL            -2
531| 
532| int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3MultiSegReader*, Fts3SegFilter*);
533| int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3MultiSegReader *);
534| void sqlite3Fts3SegReaderFinish(Fts3MultiSegReader *);
535| 
536| int sqlite3Fts3SegReaderCursor(Fts3Table *, 
537|     int, int, int, const char *, int, int, int, Fts3MultiSegReader *);
538| 
539| /* Flags allowed as part of the 4th argument to SegmentReaderIterate() */
540| #define FTS3_SEGMENT_REQUIRE_POS   0x00000001
541| #define FTS3_SEGMENT_IGNORE_EMPTY  0x00000002
542| #define FTS3_SEGMENT_COLUMN_FILTER 0x00000004
543| #define FTS3_SEGMENT_PREFIX        0x00000008
544| #define FTS3_SEGMENT_SCAN          0x00000010
545| #define FTS3_SEGMENT_FIRST         0x00000020
546| 
547| /* Type passed as 4th argument to SegmentReaderIterate() */
548| struct Fts3SegFilter {
549|   const char *zTerm;
550|   int nTerm;
551|   int iCol;
552|   int flags;
553| };
554| 
555| struct Fts3MultiSegReader {
556|   /* Used internally by sqlite3Fts3SegReaderXXX() calls */
557|   Fts3SegReader **apSegment;      /* Array of Fts3SegReader objects */
558|   int nSegment;                   /* Size of apSegment array */
559|   int nAdvance;                   /* How many seg-readers to advance */
560|   Fts3SegFilter *pFilter;         /* Pointer to filter object */
561|   char *aBuffer;                  /* Buffer to merge doclists in */
562|   i64 nBuffer;                    /* Allocated size of aBuffer[] in bytes */
563| 
564|   int iColFilter;                 /* If >=0, filter for this column */
565|   int bRestart;
566| 
567|   /* Used by fts3.c only. */
568|   int nCost;                      /* Cost of running iterator */
569|   int bLookup;                    /* True if a lookup of a single entry. */
570| 
571|   /* Output values. Valid only after Fts3SegReaderStep() returns SQLITE_ROW. */
572|   char *zTerm;                    /* Pointer to term buffer */
573|   int nTerm;                      /* Size of zTerm in bytes */
574|   char *aDoclist;                 /* Pointer to doclist buffer */
575|   int nDoclist;                   /* Size of aDoclist[] in bytes */
576| };
577| 
578| int sqlite3Fts3Incrmerge(Fts3Table*,int,int);
579| 
580| #define fts3GetVarint32(p, piVal) (                                           \
581|   (*(u8*)(p)&0x80) ? sqlite3Fts3GetVarint32(p, piVal) : (*piVal=*(u8*)(p), 1) \
582| )
583| 
584| /* fts3.c */
585| void sqlite3Fts3ErrMsg(char**,const char*,...);
586| int sqlite3Fts3PutVarint(char *, sqlite3_int64);
587| int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);
588| int sqlite3Fts3GetVarintU(const char *, sqlite_uint64 *);
589| int sqlite3Fts3GetVarintBounded(const char*,const char*,sqlite3_int64*);
590| int sqlite3Fts3GetVarint32(const char *, int *);
591| int sqlite3Fts3VarintLen(sqlite3_uint64);
592| void sqlite3Fts3Dequote(char *);
593| void sqlite3Fts3DoclistPrev(int,char*,int,char**,sqlite3_int64*,int*,u8*);
594| int sqlite3Fts3EvalPhraseStats(Fts3Cursor *, Fts3Expr *, u32 *);
595| int sqlite3Fts3FirstFilter(sqlite3_int64, char *, int, char *);
596| void sqlite3Fts3CreateStatTable(int*, Fts3Table*);
597| int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc);
598| int sqlite3Fts3ReadInt(const char *z, int *pnOut);
599| 
600| /* fts3_tokenizer.c */
601| const char *sqlite3Fts3NextToken(const char *, int *);
602| int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);
603| int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *, 
604|     sqlite3_tokenizer **, char **
605| );
606| int sqlite3Fts3IsIdChar(char);
607| 
608| /* fts3_snippet.c */
609| void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*);
610| void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,
611|   const char *, const char *, int, int
612| );
613| void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *);
614| void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p);
615| 
616| /* fts3_expr.c */
617| int sqlite3Fts3ExprParse(sqlite3_tokenizer *, int,
618|   char **, int, int, int, const char *, int, Fts3Expr **, char **
619| );
620| void sqlite3Fts3ExprFree(Fts3Expr *);
621| #ifdef SQLITE_TEST
622| int sqlite3Fts3ExprInitTestInterface(sqlite3 *db, Fts3Hash*);
623| int sqlite3Fts3InitTerm(sqlite3 *db);
624| #endif
625| void *sqlite3Fts3MallocZero(i64 nByte);
626| 
627| int sqlite3Fts3OpenTokenizer(sqlite3_tokenizer *, int, const char *, int,
628|   sqlite3_tokenizer_cursor **
629| );
630| 
631| /* fts3_aux.c */
632| int sqlite3Fts3InitAux(sqlite3 *db);
633| 
634| void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *);
635| 
636| int sqlite3Fts3MsrIncrStart(
637|     Fts3Table*, Fts3MultiSegReader*, int, const char*, int);
638| int sqlite3Fts3MsrIncrNext(
639|     Fts3Table *, Fts3MultiSegReader *, sqlite3_int64 *, char **, int *);
640| int sqlite3Fts3EvalPhrasePoslist(Fts3Cursor *, Fts3Expr *, int iCol, char **); 
641| int sqlite3Fts3MsrOvfl(Fts3Cursor *, Fts3MultiSegReader *, int *);
642| int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr);
643| 
644| /* fts3_tokenize_vtab.c */
645| int sqlite3Fts3InitTok(sqlite3*, Fts3Hash *, void(*xDestroy)(void*));
646| 
647| /* fts3_unicode2.c (functions generated by parsing unicode text files) */
648| #ifndef SQLITE_DISABLE_FTS3_UNICODE
649| int sqlite3FtsUnicodeFold(int, int);
650| int sqlite3FtsUnicodeIsalnum(int);
651| int sqlite3FtsUnicodeIsdiacritic(int);
652| #endif
653| 
654| int sqlite3Fts3ExprIterate(Fts3Expr*, int (*x)(Fts3Expr*,int,void*), void*);
655| 
656| int sqlite3Fts3IntegrityCheck(Fts3Table *p, int *pbOk);
657| 
658| #endif /* !SQLITE_CORE || SQLITE_ENABLE_FTS3 */
659| #endif /* _FTSINT_H */

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:78860: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:78861: overrun-local: Overrunning array "b.apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#78859|       assert( iOvflSpace <= (int)pBt->pageSize );
#78860|       for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}
#78861|->     pSrcEnd = b.apEnd[k];
#78862|       if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){
#78863|         rc = SQLITE_CORRUPT_BKPT;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("
");
#27459|       switch( p->statsOn ){
(Example-2) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

', '2025-11-17 21:39:06.949338');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (34, 109, 'def26', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:16035: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/shell.c:16036: double_free: Calling "sqlite3_free" frees pointer "zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#16034|   
#16035|         sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
#16036|->       sqlite3_free(zOut);
#16037|         return;
#16038|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:16035: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/shell.c:16036: double_free: Calling "sqlite3_free" frees pointer "zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#16034|   
#16035|         sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
#16036|->       sqlite3_free(zOut);
#16037|         return;
#16038|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:16035: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/shell.c:16036: double_free: Calling "sqlite3_free" frees pointer "zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#16034|   
#16035|         sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
#16036|->       sqlite3_free(zOut);
#16037|         return;
#16038|       }
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK ){
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949338');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (35, 109, 'def27', 'BAD_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:250581: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250579|     assert( nArg==0 );
#250580|     UNUSED_PARAM2(nArg, apUnused);
#250581|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250582|   }
#250583|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:250581: array_free: "sqlite3_result_text" frees array "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a".
#250579|     assert( nArg==0 );
#250580|     UNUSED_PARAM2(nArg, apUnused);
#250581|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250582|   }
#250583|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3_analyzer.c:250581: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250579|     assert( nArg==0 );
#250580|     UNUSED_PARAM2(nArg, apUnused);
#250581|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250582|   }
#250583|
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3.c:250557: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250555|     assert( nArg==0 );
#250556|     UNUSED_PARAM2(nArg, apUnused);
#250557|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250558|   }
#250559|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

', '2025-11-17 21:39:06.949339');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (36, 109, 'def28', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77693: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77691|       if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|->       pSrcEnd = pCArray->apEnd[k];
#77694|       }
#77695|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77693: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77691|       if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|->       pSrcEnd = pCArray->apEnd[k];
#77694|       }
#77695|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77693: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77691|       if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|->       pSrcEnd = pCArray->apEnd[k];
#77694|       }
#77695|     }
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug: https://sqlite.org/forum/forumpost/d0e144c233c7b286 Upstream also added some asserts to future releases so that static analysers are not confused. In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77781: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77779|       if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|->       pEnd = pCArray->apEnd[k];
#77782|       }
#77783|     }
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949339');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (49, 109, 'def41', 'NEGATIVE_RETURNS', 'sqlite-src-3450100/shell.c:13351: negative_return_fn: Function "sqlite3_value_int(argv[0])" returns a negative number.
sqlite-src-3450100/shell.c:13351: assign: Assigning: "iSlot" = "sqlite3_value_int(argv[0])".
sqlite-src-3450100/shell.c:13353: negative_returns: Using variable "iSlot" as an index to array "p->aSlot".
#13351|     iSlot = sqlite3_value_int(argv[0]);
#13352|     assert( iSlot<=p->nSlot );
#13353|->   pSlot = &p->aSlot[iSlot];
#13354|   
#13355|     switch( pSlot->eType ){', 'TRUE POSITIVE', 'Assignment of a potentially negative value to `iSlot` (line #13351) and its subsequent use as an index for `p->aSlot` (line #13353) poses a risk of out-of-bounds access, as assertions (line #13352) may be disabled or non-terminating, directly linking to the CVE''s described vulnerability.', 'The CVE report explicitly states that `sqlite3_value_int(argv[0])` returns a negative number, which is assigned to `iSlot` (line #13351).

Despite the assertion `assert( iSlot<=p->nSlot )` on line #13352, there is no guarantee this assertion prevents all potential issues since assertions can be disabled at compile-time (e.g., with `-DNDEBUG` for many compilers), and this does not inherently prevent the execution with a negative `iSlot`.

The variable `iSlot` is used as an index to array `p->aSlot` on line #13353. Using a negative index in this context can lead to out-of-bounds access, potentially causing undefined behavior or a vulnerability, aligning with the concern raised by the CVE.

The presence of an assertion does not definitively prevent the vulnerability, as its effectiveness depends on the build configuration and runtime environment. Thus, a direct and demonstrable link exists between the code''s behavior and the described vulnerability.

Given the explicit behavior of the provided source code, at least one execution path (when assertions are disabled or the assertion fails without terminating the program) potentially leads to the vulnerability described in the CVE.', 'Review the initialization and bounds declaration of `p->aSlot` to assess the actual risk of out-of-bounds access.

Investigate the `sqlite3_value_int` function to understand its behavior when returning negative numbers, including any error handling or documentation that might mitigate the reported vulnerability.

Analyze the project''s build configurations to determine if assertions are typically disabled in production environments, affecting the vulnerability''s likelihood.', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.949344');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (37, 109, 'def29', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78557: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78555|           }
#78556|         }
#78557|->       szNew[i+1] -= sz;
#78558|       }
#78559|       if( cntNew[i]>=b.nCell ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78557: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78555|           }
#78556|         }
#78557|->       szNew[i+1] -= sz;
#78558|       }
#78559|       if( cntNew[i]>=b.nCell );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78557: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78555|           }
#78556|         }
#78557|->       szNew[i+1] -= sz;
#78558|       }
#78559|       if( cntNew[i]>=b.nCell ){
(Example-1) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78542: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78540|           }
#78541|         }
#78542|->       szNew[i+1] += sz;
#78543|         cntNew[i]--;
#78544|       }
(Example-2) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

', '2025-11-17 21:39:06.94934');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (38, 109, 'def30', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:35643: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3.c:35653: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35651|     if( iRound<0 ){
#35652|       iRound = p->iDP - iRound;
#35653|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35654|         iRound = 1;
#35655|         p->zBuf[i--] = ''0'';', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';
(Example-1) Reason Marked as False Positive:
There is while that decrements the i at elast once.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77726: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77724|     if( iEnd<=iFirst ) return 0;
#77725|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77726|->   pEnd = pCArray->apEnd[k];
#77727|     while( 1 /*Exit by break*/ ){
#77728|       int sz, rc;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.94934');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (39, 109, 'def31', 'BAD_FREE', 'sqlite-src-3450100/sqlite3.c:250557: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250555|     assert( nArg==0 );
#250556|     UNUSED_PARAM2(nArg, apUnused);
#250557|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250558|   }
#250559|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:250557: array_free: "sqlite3_result_text" frees array "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a".
#250555|     assert( nArg==0 );
#250556|     UNUSED_PARAM2(nArg, apUnused);
#250557|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250558|   }
#250559|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3.c:250557: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250555|     assert( nArg==0 );
#250556|     UNUSED_PARAM2(nArg, apUnused);
#250557|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250558|   }
#250559|
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3_analyzer.c:250581: array_free: "sqlite3_result_text" frees array ""fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a"".
#250579|     assert( nArg==0 );
#250580|     UNUSED_PARAM2(nArg, apUnused);
#250581|->   sqlite3_result_text(pCtx, "fts5: 2024-01-30 16:01:20 e876e51a0ed5c5b3126f52e532044363a014bc594cfefa87ffb5b82257cc467a", -1, SQLITE_TRANSIENT);
#250582|   }
#250583|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

', '2025-11-17 21:39:06.94934');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (40, 109, 'def32', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:186439: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:186439: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3.c:186444: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186447: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186445|       }
#186446|       assert( zBuffer );
#186447|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186448|       nBuffer = nPrefix + nSuffix;
#186449|       zCsr += nSuffix;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3.c: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#       }
#       assert( zBuffer );
#->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#       nBuffer = nPrefix + nSuffix;
#       zCsr += nSuffix;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:186439: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:186439: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3.c:186444: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186447: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186445|       }
#186446|       assert( zBuffer );
#186447|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186448|       nBuffer = nPrefix + nSuffix;
#186449|       zCsr += nSuffix;
(Example-1) Reason Marked as False Positive:
nBuffer is realloc -ed when nPrefix is bigger.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:186463: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c:186463: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3_analyzer.c:186468: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186471: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186469|       }
#186470|       assert( zBuffer );
#186471|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186472|       nBuffer = nPrefix + nSuffix;
#186473|       zCsr += nSuffix;
(Example-2) Reason Marked as False Positive:
length of zBuffer is always bigger that nPrefix.

', '2025-11-17 21:39:06.949341');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (41, 109, 'def33', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77642: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77643: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77641|   
#77642|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77643|->   pSrcEnd = pCArray->apEnd[k];
#77644|   
#77645|     pData = pEnd;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77642: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77643: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77641|   
#77642|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77643|->   pSrcEnd = pCArray->apEnd[k];
#77644|   
#77645|     pData = pEnd;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77642: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77643: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77641|   
#77642|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77643|->   pSrcEnd = pCArray->apEnd[k];
#77644|   
#77645|     pData = pEnd;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77667: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77665|   
#77666|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77667|->   pSrcEnd = pCArray->apEnd[k];
#77668|   
#77669|     pData = pEnd;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949341');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (42, 109, 'def34', 'COPY_PASTE_ERROR', 'sqlite-src-3450100/sqlite3_analyzer.c:170152: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3_analyzer.c:170164: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3_analyzer.c:170164: remediation: Should it say "regEndRowid" instead?
#170162|         csr = p->end.csr;
#170163|         reg = p->end.reg;
#170164|->       if( pMWin->regStartRowid ){
#170165|           assert( pMWin->regEndRowid );
#170166|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3_analyzer.c: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3_analyzer.c: remediation: Should it say "regEndRowid" instead?
#         csr = p->end.csr;
#         reg = p->end.reg;
#->       if( pMWin->regStartRowid ){
#           assert( pMWin->regEndRowid );
#           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
sqlite-src-3450100/sqlite3_analyzer.c:170152: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3_analyzer.c:170164: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3_analyzer.c:170164: remediation: Should it say "regEndRowid" instead?
#170162|         csr = p->end.csr;
#170163|         reg = p->end.reg;
#170164|->       if( pMWin->regStartRowid ){
#170165|           assert( pMWin->regEndRowid );
#170166|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
(Example-1) Reason Marked as False Positive:
there is also assert for checking in regEndRowid is not NULL. That is sufficient.

** Example-2 **
(Example-2) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
sqlite-src-3450100/sqlite3.c:170128: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3.c:170140: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3.c:170140: remediation: Should it say "regEndRowid" instead?
#170138|         csr = p->end.csr;
#170139|         reg = p->end.reg;
#170140|->       if( pMWin->regStartRowid ){
#170141|           assert( pMWin->regEndRowid );
#170142|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
(Example-2) Reason Marked as False Positive:
there is also assert for checking in regEndRowid is not NULL. That is sufficient.

', '2025-11-17 21:39:06.949342');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (43, 109, 'def35', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77691: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77689|       i++;
#77690|       if( i>=iEnd ) break;
#77691|->     if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|         pSrcEnd = pCArray->apEnd[k];', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77691: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77689|       i++;
#77690|       if( i>=iEnd ) break;
#77691|->     if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|         pSrcEnd = pCArray->apEnd[k];', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77691: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77689|       i++;
#77690|       if( i>=iEnd ) break;
#77691|->     if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|         pSrcEnd = pCArray->apEnd[k];
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77779: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77777|       i++;
#77778|       if( i>=iEnd ) break;
#77779|->     if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|         pEnd = pCArray->apEnd[k];
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug: https://sqlite.org/forum/forumpost/d0e144c233c7b286 Upstream also added some asserts to future releases so that static analysers are not confused. In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949342');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (44, 109, 'def36', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77725: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77726: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77724|     if( iEnd<=iFirst ) return 0;
#77725|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77726|->   pEnd = pCArray->apEnd[k];
#77727|     while( 1 /*Exit by break*/ ){
#77728|       int sz, rc;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77725: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77726: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77724|     if( iEnd<=iFirst ) return 0;
#77725|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77726|->   pEnd = pCArray->apEnd[k];
#77727|     while( 1 /*Exit by break*/ ){
#77728|       int sz, rc;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77726: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77724|     if( iEnd<=iFirst ) return 0;
#77725|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77726|->   pEnd = pCArray->apEnd[k];
#77727|     while( 1 /*Exit by break*/ ){
#77728|       int sz, rc;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77750: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77748|     if( iEnd<=iFirst ) return 0;
#77749|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77750|->   pEnd = pCArray->apEnd[k];
#77751|     while( 1 /*Exit by break*/ ){
#77752|       int sz, rc;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949342');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (45, 109, 'def37', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3_analyzer.c:95910: assign: Assigning: "pIn1" = "&aMem[pOp->p1]".
sqlite-src-3450100/sqlite3_analyzer.c:95928: equal: The address of "pIn1->u.r" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3_analyzer.c:95928: equal: The address of "pIn1->u.i" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3_analyzer.c:95928: overlapping_assignment: Assigning "pIn1->u.i" to "pIn1->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3_analyzer.c:95928: target_type: "pIn1->u.r" has type "double".
sqlite-src-3450100/sqlite3_analyzer.c:95928: source_type: "pIn1->u.i" has type "long long".
#95926|           pIn1->flags &= ~MEM_Int;
#95927|         }else{
#95928|->         pIn1->u.r = (double)pIn1->u.i;
#95929|           pIn1->flags |= MEM_Real;
#95930|           pIn1->flags &= ~(MEM_Int|MEM_Str);', 'TRUE POSITIVE', 'Overlapping assignment with type mismatch occurs at line #95928, where a `long long` (`pIn1->u.i`) is cast to a `double` (`pIn1->u.r`) in overlapping memory locations, potentially leading to type confusion or unexpected behavior.', 'Direct evidence of overlapping assignment with different types at line **#95928**: `pIn1->u.r = (double)pIn1->u.i;`, where `pIn1->u.r` is of type `double` and `pIn1->u.i` is of type `long long`, and they share overlapping memory locations as indicated by the equality of their addresses (**sqlite-src-3450100/sqlite3_analyzer.c:95928**).

The assignment at **#95928** explicitly casts a `long long` value to a `double`, which, given the overlapping memory locations, could lead to type confusion or unexpected behavior, aligning with the described vulnerability of overlapping assignment with different types.

The code''s explicit behavior, as written, does not prevent or mitigate this overlapping assignment with type mismatch in the identified execution path, satisfying the condition for a TRUE POSITIVE finding.

No definitive proof within the provided code snippet indicates that this vulnerability cannot occur under any circumstances, further supporting the TRUE POSITIVE conclusion.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.949343');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (46, 109, 'def38', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:237109: freed_arg: "fts5ExprAddChildren" frees "pRight".
sqlite-src-3450100/sqlite3.c:237126: double_free: Calling "sqlite3Fts5ParseNodeFree" frees pointer "pRight" which has already been freed.
#237124|       assert( pParse->rc!=SQLITE_OK );
#237125|       sqlite3Fts5ParseNodeFree(pLeft);
#237126|->     sqlite3Fts5ParseNodeFree(pRight);
#237127|       sqlite3Fts5ParseNearsetFree(pNear);
#237128|     }', 'TRUE POSITIVE', 'Consecutive calls to `sqlite3Fts5ParseNodeFree` for `pRight` (lines 237109 and 237126) with no intervening nullification or protective checks, confirming a direct execution path to a double-free vulnerability (CWE-416).', 'Direct evidence of double-free vulnerability: the CVE report explicitly states that `fts5ExprAddChildren` frees `pRight` (line 237109) and subsequently `sqlite3Fts5ParseNodeFree` attempts to free `pRight` again (line 237126).

Code confirmation: the provided source code snippet shows consecutive calls to `sqlite3Fts5ParseNodeFree` for both `pLeft` (line 237125) and `pRight` (line 237126), with no intervening checks or operations on `pRight` that would prevent the double-free.

Lack of explicit nullification or protection: there is no visible nullification of `pRight` after its initial free (which would prevent the double-free) within the provided code snippet, nor any conditional statement that would skip the second free if `pRight` had already been freed.

No uncertainty in execution path: given the sequential nature of the code and the absence of any conditional statements that could bypass the second free, there is a clear, direct execution path leading to the double-free vulnerability.

Correlation with CWE-416 (Use After Free, which includes Double-Free): the described behavior aligns with CWE-416, as it involves the freeing of a resource (`pRight`) followed by an attempt to free that same resource again.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-1) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:248872: freed_arg: "fts5FreeCursorComponents" frees "pCsr->pExpr".
sqlite-src-3450100/sqlite3.c:249001: deref_arg: Calling "fts5CursorFirst" dereferences freed pointer "pCsr->pExpr".
#248999|         }else{
#249000|           pCsr->ePlan = FTS5_PLAN_MATCH;
#249001|->         rc = fts5CursorFirst(pTab, pCsr, bDesc);
#249002|         }
#249003|       }
(Example-2) Reason Marked as False Positive:
There is a check, that check if pCsr->pExpr is not NULL.
Only when it is not NULL this is executed.

', '2025-11-17 21:39:06.949343');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (47, 109, 'def39', 'BAD_FREE', 'sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:7636: array_free: "sqlite3_result_text" frees array "z".
# 7634|     }
# 7635|     z[10] = ''\0'';
# 7636|->   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
# 7637|   }
# 7638|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

', '2025-11-17 21:39:06.949344');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (48, 109, 'def40', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:186278: overrun-local: Overrunning array of 8 bytes at byte offset 8 by dereferencing pointer "&&pCsr->base[1]". [Note: The source code implementation of the function has been overridden by a builtin model.]
#186276|     sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
#186277|     sqlite3Fts3ExprFree(pCsr->pExpr);
#186278|->   :qCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
#186279|   }
#186280|', 'TRUE POSITIVE', 'Explicit dereference of `&&pCsr->base[1]` at byte offset 8 exceeds the 8-byte array size, with no visible bounds checking in the provided code snippet (#186276-#186280), identifying a single vulnerable execution path.', '1. **Explicit Dereference of Out-of-Bounds Pointer**: The CVE report specifically highlights the dereference of `&&pCsr->base[1]` at byte offset 8, which is beyond the reported 8-byte array size. This directly correlates with the definition of an overrun (CWE-119), as it accesses memory beyond the allocated space.

2. **Lack of Explicit Bounds Checking in Provided Code**: There is no visible check within the provided code snippet (#186276 to #186280) that ensures `pCsr->base[1]` is within the valid bounds of the `base` array before its dereference. The absence of explicit bounds checking in the given context increases the likelihood of a vulnerability.

3. **Unclear Impact of ''builtin model'' Override**: The note about the source code implementation being overridden by a builtin model does not provide sufficient assurance that the vulnerability is mitigated. Without explicit details on how this override prevents the overrun, it cannot be relied upon as a justification for a FALSE POSITIVE.

4. **Insufficient Context to Assume Safety**: Given the strict guidelines to not infer behavior based on function names or implied functionality, there''s insufficient context to assume that `sqlite3Fts3MIBufferFree` or `sqlite3Fts3ExprFree` (lines #186276 and #186277) have any direct impact on the memory safety of `pCsr->base[1]`.

5. **Single Vulnerable Path Identified**: The direct dereference of `&&pCsr->base[1]` at an offset that exceeds the array''s size constitutes a single, identifiable execution path that potentially triggers the described overrun vulnerability, satisfying the criteria for a TRUE POSITIVE finding.', 'Obtain detailed documentation or explanation for the ''builtin model'' override''s implementation and its memory safety guarantees.

Analyze the complete implementation of `Fts3Cursor` and `sqlite3_vtab_cursor` to understand the memory layout and potential bounds.

Investigate if there are implicit bounds checks or memory safety mechanisms in the surrounding code not immediately apparent in the provided snippet.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
(Example-1) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("
");
#27459|       switch( p->statsOn ){
(Example-2) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

', '2025-11-17 21:39:06.949344');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (407, 102, 'def10', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_prog.c:552: tainted_data_return: Called function "read(fd, inptr, maxlen - actlen)", and a possible return value may be less than zero.
glibc-2.39/iconv/iconv_prog.c:552: assign: Assigning: "n" = "read(fd, inptr, maxlen - actlen)".
glibc-2.39/iconv/iconv_prog.c:566: overflow: The expression "actlen += n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/iconv/iconv_prog.c:612: overflow_sink: "actlen", which might be negative, is passed to "process_block(cd, inbuf, actlen, output, output_file)".
#  610|   
#  611|     /* Now we have all the input in the buffer.  Process it in one run.  */
#  612|->   return process_block (cd, inbuf, actlen, output, output_file);
#  613|   }
#  614|', 'TRUE POSITIVE', 'Potential negative return value from `read()` at iconv_prog.c:552 can propagate through assignments (`n` at 552, `actlen` at 566) and be passed to `process_block()` at 612 without explicit prevention or handling for negative values, leveraging unsigned context expectations.', '1. **Negative Return Value from `read()`**: The `read()` function at `iconv_prog.c:552` can indeed return a value less than zero, indicating an error (as per POSIX standards). This is correctly identified as a potential issue.

2. **Assignment of Potentially Negative Value to `n`**: The return value of `read()` is assigned to `n` without modification (`iconv_prog.c:552`). If `read()` returns an error (negative value), `n` will hold this negative value.

3. **Potential Negative Value in `actlen += n`**: At `iconv_prog.c:566`, if `n` is negative (from a `read()` error), adding it to `actlen` could result in a negative value for `actlen`. The analysis correctly notes this expression might be negative but is used in a context expecting an unsigned value.

4. **Passing Potentially Negative `actlen` to `process_block()`**: Despite the loop conditions and error handling around `read()` and buffer management, there''s no explicit check to prevent a negative `actlen` from being passed to `process_block()` at `iconv_prog.c:612` if an error occurs in a specific manner that bypasses the `break` or `return -1` statements.

5. **Lack of Explicit Unsigned Guarantee for `actlen` in `process_block()` Call**: The provided code for `process_block()` (`iconv_prog.c:448-534`) does not explicitly handle the case where `len` (which would be `actlen` in this context) is negative. While `size_t` is unsigned, the passing of a potentially negative value through a signed intermediate (`actlen`) to an unsigned parameter could lead to unexpected behavior, depending on the system''s integer promotion rules.

6. **No Clear False Positive Evidence**: There is no definitive proof within the provided code that the described vulnerability cannot occur under any circumstances. The error handling and loop conditions do not explicitly prevent a negative value from being used in a manner that could lead to the described vulnerability.', 'Examine the implementation of `process_block()` to determine how it handles potentially negative `actlen` values.

Verify if there are any implicit checks or handling mechanisms within `process_block()` that could mitigate the reported vulnerability.', 0.0000, '*** Source Code Context ***

code of iconv/iconv_prog.c file:
537| static int
538| process_fd (iconv_t cd, int fd, FILE **output, const char *output_file)
539| {
540|   /* we have a problem with reading from a descriptor since we must not
541|      provide the iconv() function an incomplete character or shift
542|      sequence at the end of the buffer.  Since we have to deal with
543|      arbitrary encodings we must read the whole text in a buffer and
544|      process it in one step.  */
545|   static char *inbuf = NULL;
546|   static size_t maxlen = 0;
547|   char *inptr = NULL;
548|   size_t actlen = 0;
549| 
550|   while (actlen < maxlen)
551|     {
552|       ssize_t n = read (fd, inptr, maxlen - actlen);
553| 
554|       if (n == 0)
555| 	/* No more text to read.  */
556| 	break;
557| 
558|       if (n == -1)
559| 	{
560| 	  /* Error while reading.  */
561| 	  error (0, errno, _("error while reading the input"));
562| 	  return -1;
563| 	}
564| 
565|       inptr += n;
566|       actlen += n;
567|     }
568| 
569|   if (actlen == maxlen)
570|     while (1)
571|       {
572| 	ssize_t n;
573| 	char *new_inbuf;
574| 
575| 	/* Increase the buffer.  */
576| 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
577| 	if (new_inbuf == NULL)
578| 	  {
579| 	    error (0, errno, _("unable to allocate buffer for input"));
580| 	    return -1;
581| 	  }
582| 	inbuf = new_inbuf;
583| 	maxlen += 32768;
584| 	inptr = inbuf + actlen;
585| 
586| 	do
587| 	  {
588| 	    n = read (fd, inptr, maxlen - actlen);
589| 
590| 	    if (n == 0)
591| 	      /* No more text to read.  */
592| 	      break;
593| 
594| 	    if (n == -1)
595| 	      {
596| 		/* Error while reading.  */
597| 		error (0, errno, _("error while reading the input"));
598| 		return -1;
599| 	      }
600| 
601| 	    inptr += n;
602| 	    actlen += n;
603| 	  }
604| 	while (actlen < maxlen);
605| 
606| 	if (n == 0)
607| 	  /* Break again so we leave both loops.  */
608| 	  break;
609|       }
610| 
611|   /* Now we have all the input in the buffer.  Process it in one run.  */
612|   return process_block (cd, inbuf, actlen, output, output_file);
613| }

code of /shared-data/source/glibc-2.39/iconv/iconv_prog.c file:
448| static int
449| process_block (iconv_t cd, char *addr, size_t len, FILE **output,
450| 	       const char *output_file)
451| {
452| #define OUTBUF_SIZE	32768
453|   const char *start = addr;
454|   char outbuf[OUTBUF_SIZE];
455|   char *outptr;
456|   size_t outlen;
457|   size_t n;
458|   int ret = 0;
459| 
460|   while (len > 0)
461|     {
462|       outptr = outbuf;
463|       outlen = OUTBUF_SIZE;
464|       n = iconv (cd, &addr, &len, &outptr, &outlen);
465| 
466|       if (n == (size_t) -1 && omit_invalid && errno == EILSEQ)
467| 	{
468| 	  ret = 1;
469| 	  if (len == 0)
470| 	    n = 0;
471| 	  else
472| 	    errno = E2BIG;
473| 	}
474| 
475|       if (outptr != outbuf)
476| 	{
477| 	  ret = write_output (outbuf, outptr, output, output_file);
478| 	  if (ret != 0)
479| 	    break;
480| 	}
481| 
482|       if (n != (size_t) -1)
483| 	{
484| 	  /* All the input test is processed.  For state-dependent
485| 	     character sets we have to flush the state now.  */
486| 	  outptr = outbuf;
487| 	  outlen = OUTBUF_SIZE;
488| 	  n = iconv (cd, NULL, NULL, &outptr, &outlen);
489| 
490| 	  if (outptr != outbuf)
491| 	    {
492| 	      ret = write_output (outbuf, outptr, output, output_file);
493| 	      if (ret != 0)
494| 		break;
495| 	    }
496| 
497| 	  if (n != (size_t) -1)
498| 	    break;
499| 
500| 	  if (omit_invalid && errno == EILSEQ)
501| 	    {
502| 	      ret = 1;
503| 	      break;
504| 	    }
505| 	}
506| 
507|       if (errno != E2BIG)
508| 	{
509| 	  /* iconv() ran into a problem.  */
510| 	  switch (errno)
511| 	    {
512| 	    case EILSEQ:
513| 	      if (! omit_invalid)
514| 		error (0, 0, _("illegal input sequence at position %ld"),
515| 		       (long int) (addr - start));
516| 	      break;
517| 	    case EINVAL:
518| 	      error (0, 0, _("\
519| incomplete character or shift sequence at end of buffer"));
520| 	      break;
521| 	    case EBADF:
522| 	      error (0, 0, _("internal error (illegal descriptor)"));
523| 	      break;
524| 	    default:
525| 	      error (0, 0, _("unknown iconv() error %d"), errno);
526| 	      break;
527| 	    }
528| 
529| 	  return -1;
530| 	}
531|     }
532| 
533|   return ret;
534| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-1) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-2) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

', '2025-11-17 21:39:07.118805');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (50, 109, 'def42', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78542: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78540|           }
#78541|         }
#78542|->       szNew[i+1] += sz;
#78543|         cntNew[i]--;
#78544|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78542: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78540|           }
#78541|         }
#78542|->       szNew[i+1] += sz;
#78543|         cntNew[i]--;
#78544|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78542: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78540|           }
#78541|         }
#78542|->       szNew[i+1] += sz;
#78543|         cntNew[i]--;
#78544|       }
(Example-1) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:78529: cond_at_most: Checking "k > 5" implies that "k" may be up to 5 on the false branch.
sqlite-src-3450100/sqlite3.c:78524: cond_between: Checking "i < k" implies that "i" is between 2 and 4 (inclusive) on the true branch.
sqlite-src-3450100/sqlite3.c:78557: overrun-local: Overrunning array "szNew" of 5 4-byte elements at element index 5 (byte offset 23) using index "i + 1" (which evaluates to 5).
#78555|           }
#78556|         }
#78557|->       szNew[i+1] -= sz;
#78558|       }
#78559|       if( cntNew[i]>=b.nCell ){
(Example-2) Reason Marked as False Positive:
The is this check:
8388       if( i+1>=k ){
8389         k = i+2;
8390         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
8391         szNew[k-1] = 0;
8392         cntNew[k-1] = b.nCell;
8393       }
that send program to balance cleanup if k>5. And if k==5 on line 8390, then based od 8389 i=3.
That means accessing szNew[i+1] is valid.

', '2025-11-17 21:39:06.949345');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (51, 109, 'def43', 'BAD_FREE', 'sqlite-src-3450100/tool/sqldiff.c:1826: array_free: "sqlite3_result_text" frees array "zToken".
# 1824|     zSql = gobble_token(zSql, zToken, sizeof(zToken));
# 1825|     
# 1826|->   sqlite3_result_text(pCtx, zToken, -1, SQLITE_TRANSIENT);
# 1827|   }
# 1828|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/tool/sqldiff.c:1826: array_free: "sqlite3_result_text" frees array "zToken".
# 1824|     zSql = gobble_token(zSql, zToken, sizeof(zToken));
# 1825|      
# 1826|->   sqlite3_result_text(pCtx, zToken, -1, SQLITE_TRANSIENT);
# 1827|   }
# 1828|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/tool/sqldiff.c:1826: array_free: "sqlite3_result_text" frees array "zToken".
# 1824|     zSql = gobble_token(zSql, zToken, sizeof(zToken));
# 1825|     
# 1826|->   sqlite3_result_text(pCtx, zToken, -1, SQLITE_TRANSIENT);
# 1827|   }
# 1828|
(Example-1) Reason Marked as False Positive:
Freeing is ommited when SQLITE_TRANSIENT is set.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

', '2025-11-17 21:39:06.949345');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (52, 109, 'def44', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/shell.c:10458: cast_overflow: Truncation due to cast operation on "(szFile < 65536LL) ? szFile : 65536LL" from 64 to 32 bits.
sqlite-src-3450100/shell.c:10458: overflow_assign: "nRead" is assigned from "(int)((szFile < 65536LL) ? szFile : 65536LL)".
sqlite-src-3450100/shell.c:10460: overflow_sink: "nRead", which might have overflowed, is passed to "zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg)".
#10458|       nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
#10459|       iOff = szFile - nRead;
#10460|->     rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
#10461|     }else{
#10462|       nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:10458: cast_overflow: Truncation due to cast operation on "(szFile < 65536LL) ? szFile : 65536LL" from 64 to 32 bits.
sqlite-src-3450100/shell.c:10458: overflow_assign: "nRead" is assigned from "(int)((szFile < 65536LL) ? szFile : 65536LL)".
sqlite-src-3450100/shell.c:10460: overflow_sink: "nRead", which might have overflowed, is passed to "zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg)".
#10458|       nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
#10459|       iOff = szFile - nRead;
#10460|->     rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
#10461|     }else{
#10462|       nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10458: cast_overflow: Truncation due to cast operation on "(szFile < 65536LL) ? szFile : 65536LL" from 64 to 32 bits.
sqlite-src-3450100/shell.c:10458: overflow_assign: "nRead" is assigned from "(int)((szFile < 65536LL) ? szFile : 65536LL)".
sqlite-src-3450100/shell.c:10460: overflow_sink: "nRead", which might have overflowed, is passed to "zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg)".
#10458|       nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
#10459|       iOff = szFile - nRead;
#10460|->     rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
#10461|     }else{
#10462|       nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));
(Example-1) Reason Marked as False Positive:
On RHEL supported architectures is int 4B and this is not a problem.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10137: tainted_data_transitive: Call to function "zipfileReadCDS" with tainted argument "*aRead" transitively taints "pNew->cds.iOffset".
sqlite-src-3450100/shell.c:10179: underflow: The cast of "pNew->cds.iOffset" to a signed type could result in a negative number.
#10177|           }
#10178|         }else{
#10179|->         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
#10180|               (int)pNew->cds.iOffset
#10181|           );
(Example-2) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

', '2025-11-17 21:39:06.949346');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (53, 109, 'def45', 'BAD_FREE', 'sqlite-src-3450100/sqlite3.c:143889: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3.c:143889: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3.c:143898: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143896|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143897|         }else{
#143898|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143899|         }
#143900|       }else{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:143889: array_address: Taking address of array "rowid".
sqlite-src-3450100/sqlite3.c:143889: assign: Assigning: "zCol" = "rowid".
sqlite-src-3450100/sqlite3.c:143898: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143896|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143897|         }else{
#143898|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143899|         
#143900|       }else{', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/sqlite3.c:143889: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3.c:143889: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3.c:143898: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143896|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143897|         }else{
#143898|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143899|         }
#143900|       }else{
(Example-1) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/sqlite3_analyzer.c:143913: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143913: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143922: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143920|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143921|         }else{
#143922|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143923|         }
#143924|       }else{
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

', '2025-11-17 21:39:06.949346');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (59, 109, 'def51', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:237132: freed_arg: "fts5ExprAddChildren" frees "pLeft".
sqlite-src-3450100/sqlite3_analyzer.c:237149: double_free: Calling "sqlite3Fts5ParseNodeFree" frees pointer "pLeft" which has already been freed.
#237147|     if( pRet==0 ){
#237148|       assert( pParse->rc!=SQLITE_OK );
#237149|->     sqlite3Fts5ParseNodeFree(pLeft);
#237150|       sqlite3Fts5ParseNodeFree(pRight);
#237151|       sqlite3Fts5ParseNearsetFree(pNear);', 'TRUE POSITIVE', 'Double-free vulnerability (CWE-416) is possible as `fts5ExprAddChildren` frees `pLeft` (fts5_expr.c:2267) under certain conditions, and `sqlite3Fts5ParseNodeFree(pLeft)` is later called (sqlite3_analyzer.c:237149) without resetting the pointer to 0 or explicit NOOP evidence.', 'The CVE report snippet explicitly states that `fts5ExprAddChildren` frees `pLeft` (line 237132), which is later attempted to be freed again by `sqlite3Fts5ParseNodeFree` (line 237149), constituting a double-free vulnerability (CWE-416: Use After Free).

The provided source code for `fts5ExprAddChildren` (fts5_expr.c, lines 2261-2274) indeed frees `pSub` (which corresponds to `pLeft` in the CVE report) under certain conditions (when `p->eType!=FTS5_NOT && pSub->eType==p->eType`), specifically at line 2267: `sqlite3_free(pSub);`.

The code path leading to the potential double-free is clearly identifiable: if `pRet==0` (line 237147), the function proceeds to call `sqlite3Fts5ParseNodeFree(pLeft)` (line 237149), despite `pLeft` having been previously freed by `fts5ExprAddChildren`.

There is no explicit evidence within the provided code that the second call to `sqlite3Fts5ParseNodeFree(pLeft)` would be a NOOP (e.g., due to setting the pointer to 0 after the first free) or that the freeing in `fts5ExprAddChildren` is conditional on a factor that would prevent the double-free in this specific execution path.

Given the direct correlation between the code''s behavior and the vulnerability described in the CVE, and in adherence to the guideline that a single vulnerable path is sufficient for a TRUE POSITIVE finding, this issue cannot be considered a FALSE POSITIVE without further, unprovided context.', 'Examine the full execution path between the initial free at line 237132 and the second attempted free at line 237149 to identify any potential reassignments to `pLeft`.

Investigate the program''s state and memory management practices to determine if any mechanisms (e.g., setting pointers to NULL after free) are consistently applied to prevent double-free errors.

Analyze the call stack and surrounding code to assess if the conditional statement at line 237147 (`if( pRet==0 )`) could implicitly prevent the double-free under specific conditions not immediately apparent from the provided snippet.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/ext/fts5/fts5Int.h file:
738| int sqlite3Fts5ExprNew(
739|   Fts5Config *pConfig, 
740|   int bPhraseToAnd,
741|   int iCol,                       /* Column on LHS of MATCH operator */
742|   const char *zExpr,
743|   Fts5Expr **ppNew, 
744|   char **pzErr
745| );
746| int sqlite3Fts5ExprPattern(
747|   Fts5Config *pConfig, 
748|   int bGlob, 
749|   int iCol, 
750|   const char *zText, 
751|   Fts5Expr **pp
752| );
753| 
754| /*
755| ** for(rc = sqlite3Fts5ExprFirst(pExpr, pIdx, bDesc);
756| **     rc==SQLITE_OK && 0==sqlite3Fts5ExprEof(pExpr);
757| **     rc = sqlite3Fts5ExprNext(pExpr)
758| ** ){
759| **   // The document with rowid iRowid matches the expression!
760| **   i64 iRowid = sqlite3Fts5ExprRowid(pExpr);
761| ** }
762| */
763| int sqlite3Fts5ExprFirst(Fts5Expr*, Fts5Index *pIdx, i64 iMin, int bDesc);
764| int sqlite3Fts5ExprNext(Fts5Expr*, i64 iMax);
765| int sqlite3Fts5ExprEof(Fts5Expr*);
766| i64 sqlite3Fts5ExprRowid(Fts5Expr*);
767| 
768| void sqlite3Fts5ExprFree(Fts5Expr*);
769| int sqlite3Fts5ExprAnd(Fts5Expr **pp1, Fts5Expr *p2);
770| 
771| /* Called during startup to register a UDF with SQLite */
772| int sqlite3Fts5ExprInit(Fts5Global*, sqlite3*);
773| 
774| int sqlite3Fts5ExprPhraseCount(Fts5Expr*);
775| int sqlite3Fts5ExprPhraseSize(Fts5Expr*, int iPhrase);
776| int sqlite3Fts5ExprPoslist(Fts5Expr*, int, const u8 **);
777| 
778| typedef struct Fts5PoslistPopulator Fts5PoslistPopulator;
779| Fts5PoslistPopulator *sqlite3Fts5ExprClearPoslists(Fts5Expr*, int);
780| int sqlite3Fts5ExprPopulatePoslists(
781|     Fts5Config*, Fts5Expr*, Fts5PoslistPopulator*, int, const char*, int
782| );
783| void sqlite3Fts5ExprCheckPoslists(Fts5Expr*, i64);
784| 
785| int sqlite3Fts5ExprClonePhrase(Fts5Expr*, int, Fts5Expr**);
786| 
787| int sqlite3Fts5ExprPhraseCollist(Fts5Expr *, int, const u8 **, int *);
788| 
789| int sqlite3Fts5ExprQueryToken(Fts5Expr*, int, int, const char**, int*);
790| int sqlite3Fts5ExprInstToken(Fts5Expr*, i64, int, int, int, int, const char**, int*);
791| void sqlite3Fts5ExprClearTokens(Fts5Expr*);
792| 
793| /*******************************************
794| ** The fts5_expr.c API above this point is used by the other hand-written
795| ** C code in this module. The interfaces below this point are called by
796| ** the parser code in fts5parse.y.  */
797| 
798| void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...);
799| 
800| Fts5ExprNode *sqlite3Fts5ParseNode(
801|   Fts5Parse *pParse,
802|   int eType,
803|   Fts5ExprNode *pLeft,
804|   Fts5ExprNode *pRight,
805|   Fts5ExprNearset *pNear
806| );
807| 
808| Fts5ExprNode *sqlite3Fts5ParseImplicitAnd(
809|   Fts5Parse *pParse,
810|   Fts5ExprNode *pLeft,
811|   Fts5ExprNode *pRight
812| );
813| 
814| Fts5ExprPhrase *sqlite3Fts5ParseTerm(
815|   Fts5Parse *pParse, 
816|   Fts5ExprPhrase *pPhrase, 
817|   Fts5Token *pToken,
818|   int bPrefix
819| );
820| 
821| void sqlite3Fts5ParseSetCaret(Fts5ExprPhrase*);
822| 
823| Fts5ExprNearset *sqlite3Fts5ParseNearset(
824|   Fts5Parse*, 
825|   Fts5ExprNearset*,
826|   Fts5ExprPhrase* 
827| );
828| 
829| Fts5Colset *sqlite3Fts5ParseColset(
830|   Fts5Parse*, 
831|   Fts5Colset*, 
832|   Fts5Token *
833| );
834| 
835| void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase*);
836| void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset*);
837| void sqlite3Fts5ParseNodeFree(Fts5ExprNode*);
838| 
839| void sqlite3Fts5ParseSetDistance(Fts5Parse*, Fts5ExprNearset*, Fts5Token*);
840| void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNode*, Fts5Colset*);
841| Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse*, Fts5Colset*);
842| void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p);
843| void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token*);
844| 
845| /*
846| ** End of interface to code in fts5_expr.c.
847| **************************************************************************/
848| 
849| 
850| 
851| /**************************************************************************
852| ** Interface to code in fts5_aux.c. 
853| */
854| 
855| int sqlite3Fts5AuxInit(fts5_api*);
856| /*
857| ** End of interface to code in fts5_aux.c.
858| **************************************************************************/
859| 
860| /**************************************************************************
861| ** Interface to code in fts5_tokenizer.c. 
862| */
863| 
864| int sqlite3Fts5TokenizerInit(fts5_api*);
865| int sqlite3Fts5TokenizerPattern(
866|     int (*xCreate)(void*, const char**, int, Fts5Tokenizer**),
867|     Fts5Tokenizer *pTok
868| );
869| /*
870| ** End of interface to code in fts5_tokenizer.c.
871| **************************************************************************/
872| 
873| /**************************************************************************
874| ** Interface to code in fts5_vocab.c. 
875| */
876| 
877| int sqlite3Fts5VocabInit(Fts5Global*, sqlite3*);
878| 
879| /*
880| ** End of interface to code in fts5_vocab.c.
881| **************************************************************************/
882| 
883| 
884| /**************************************************************************
885| ** Interface to automatically generated code in fts5_unicode2.c. 
886| */
887| int sqlite3Fts5UnicodeIsdiacritic(int c);
888| int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic);
889| 
890| int sqlite3Fts5UnicodeCatParse(const char*, u8*);
891| int sqlite3Fts5UnicodeCategory(u32 iCode);
892| void sqlite3Fts5UnicodeAscii(u8*, u8*);
893| /*
894| ** End of interface to code in fts5_unicode2.c.
895| **************************************************************************/
896| 
897| #endif
code of /shared-data/source/sqlite-src-3450100/ext/fts5/fts5_expr.c file:
2261| static void fts5ExprAddChildren(Fts5ExprNode *p, Fts5ExprNode *pSub){
2262|   int ii = p->nChild;
2263|   if( p->eType!=FTS5_NOT && pSub->eType==p->eType ){
2264|     int nByte = sizeof(Fts5ExprNode*) * pSub->nChild;
2265|     memcpy(&p->apChild[p->nChild], pSub->apChild, nByte);
2266|     p->nChild += pSub->nChild;
2267|     sqlite3_free(pSub);
2268|   }else{
2269|     p->apChild[p->nChild++] = pSub;
2270|   }
2271|   for( ; ii<p->nChild; ii++){
2272|     p->iHeight = MAX(p->iHeight, p->apChild[ii]->iHeight + 1);
2273|   }
2274| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-1) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed
", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }
(Example-2) Reason Marked as False Positive:
members of apWiData is set set to 0 after freeing. Second Freeing will be NOOP

', '2025-11-17 21:39:06.949348');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (54, 109, 'def46', 'UNINIT', 'sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204923: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204921|         j++;
#204922|       }
#204923|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204924|       return j+1;
#204925|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#         j++;
#       }
#->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#       return j+1;
#     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204923: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204921|         j++;
#204922|       }
#204923|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204924|       return j+1;
#204925|     }
(Example-1) Reason Marked as False Positive:
opcode is initialized everytime the code steps into parse_string.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204899: uninit_use_in_call: Using uninitialized value "opcode" when calling "jsonBlobAppendNode".
#204897|         j++;
#204898|       }
#204899|->     jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
#204900|       return j+1;
#204901|     }
(Example-2) Reason Marked as False Positive:
The opcode is correctly initilized to JSONB_TEXT before jumping to the parse_string flag.

', '2025-11-17 21:39:06.949346');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (55, 109, 'def47', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:232787: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3_analyzer.c:232789: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232787|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232788|       }
#232789|->     sqlite3_free(ctx.zOut);
#232790|     }
#232791|     if( rc!=SQLITE_OK ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3_analyzer.c: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed.
#         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#       }
#->     sqlite3_free(ctx.zOut);
#     }
#     if( rc!=SQLITE_OK ){', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:232787: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3_analyzer.c:232789: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232787|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232788|       }
#232789|->     sqlite3_free(ctx.zOut);
#232790|     }
#232791|     if( rc!=SQLITE_OK ){
(Example-1) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK ){
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949347');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (56, 109, 'def48', 'RETURN_LOCAL', 'sqlite-src-3450100/sqlite3.c:81127: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3.c:81227: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3.c:81227: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81225|       *pzOut = 0;
#81226|     }else{
#81227|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81228|     }
#81229|     /* Make sure this analysis did not leave any unref() pages. */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:81127: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3.c:81227: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3.c:81227: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81225|       *pzOut = 0;
#81226|     }else{
#81227|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81228|     
#81229|     /* Make sure this analysis did not leave any unref() pages. */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RETURN_LOCAL (CWE-562):
sqlite-src-3450100/sqlite3.c:81127: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3.c:81227: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3.c:81227: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81225|       *pzOut = 0;
#81226|     }else{
#81227|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81228|     }
#81229|     /* Make sure this analysis did not leave any unref() pages. */
(Example-1) Reason Marked as False Positive:
sqlite checks is the array is malloced, and if not reallocs it and returns the reallocated one.

** Example-2 **
(Example-2) Known False Positive:
Error RETURN_LOCAL (CWE-562):
sqlite-src-3450100/sqlite3_analyzer.c:81151: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3_analyzer.c:81251: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3_analyzer.c:81251: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81249|       *pzOut = 0;
#81250|     }else{
#81251|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81252|     }
#81253|     /* Make sure this analysis did not leave any unref() pages. */
(Example-2) Reason Marked as False Positive:
It is returning integer

', '2025-11-17 21:39:06.949347');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (57, 109, 'def49', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3.c:201042: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3.c:201046: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
#201048|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3.c:201042: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3.c:201046: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
#201048|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3.c:201042: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3.c:201046: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
#201048|     }
(Example-1) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201045: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201045: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201043|       for(i=0; i<pIter->nPhrase; i++){
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
(Example-2) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

', '2025-11-17 21:39:06.949348');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (58, 109, 'def50', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116651: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116651: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116651: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.949348');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (60, 109, 'def52', 'BAD_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:143913: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143913: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143922: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143920|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143921|         }else{
#143922|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143923|         }
#143924|       }else{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: array_address: Taking address of array "rowid".
sqlite-src-3450100/sqlite3_analyzer.c: assign: Assigning: "zCol" = "rowid".
sqlite-src-3450100/sqlite3_analyzer.c: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#         }else{
#->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#         }
#       }else{', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/sqlite3_analyzer.c:143913: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143913: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3_analyzer.c:143922: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143920|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143921|         }else{
#143922|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143923|         }
#143924|       }else{
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-763):
sqlite-src-3450100/sqlite3.c:143889: array_address: Taking address of array ""rowid"".
sqlite-src-3450100/sqlite3.c:143889: assign: Assigning: "zCol" = ""rowid"".
sqlite-src-3450100/sqlite3.c:143898: incorrect_free: "sqlite3VdbeSetColName" frees incorrect pointer "zCol".
#143896|           sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
#143897|         }else{
#143898|->         sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
#143899|         }
#143900|       }else{
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.949349');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (61, 109, 'def53', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:13847: assign: Assigning: "pScanOrig" = "p->pScan".
sqlite-src-3450100/shell.c:13882: freed_arg: "idxScanFree" frees "p->pScan".
sqlite-src-3450100/shell.c:13884: use_after_free: Using freed pointer "pScanOrig".
#13882|       idxScanFree(p->pScan, pScanOrig);
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|->     p->pScan = pScanOrig;
#13885|       p->pStatement = pStmtOrig;
#13886|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:13847: assign: Assigning: "pScanOrig" = "p->pScan".
sqlite-src-3450100/shell.c:13882: freed_arg: "idxScanFree" frees "p->pScan".
sqlite-src-3450100/shell.c:13884: use_after_free: Using freed pointer "pScanOrig".
#13882|       idxScanFree(p->pScan, pScanOrig);
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|->     p->pScan = pScanOrig;
#13885|       p->pStatement = pStmtOrig;
#13886|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:13847: assign: Assigning: "pScanOrig" = "p->pScan".
sqlite-src-3450100/shell.c:13882: freed_arg: "idxScanFree" frees "p->pScan".
sqlite-src-3450100/shell.c:13884: use_after_free: Using freed pointer "pScanOrig".
#13882|       idxScanFree(p->pScan, pScanOrig);
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|->     p->pScan = pScanOrig;
#13885|       p->pStatement = pStmtOrig;
#13886|     }
(Example-1) Reason Marked as False Positive:
pScanOrig is not freed, because it is the pLast, and thus p->pScan is nto freed, as they point to the same address.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:13848: assign: Assigning: "pStmtOrig" = "p->pStatement".
sqlite-src-3450100/shell.c:13883: freed_arg: "idxStatementFree" frees "p->pStatement".
sqlite-src-3450100/shell.c:13885: use_after_free: Using freed pointer "pStmtOrig".
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|       p->pScan = pScanOrig;
#13885|->     p->pStatement = pStmtOrig;
#13886|     }
#13887|
(Example-2) Reason Marked as False Positive:
pStmtOrig is not freed in idxStatementFree

', '2025-11-17 21:39:06.949349');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (62, 109, 'def54', 'BAD_FREE', 'sqlite-src-3450100/shell.c:7636: array_free: "sqlite3_result_text" frees array "z".
# 7634|     }
# 7635|     z[10] = ''\0'';
# 7636|->   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
# 7637|   }
# 7638|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:7636: array_free: "sqlite3_result_text" frees array "z".
# 7634|     }
# 7635|     z[10] = ''\0'';
# 7636|->   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
# 7637|   }
# 7638|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:7636: array_free: "sqlite3_result_text" frees array "z".
# 7634|     }
# 7635|     z[10] = ''\0'';
# 7636|->   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
# 7637|   }
# 7638|
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

', '2025-11-17 21:39:06.94935');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (63, 109, 'def55', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:154750: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3_analyzer.c:154772: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154770|       if( sCtx.bDeclared==0 ){
#154771|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154772|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154773|         sqlite3VtabUnlock(pVTable);
#154774|         rc = SQLITE_ERROR;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:154726: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3.c:154748: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154746|       if( sCtx.bDeclared==0 ){
#154747|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154748|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154749|         sqlite3VtabUnlock(pVTable);
#154750|         rc = SQLITE_ERROR;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:154726: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3.c:154748: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154746|       if( sCtx.bDeclared==0 ){
#154747|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154748|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154749|         sqlite3VtabUnlock(pVTable);
#154750|         rc = SQLITE_ERROR;
(Example-1) Reason Marked as False Positive:
54eb54c7de06e050023d97dc521e77308bf3df64
^this is a commit where upstream addresses this issue, even thougth they claim this is false positive.
more info in a forum thread: https://sqlite.org/forum/forumpost/cafbe582e8

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.94935');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (68, 109, 'def60', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:237108: freed_arg: "fts5ExprAddChildren" frees "pLeft".
sqlite-src-3450100/sqlite3.c:237125: double_free: Calling "sqlite3Fts5ParseNodeFree" frees pointer "pLeft" which has already been freed.
#237123|     if( pRet==0 ){
#237124|       assert( pParse->rc!=SQLITE_OK );
#237125|->     sqlite3Fts5ParseNodeFree(pLeft);
#237126|       sqlite3Fts5ParseNodeFree(pRight);
#237127|       sqlite3Fts5ParseNearsetFree(pNear);', 'TRUE POSITIVE', 'Double-free vulnerability (CWE-416) confirmed: `fts5ExprAddChildren` frees `pLeft` at #237108, with no subsequent NULL assignment, and is later attempted to be freed again by `sqlite3Fts5ParseNodeFree` at #237125, within the execution path conditioned by `if( pRet==0 )` at #237123.', 'Explicit double-free error reported in the CVE snippet, indicating a potential vulnerability (CWE-416: Use After Free).

At line #237108, `fts5ExprAddChildren` is confirmed to free the pointer `pLeft`.

Subsequent execution at line #237125 attempts to free the same pointer `pLeft` using `sqlite3Fts5ParseNodeFree`, despite it being already freed.

The conditional statement at line #237123 (`if( pRet==0 )`) does not mitigate the double-free vulnerability, as it only determines the execution path that leads to the second free, but does not prevent the initial free at #237108.

No evidence within the provided code snippet suggests that the `pLeft` pointer is set to NULL after being freed at #237108, which would prevent the double-free error.

The provided examples (Example-1 and Example-2) of known false positives are distinguished by the presence of `SQLITE_TRANSIENT`, which is not mentioned in the context of the reported CVE, thus not applicable to this investigation.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-1) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949352');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (64, 109, 'def56', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77757: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77755|       if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|->       pEnd = pCArray->apEnd[k];
#77758|       }
#77759|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77757: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77755|       if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|->       pEnd = pCArray->apEnd[k];
#77758|       }
#77759|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77757: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77755|       if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|->       pEnd = pCArray->apEnd[k];
#77758|       }
#77759|     }
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77669: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77667|       if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|->       pSrcEnd = pCArray->apEnd[k];
#77670|       }
#77671|     }
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.94935');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (65, 109, 'def57', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-1) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

', '2025-11-17 21:39:06.949351');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (66, 109, 'def58', 'UNINIT', 'sqlite-src-3450100/sqlite3.c:204919: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3.c:205024: uninit_use: Using uninitialized value "seenE".
#205022|             }
#205023|           }
#205024|->         if( seenE ){
#205025|             pParse->iErr = j;
#205026|             return -1;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:204919: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3.c:205024: uninit_use: Using uninitialized value "seenE".
#|             }
#|           }
#|->         if( seenE ){
#|             pParse->iErr = j;
#|             return -1;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204919: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3.c:205024: uninit_use: Using uninitialized value "seenE".
#205022|             }
#205023|           }
#205024|->         if( seenE ){
#205025|             pParse->iErr = j;
#205026|             return -1;
(Example-1) Reason Marked as False Positive:
seenE is set before entering the goto section.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204943: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3_analyzer.c:205048: uninit_use: Using uninitialized value "seenE".
#205046|             }
#205047|           }
#205048|->         if( seenE ){
#205049|             pParse->iErr = j;
#205050|             return -1;
(Example-2) Reason Marked as False Positive:
seenE is set ahead every jump to parse_number_2

', '2025-11-17 21:39:06.949351');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (67, 109, 'def59', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:10563: freed_arg: "zipfileResetCursor" frees "pCsr->pFreeEntry".
sqlite-src-3450100/shell.c:10606: use_after_free: Using freed pointer "pCsr->pFreeEntry".
#10604|     }else{
#10605|       pCsr->bNoop = 1;
#10606|->     pCsr->pCurrent = pCsr->pFreeEntry ? pCsr->pFreeEntry : pTab->pFirstEntry;
#10607|       rc = zipfileNext(cur);
#10608|     }', 'TRUE POSITIVE', 'Direct use-after-free vulnerability at `sqlite-src-3450100/shell.c:10606`, where potentially freed `pCsr->pFreeEntry` (freed at `#10563`) is assigned to `pCsr->pCurrent` without explicit nullification or safeguarding after free.', 'Direct evidence of `use_after_free` vulnerability: the `pCsr->pFreeEntry` pointer is explicitly marked as freed at `sqlite-src-3450100/shell.c:10563` by `zipfileResetCursor`.

At `sqlite-src-3450100/shell.c:10606`, the potentially freed `pCsr->pFreeEntry` is used to assign a value to `pCsr->pCurrent`, demonstrating a clear use-after-free scenario.

The conditional statement `pCsr->pFreeEntry ? pCsr->pFreeEntry : pTab->pFirstEntry` at `#10606` does not mitigate the vulnerability; if `pCsr->pFreeEntry` is not NULL, the freed pointer is still used.

There is no explicit evidence within the provided code snippet that `pCsr->pFreeEntry` is set to NULL or otherwise safeguarded after being freed at `#10563`, which would be necessary to prevent the use-after-free vulnerability.

The execution path leading to the vulnerability is clear and direct, with no apparent misinterpretation of the code''s explicit behavior based on the provided context.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:67013: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:67046: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67044|       }
#67045|       WALTRACE(("WAL%p: closed
", pWal));
#67046|->     sqlite3_free((void *)pWal->apWiData);
#67047|       sqlite3_free(pWal);
#67048|     }
(Example-1) Reason Marked as False Positive:
Its calling realloc, not free.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:191091: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:191127: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191125|     pCsr->iLangid = iLangVal;
#191126|   
#191127|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191128|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191129|     );
(Example-2) Reason Marked as False Positive:
pCsr.filter is set to NULL and nTerm is set to zero to avoid invalid access.

', '2025-11-17 21:39:06.949351');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (99, 109, 'def91', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3.c:95802: assign: Assigning: "pIn1" = "&aMem[pOp->p1]".
sqlite-src-3450100/sqlite3.c:95841: equal: The address of "pIn1->u.r" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3.c:95841: equal: The address of "pIn1->u.i" is equal to "aMem + pOp->p1".
sqlite-src-3450100/sqlite3.c:95841: overlapping_assignment: Assigning "pIn1->u.i" to "pIn1->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3.c:95841: target_type: "pIn1->u.r" has type "double".
sqlite-src-3450100/sqlite3.c:95841: source_type: "pIn1->u.i" has type "long long".
#95839|                 pIn1->flags &= ~MEM_Int;
#95840|               }else{
#95841|->               pIn1->u.r = (double)pIn1->u.i;
#95842|                 pIn1->flags |= MEM_Real;
#95843|                 pIn1->flags &= ~MEM_Int;', 'TRUE POSITIVE', 'Assignment at line #95841 potentially leads to data corruption or unexpected behavior due to overlapping memory locations of different types (`double` and `long long`) without ensuring sufficient memory allocation, directly correlating with the CVE''s described `overlapping_assignment` vulnerability.', '**Overlapping Memory Locations with Different Types**'': The CVE report highlights that `pIn1->u.r` (type `double`) and `pIn1->u.i` (type `long long`) have overlapping memory locations. This is confirmed by the equal addresses at lines `95841` in the CVE report.

**Explicit Type Casting but No Memory Reallocation**'': At line `#95841`, the code explicitly casts the value of `pIn1->u.i` (a `long long`) to a `double` and assigns it to `pIn1->u.r`. Since `double` and `long long` likely have different sizes (typically 8 bytes for both, but this can vary by platform, and the cast itself doesn''t change the memory allocation), this operation can lead to data corruption or unexpected behavior if the memory for `pIn1->u` was not allocated to accommodate the larger of the two types or if the types'' sizes differ.

**Flag Management Doesn''t Mitigate the Vulnerability**'': While the code manages flags (`MEM_Int` and `MEM_Real`) to track the type of data stored (lines `#95839`, `#95842`, `#95843`), this does not prevent the overlapping assignment issue. It merely updates the metadata about the stored value without ensuring the memory safety of the assignment.

**Direct Correlation to CVE Description**'': The described issue directly correlates with the CVE report''s mention of an `overlapping_assignment` with different types, indicating a potential vulnerability in how the code handles memory for different data types.', 'Verify the memory allocation size for `pIn1->u` to determine if it can accommodate both `double` and `long long` without overflow.

Investigate platform-specific behaviors for `double` and `long long` sizes to assess variability in vulnerability impact.

Examine the implementation of the type casting operation at line `#95841` to ensure no implicit memory reallocation or safety checks are in place.', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.949364');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (69, 109, 'def61', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:13848: assign: Assigning: "pStmtOrig" = "p->pStatement".
sqlite-src-3450100/shell.c:13883: freed_arg: "idxStatementFree" frees "p->pStatement".
sqlite-src-3450100/shell.c:13885: use_after_free: Using freed pointer "pStmtOrig".
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|       p->pScan = pScanOrig;
#13885|->     p->pStatement = pStmtOrig;
#13886|     }
#13887|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:13848: assign: Assigning: "pStmtOrig" = "p->pStatement".
sqlite-src-3450100/shell.c:13883: freed_arg: "idxStatementFree" frees "p->pStatement".
sqlite-src-3450100/shell.c:13885: use_after_free: Using freed pointer "pStmtOrig".
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|       p->pScan = pScanOrig;
#13885|->     p->pStatement = pStmtOrig;
#13886|     }
#13887|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:13848: assign: Assigning: "pStmtOrig" = "p->pStatement".
sqlite-src-3450100/shell.c:13883: freed_arg: "idxStatementFree" frees "p->pStatement".
sqlite-src-3450100/shell.c:13885: use_after_free: Using freed pointer "pStmtOrig".
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|       p->pScan = pScanOrig;
#13885|->     p->pStatement = pStmtOrig;
#13886|     }
#13887|
(Example-1) Reason Marked as False Positive:
pStmtOrig is not freed in idxStatementFree

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:13847: assign: Assigning: "pScanOrig" = "p->pScan".
sqlite-src-3450100/shell.c:13882: freed_arg: "idxScanFree" frees "p->pScan".
sqlite-src-3450100/shell.c:13884: use_after_free: Using freed pointer "pScanOrig".
#13882|       idxScanFree(p->pScan, pScanOrig);
#13883|       idxStatementFree(p->pStatement, pStmtOrig);
#13884|->     p->pScan = pScanOrig;
#13885|       p->pStatement = pStmtOrig;
#13886|     }
(Example-2) Reason Marked as False Positive:
pScanOrig is not freed, because it is the pLast, and thus p->pScan is nto freed, as they point to the same address.

', '2025-11-17 21:39:06.949352');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (70, 109, 'def62', 'OVERRUN', 'sqlite-src-3450100/shell.c:27449: overrun-buffer-val: Overrunning array "p->nullValue" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27447|       }
#27448|       oputf("%12.12s: ", "nullvalue");
#27449|->     output_c_string(p->nullValue);
#27450|       oputz("\n");
#27451|       oputf("%12.12s: %s\n","output",', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:27449: overrun-buffer-val: Overrunning array "p->nullValue" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27447|       }
#27448|       oputf("%12.12s: ", "nullvalue");
#27449|->     output_c_string(p->nullValue);
#27450|       oputz("\n");
#27451|       oputf("%12.12s: %s\n","output",', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27449: overrun-buffer-val: Overrunning array "p->nullValue" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27447|       }
#27448|       oputf("%12.12s: ", "nullvalue");
#27449|->     output_c_string(p->nullValue);
#27450|       oputz("
");
#27451|       oputf("%12.12s: %s
","output",
(Example-1) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
(Example-2) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

', '2025-11-17 21:39:06.949353');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (71, 109, 'def63', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77750: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77748|     if( iEnd<=iFirst ) return 0;
#77749|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77750|->   pEnd = pCArray->apEnd[k];
#77751|     while( 1 /*Exit by break*/ ){
#77752|       int sz, rc;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77750: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77748|     if( iEnd<=iFirst ) return 0;
#77749|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77750|->   pEnd = pCArray->apEnd[k];
#77751|     while( 1 /*Exit by break*/ ){
#77752|       int sz, rc;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77750: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77748|     if( iEnd<=iFirst ) return 0;
#77749|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77750|->   pEnd = pCArray->apEnd[k];
#77751|     while( 1 /*Exit by break*/ ){
#77752|       int sz, rc;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3.c:77726: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77724|     if( iEnd<=iFirst ) return 0;
#77725|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77726|->   pEnd = pCArray->apEnd[k];
#77727|     while( 1 /*Exit by break*/ ){
#77728|       int sz, rc;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949353');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (72, 109, 'def64', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77667: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77665|   
#77666|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77667|->   pSrcEnd = pCArray->apEnd[k];
#77668|   
#77669|     pData = pEnd;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77667: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77665|   
#77666|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77667|->   pSrcEnd = pCArray->apEnd[k];
#77668|   
#77669|     pData = pEnd;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77667: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77665|   
#77666|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}
#77667|->   pSrcEnd = pCArray->apEnd[k];
#77668|   
#77669|     pData = pEnd;
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_const: Checking "k < 6" implies that "k" is 6 on the false branch.
sqlite-src-3450100/sqlite3_analyzer.c:77750: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77748|     if( iEnd<=iFirst ) return 0;
#77749|     for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}
#77750|->   pEnd = pCArray->apEnd[k];
#77751|     while( 1 /*Exit by break*/ ){
#77752|       int sz, rc;
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949353');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (73, 109, 'def65', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }', 'TRUE POSITIVE', 'Code at line 87908 attempts to free potentially already freed `p->zErrMsg` pointer (as indicated by the CVE report snippet), with no explicit null or double-free prevention within the `sqlite3DbFree` function''s provided implementation, establishing a direct link to the described double-free vulnerability.', 'The CVE report snippet explicitly states a `double_free` error at line 87908, indicating that the pointer `p->zErrMsg` is being freed twice.

The code at line 87908 (`sqlite3DbFree(db, p->zErrMsg);`) indeed attempts to free the `p->zErrMsg` pointer, assuming it is not null (checked at line 87907).

The function `sqlite3DbFree` (defined in `malloc.c`) does not contain an explicit null pointer check within its implementation (lines 421-459). Unlike Example-2, there is no indication that `sqlite3DbFree(D,X)` is a harmless no-op when `X==0` is not applicable here as the check is present before calling `sqlite3DbFree`.

There is no evidence within the provided source code (specifically within the `sqlite3DbFree` function or the snippet from `sqlite3.c`) that suggests `p->zErrMsg` is not actually freed when `sqlite3VdbeTransferError` is called, unlike Example-1 where a specific condition (SQLITE_TRANSIENT) prevented the freeing.

Given the explicit operations performed, there is a direct and demonstrable link between the code''s behavior and the vulnerability described in the CVE (double-freeing `p->zErrMsg`), with at least one execution path (when `p->zErrMsg` is not null) potentially triggering the vulnerability.', 'Obtain and examine the implementation details of `sqlite3DbFree` to determine if it contains a null pointer check or handles already-freed pointers as a harmless no-op.

Investigate if there are any external factors (e.g., compiler optimizations, specific SQLite configurations) that could influence the behavior of `sqlite3DbFree` in the context of the reported CVE.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/src/malloc.c file:
421| void sqlite3DbFreeNN(sqlite3 *db, void *p){
422|   assert( db==0 || sqlite3_mutex_held(db->mutex) );
423|   assert( p!=0 );
424|   if( db ){
425|     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
426| #ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
427|       if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
428|         LookasideSlot *pBuf = (LookasideSlot*)p;
429|         assert( db->pnBytesFreed==0 );
430| #ifdef SQLITE_DEBUG
431|         memset(p, 0xaa, LOOKASIDE_SMALL);  /* Trash freed content */
432| #endif
433|         pBuf->pNext = db->lookaside.pSmallFree;
434|         db->lookaside.pSmallFree = pBuf;
435|         return;
436|       }
437| #endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */
438|       if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
439|         LookasideSlot *pBuf = (LookasideSlot*)p;
440|         assert( db->pnBytesFreed==0 );
441| #ifdef SQLITE_DEBUG
442|         memset(p, 0xaa, db->lookaside.szTrue);  /* Trash freed content */
443| #endif
444|         pBuf->pNext = db->lookaside.pFree;
445|         db->lookaside.pFree = pBuf;
446|         return;
447|       }
448|     }
449|     if( db->pnBytesFreed ){
450|       measureAllocationSize(db, p);
451|       return;
452|     }
453|   }
454|   assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
455|   assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
456|   assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );
457|   sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
458|   sqlite3_free(p);
459| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-1) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:87891: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3.c:87908: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87906|   #endif
#87907|     if( p->zErrMsg ){
#87908|->     sqlite3DbFree(db, p->zErrMsg);
#87909|       p->zErrMsg = 0;
#87910|     }
(Example-2) Reason Marked as False Positive:
From sqlite''s comments:
Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.

sqlite3DbFree contains null pointer check.

', '2025-11-17 21:39:06.949354');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (74, 109, 'def66', 'USE_AFTER_FREE', 'sqlite-src-3450100/shell.c:7876: freed_arg: "sqlite3_result_text" frees "aBuf".
sqlite-src-3450100/shell.c:7877: double_free: Calling "sqlite3_free" frees pointer "aBuf" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 7875|   
# 7876|           sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
# 7877|->         if( aBuf!=aStatic ) sqlite3_free(aBuf);
# 7878|   #endif
# 7879|         }else{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:7876: freed_arg: "sqlite3_result_text" frees "aBuf".
sqlite-src-3450100/shell.c:7877: double_free: Calling "sqlite3_free" frees pointer "aBuf" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 7875|   
# 7876|           sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
# 7877|->         if( aBuf!=aStatic ) sqlite3_free(aBuf);
# 7878|   #endif
# 7879|         }else{', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:7876: freed_arg: "sqlite3_result_text" frees "aBuf".
sqlite-src-3450100/shell.c:7877: double_free: Calling "sqlite3_free" frees pointer "aBuf" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 7875|   
# 7876|           sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
# 7877|->         if( aBuf!=aStatic ) sqlite3_free(aBuf);
# 7878|   #endif
# 7879|         }else{
(Example-1) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK ){
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949354');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (75, 109, 'def67', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3.c:127622: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3.c:127623: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127621|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127622|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127623|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127624|         }
#127625|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:127622: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3.c:127623: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127621|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127622|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127623|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127624|         }
#127625|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:127622: cast_overflow: Truncation due to cast operation on "iCol" from 32 to 16 bits.
sqlite-src-3450100/sqlite3.c:127623: overflow_sink: "iCol", which might have overflowed, is passed to "sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld + kk + 1)".
#127621|         if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
#127622|           int kk = sqlite3TableColumnToStorage(pTab, iCol);
#127623|->         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
#127624|         }
#127625|       }
(Example-1) Reason Marked as False Positive:
iCol in this case can not be bigger that i16, as the condition in for loop look looks as follows:
for(iCol=0; iCol<pTab->nCol; iCol++){
and pTab->nCol is i16

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:31105: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3.c:31105: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3.c:31105: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3.c:31699: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:31701: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31699|       width -= length;
#31700|       if( width>0 ){
#31701|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31702|         sqlite3_str_append(pAccum, bufpt, length);
#31703|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-2) Reason Marked as False Positive:
there is check if width is bigger than 0

', '2025-11-17 21:39:06.949355');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (76, 109, 'def68', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77779: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77777|       i++;
#77778|       if( i>=iEnd ) break;
#77779|->     if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|         pEnd = pCArray->apEnd[k];', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77779: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77777|       i++;
#77778|       if( i>=iEnd ) break;
#77779|->     if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|         pEnd = pCArray->apEnd[k];', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77779: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77777|       i++;
#77778|       if( i>=iEnd ) break;
#77779|->     if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|         pEnd = pCArray->apEnd[k];
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug: https://sqlite.org/forum/forumpost/d0e144c233c7b286 Upstream also added some asserts to future releases so that static analysers are not confused. In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77691: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77689|       i++;
#77690|       if( i>=iEnd ) break;
#77691|->     if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|         pSrcEnd = pCArray->apEnd[k];
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949355');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (77, 109, 'def69', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:154726: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3.c:154748: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154746|       if( sCtx.bDeclared==0 ){
#154747|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154748|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154749|         sqlite3VtabUnlock(pVTable);
#154750|         rc = SQLITE_ERROR;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:154726: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3.c:154748: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154746|       if( sCtx.bDeclared==0 ){
#154747|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154748|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154749|         sqlite3VtabUnlock(pVTable);
#154750|         rc = SQLITE_ERROR;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:154726: freed_arg: "sqlite3DeleteTable" frees "pTab->zName".
sqlite-src-3450100/sqlite3.c:154748: pass_freed_arg: Passing freed pointer "pTab->zName" as an argument to "sqlite3MPrintf".
#154746|       if( sCtx.bDeclared==0 ){
#154747|         const char *zFormat = "vtable constructor did not declare schema: %s";
#154748|->       *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
#154749|         sqlite3VtabUnlock(pVTable);
#154750|         rc = SQLITE_ERROR;
(Example-1) Reason Marked as False Positive:
54eb54c7de06e050023d97dc521e77308bf3df64
^this is a commit where upstream addresses this issue, even thougth they claim this is false positive.
more info in a forum thread: https://sqlite.org/forum/forumpost/cafbe582e8

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

', '2025-11-17 21:39:06.949356');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (78, 109, 'def70', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:186463: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c:186463: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3_analyzer.c:186468: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186471: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186469|       }
#186470|       assert( zBuffer );
#186471|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186472|       nBuffer = nPrefix + nSuffix;
#186473|       zCsr += nSuffix;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3_analyzer.c: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:186463: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c:186463: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3_analyzer.c:186468: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186472: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186447: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186456: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3_analyzer.c:186460: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3_analyzer.c:186471: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186469|       }
#186470|       assert( zBuffer );
#186471|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186472|       nBuffer = nPrefix + nSuffix;
#186473|       zCsr += nSuffix;
(Example-1) Reason Marked as False Positive:
length of zBuffer is always bigger that nPrefix.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:186439: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:186439: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3.c:186444: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186447: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186445|       }
#186446|       assert( zBuffer );
#186447|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186448|       nBuffer = nPrefix + nSuffix;
#186449|       zCsr += nSuffix;
(Example-2) Reason Marked as False Positive:
nBuffer is realloc -ed when nPrefix is bigger.

', '2025-11-17 21:39:06.949356');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (79, 109, 'def71', 'OVERRUN', 'sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77781: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77779|       if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|->       pEnd = pCArray->apEnd[k];
#77782|       }
#77783|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77781: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77779|       if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|->       pEnd = pCArray->apEnd[k];
#77782|       }
#77783|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77749: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77780: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77781: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77779|       if( pCArray->ixNx[k]<=i ){
#77780|         k++;
#77781|->       pEnd = pCArray->apEnd[k];
#77782|       }
#77783|     }
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:77666: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3_analyzer.c:77692: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3_analyzer.c:77693: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77691|       if( pCArray->ixNx[k]<=i ){
#77692|         k++;
#77693|->       pSrcEnd = pCArray->apEnd[k];
#77694|       }
#77695|     }
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug: https://sqlite.org/forum/forumpost/d0e144c233c7b286 Upstream also added some asserts to future releases so that static analysers are not confused. In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949356');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (80, 109, 'def72', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3_analyzer.c:31129: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3_analyzer.c:31129: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:31129: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3_analyzer.c:31723: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:31725: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31723|       width -= length;
#31724|       if( width>0 ){
#31725|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31726|         sqlite3_str_append(pAccum, bufpt, length);
#31727|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:31129: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3_analyzer.c:31129: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:31129: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3_analyzer.c:31723: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:31725: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31723|       width -= length;
#31724|       if( width>0 ){
#31725|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31726|         sqlite3_str_append(pAccum, bufpt, length);
#31727|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3_analyzer.c:31129: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3_analyzer.c:31129: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:31129: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3_analyzer.c:31723: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:31725: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31723|       width -= length;
#31724|       if( width>0 ){
#31725|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31726|         sqlite3_str_append(pAccum, bufpt, length);
#31727|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-1) Reason Marked as False Positive:
there is check if width is bigger than 0

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:31105: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3.c:31105: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3.c:31105: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3.c:31699: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:31701: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31699|       width -= length;
#31700|       if( width>0 ){
#31701|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31702|         sqlite3_str_append(pAccum, bufpt, length);
#31703|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-2) Reason Marked as False Positive:
there is check if width is bigger than 0

', '2025-11-17 21:39:06.949357');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (81, 109, 'def73', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;', 'FALSE POSITIVE', 'Assignment of `zOut` to `sqlite3_result_text` with `SQLITE_TRANSIENT` flag (line #116667) ensures its memory is not freed, thus preventing the reported double-free vulnerability at line #116668 (`sqlite3DbFree(db, zOut)`).', 'The `sqlite3_result_text` function at line #116667 is called with the `SQLITE_TRANSIENT` flag, which, based on the provided examples (Example-1 and Example-2), indicates that the memory pointed to by `zOut` is not freed by this function call.

The assignment of `zBuf1` and `zBuf2` at lines #116611 and #116612, respectively, does not directly contribute to the double-free vulnerability, as the concern is about the freeing of `zOut`, not the buffers derived from it.

The reported double-free error at line #116668 (`sqlite3DbFree(db, zOut)`) is predicated on `zOut` being freed by `sqlite3_result_text`, which, as established, does not occur when `SQLITE_TRANSIENT` is specified.

Given the explicit behavior of the code with the `SQLITE_TRANSIENT` flag, there is no execution path within the provided snippet that leads to a double-free vulnerability for `zOut`.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-1) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:116611: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116612: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3_analyzer.c:116651: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3_analyzer.c:116667: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3_analyzer.c:116668: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116666|   
#116667|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116668|->     sqlite3DbFree(db, zOut);
#116669|     }else{
#116670|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

', '2025-11-17 21:39:06.949357');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (82, 109, 'def74', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10137: tainted_data_transitive: Call to function "zipfileReadCDS" with tainted argument "*aRead" transitively taints "pNew->cds.iOffset".
sqlite-src-3450100/shell.c:10179: underflow: The cast of "pNew->cds.iOffset" to a signed type could result in a negative number.
#10177|           }
#10178|         }else{
#10179|->         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
#10180|               (int)pNew->cds.iOffset
#10181|           );', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10137: tainted_data_transitive: Call to function "zipfileReadCDS" with tainted argument "*aRead" transitively taints "pNew->cds.iOffset".
sqlite-src-3450100/shell.c:10179: underflow: The cast of "pNew->cds.iOffset" to a signed type could result in a negative number.
#10177|           }
#10178|         }else{
#10179|->         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
#10180|               (int)pNew->cds.iOffset
#10181|           );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10137: tainted_data_transitive: Call to function "zipfileReadCDS" with tainted argument "*aRead" transitively taints "pNew->cds.iOffset".
sqlite-src-3450100/shell.c:10179: underflow: The cast of "pNew->cds.iOffset" to a signed type could result in a negative number.
#10177|           }
#10178|         }else{
#10179|->         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
#10180|               (int)pNew->cds.iOffset
#10181|           );
(Example-1) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10124: tainted_data_transitive: Call to function "zipfileGetU16" with tainted argument "*aRead" returns tainted data.
sqlite-src-3450100/shell.c:10124: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10125: overflow: The tainted expression "nExtra" is used in an arithmetic operation. The expression "nExtra" is considered to have possibly overflowed.
sqlite-src-3450100/shell.c:10127: overflow: The expression "96UL + nExtra" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/shell.c:10127: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10132: overflow_sink: "nAlloc", which might have underflowed, is passed to "sqlite3_malloc64(nAlloc)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#10130|       }
#10131|   
#10132|->     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
#10133|       if( pNew==0 ){
#10134|         rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

', '2025-11-17 21:39:06.949357');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (83, 109, 'def75', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:66030: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:66044: use_after_free: Using freed pointer "pWal->apWiData".
#66042|           }
#66043|         }
#66044|->       pWal->apWiData[iPg] = aShare;
#66045|         SEH_SET_ON_ERROR(0,0);
#66046|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:66030: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:66044: use_after_free: Using freed pointer "pWal->apWiData".
#66042|           }
#66043|         }
#66044|->       pWal->apWiData[iPg] = aShare;
#66045|         SEH_SET_ON_ERROR(0,0);
#66046|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:66030: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:66044: use_after_free: Using freed pointer "pWal->apWiData".
#66042|           }
#66043|         }
#66044|->       pWal->apWiData[iPg] = aShare;
#66045|         SEH_SET_ON_ERROR(0,0);
#66046|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);
(Example-1) Reason Marked as False Positive:
It is realloc, not free.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:66006: freed_arg: "walIndexAppend" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:66020: use_after_free: Using freed pointer "pWal->apWiData".
#66018|           }
#66019|         }
#66020|->       pWal->apWiData[iPg] = aShare;
#66021|         SEH_SET_ON_ERROR(0,0);
#66022|         nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);
(Example-2) Reason Marked as False Positive:
wallIndexAppend does not free pWal->apWiData, but reallocates it.

', '2025-11-17 21:39:06.949358');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (84, 109, 'def76', 'OVERRUN', 'sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("\n");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("\n");
#27459|       switch( p->statsOn ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("\n");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("\n");
#27459|       switch( p->statsOn );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("
");
#27459|       switch( p->statsOn ){
(Example-1) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
(Example-2) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

', '2025-11-17 21:39:06.949358');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (85, 109, 'def77', 'BAD_FREE', 'sqlite-src-3450100/shell.c:5436: array_free: "sqlite3_result_text" frees array "zResult".
# 5434|           sqlite3_snprintf(sizeof(zResult), zResult, "ieee754(%lld,%d)",
# 5435|                            m, e-1075);
# 5436|->         sqlite3_result_text(context, zResult, -1, SQLITE_TRANSIENT);
# 5437|           break;
# 5438|         case 1:', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:5436: array_free: "sqlite3_result_text" frees array "zResult".
# 5434|           sqlite3_snprintf(sizeof(zResult), zResult, "ieee754(%lld,%d)",
# 5435|                            m, e-1075);
# 5436|->         sqlite3_result_text(context, zResult, -1, SQLITE_TRANSIENT);
# 5437|           break;
# 5438|         case 1:', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:5436: array_free: "sqlite3_result_text" frees array "zResult".
# 5434|           sqlite3_snprintf(sizeof(zResult), zResult, "ieee754(%lld,%d)",
# 5435|                            m, e-1075);
# 5436|->         sqlite3_result_text(context, zResult, -1, SQLITE_TRANSIENT);
# 5437|           break;
# 5438|         case 1:
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:2057: array_free: "sqlite3_result_text" frees array "z".
# 2055|     if( n>350 ) n = 350;
# 2056|     sqlite3_snprintf(sizeof(z), z, "%#+.*e", n, r);
# 2057|->   sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
# 2058|   }
# 2059|
(Example-2) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the array is not freed. That is also this case.

', '2025-11-17 21:39:06.949359');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (86, 109, 'def78', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201045: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201045: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201043|       for(i=0; i<pIter->nPhrase; i++){
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201045: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201045: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1}".
#201043|       for(i=0; i<pIter->nPhrase; i++){
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201045: overflow: The expression "iEnd + 1" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201045: overflow_sink: "iEnd + 1", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd + 1)".
#201043|       for(i=0; i<pIter->nPhrase; i++){
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|->       fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|         fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
(Example-1) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:201035: cast_overflow: Truncation due to cast operation on "pPhrase->iHead" from 64 to 32 bits.
sqlite-src-3450100/sqlite3.c:201035: overflow_assign: "iEnd" is assigned from "pPhrase->iHead".
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:201042: overflow: The expression "iEnd - pIter->nSnippet + 1" is deemed underflowed because at least one of its arguments has underflowed.
sqlite-src-3450100/sqlite3.c:201042: assign: Assigning: "iStart" = "iEnd - pIter->nSnippet + 1".
sqlite-src-3450100/sqlite3.c:201046: overflow_sink: "iStart", which might have underflowed, is passed to "fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart)".
#201044|         SnippetPhrase *pPhrase = &pIter->aPhrase[i];
#201045|         fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
#201046|->       fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
#201047|       }
#201048|     }
(Example-2) Reason Marked as False Positive:
we are casting u32 to s32, but only when the u32 is less than 0x7FFFFFFF;
this will not cause overflow.

', '2025-11-17 21:39:06.949359');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (87, 109, 'def79', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:210502: cond_const: Checking "iIdx < 40" implies that "iIdx" is 41 on the false branch.
sqlite-src-3450100/sqlite3.c:210561: overrun-buffer-arg: Overrunning array "zIdxStr" of 41 bytes by passing it to a function which accesses it at byte offset 41 using argument "iIdx + 1" (which evaluates to 42). [Note: The source code implementation of the function has been overridden by a builtin model.]
#210559|         return SQLITE_NOMEM;
#210560|       }
#210561|->     memcpy(pIdxInfo->idxStr, zIdxStr, iIdx+1);
#210562|     }
#210563|', 'TRUE POSITIVE', 'Buffer overrun is implied at line 210561 when `iIdx` is 41 (as inferred from `iIdx < 40` check at line 210502), causing `memcpy` to access `zIdxStr` (size 41 bytes) at offset 42, with no explicit bounds checking to prevent this overrun.', 'The condition `iIdx < 40` at line 210502 implies that when this condition is false, `iIdx` is indeed 41 or greater.

Immediately after the false branch of the implied condition (within the same logical code block, after the `return SQLITE_NOMEM;` statement which doesn''t affect the `iIdx` value), the code executes `memcpy(pIdxInfo->idxStr, zIdxStr, iIdx+1);` at line 210561.

Here, `iIdx+1` is used as the length argument for `memcpy`, and since `iIdx` can be 41 (as per the false branch of the condition), `iIdx+1` evaluates to 42.

The array `zIdxStr` is described as having a size of 41 bytes, meaning accessing it at an offset of 41 (i.e., `iIdx+1` when `iIdx` is 41) indeed overruns the buffer by 1 byte.

The implementation of `memcpy` is overridden by a builtin model, but its standard behavior of copying `n` bytes (where `n` is the third argument, here `iIdx+1`) from source to destination is well-defined and implies the buffer overrun in this context.

No explicit bounds checking or adjustment is shown in the provided code snippet to prevent the buffer overrun when `iIdx` is 41, leading to a direct correlation between the code''s behavior and the described vulnerability (CWE-119: Buffer Overrun).', 'Verify the size of the `pIdxInfo->idxStr` buffer to assess the actual impact of the potential overrun.

Investigate if there are any implicit or explicit checks within the SQLite environment that could prevent or mitigate the buffer overrun when `iIdx` reaches 41, not immediately apparent from the provided code snippet.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';
(Example-1) Reason Marked as False Positive:
There is while that decrements the i at elast once.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:186439: buffer_alloc: Calling allocating function "sqlite3_realloc64" which allocates "nAlloc" bytes. [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:186439: var_assign: Assigning: "zNew" = "sqlite3_realloc64(zBuffer, nAlloc)".
sqlite-src-3450100/sqlite3.c:186444: alias: Assigning: "zBuffer" = "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186448: symbolic_assign: Tracking "nBuffer" since "nPrefix + nSuffix" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186423: symbolic_compare: Tracking "nPrefix" since "nBuffer" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "zCsr - zNode" since "nPrefix" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186432: symbolic_compare: Tracking "nPrefix" since "zCsr - zNode" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zNew".
sqlite-src-3450100/sqlite3.c:186436: symbolic_compare: Tracking "(i64)nPrefix + nSuffix" since "nAlloc" is tracked with "zBuffer".
sqlite-src-3450100/sqlite3.c:186447: overrun-local: Overrunning dynamic array "zBuffer" at offset corresponding to index variable "nPrefix".
#186445|       }
#186446|       assert( zBuffer );
#186447|->     memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
#186448|       nBuffer = nPrefix + nSuffix;
#186449|       zCsr += nSuffix;
(Example-2) Reason Marked as False Positive:
nBuffer is realloc -ed when nPrefix is bigger.

', '2025-11-17 21:39:06.94936');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (88, 109, 'def80', 'RETURN_LOCAL', 'sqlite-src-3450100/sqlite3_analyzer.c:81151: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3_analyzer.c:81251: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3_analyzer.c:81251: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81249|       *pzOut = 0;
#81250|     }else{
#81251|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81252|     }
#81253|     /* Make sure this analysis did not leave any unref() pages. */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:81151: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3_analyzer.c:81251: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3_analyzer.c:81251: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81249|       *pzOut = 0;
#81250|     }else{
#81251|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81252|     }
#81253|     /* Make sure this analysis did not leave any unref() pages. */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RETURN_LOCAL (CWE-562):
sqlite-src-3450100/sqlite3_analyzer.c:81151: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3_analyzer.c:81251: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3_analyzer.c:81251: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81249|       *pzOut = 0;
#81250|     }else{
#81251|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81252|     }
#81253|     /* Make sure this analysis did not leave any unref() pages. */
(Example-1) Reason Marked as False Positive:
It is returning integer

** Example-2 **
(Example-2) Known False Positive:
Error RETURN_LOCAL (CWE-562):
sqlite-src-3450100/sqlite3.c:81127: local_ptr_identity_local: "sqlite3StrAccumInit(&sCheck.errMsg, NULL, zErr, 100, 1000000000)" stores "zErr" (address of local variable "zErr") into "sCheck.errMsg.zText".
sqlite-src-3450100/sqlite3.c:81227: identity_transfer: Passing field "sCheck.errMsg.zText" (indirectly, via argument 1) to function "sqlite3StrAccumFinish", which returns it.
sqlite-src-3450100/sqlite3.c:81227: escape_local_addr_alias: Returning, through "*pzOut", pointer "sqlite3StrAccumFinish(&sCheck.errMsg)" which points to local variable "zErr".
#81225|       *pzOut = 0;
#81226|     }else{
#81227|->     *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
#81228|     }
#81229|     /* Make sure this analysis did not leave any unref() pages. */
(Example-2) Reason Marked as False Positive:
sqlite checks is the array is malloced, and if not reallocs it and returns the reallocated one.

', '2025-11-17 21:39:06.94936');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (89, 109, 'def81', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3_analyzer.c:96007: assign: Assigning: "pLast" = "&pData0[nField - 1]".
sqlite-src-3450100/sqlite3_analyzer.c:96072: assign: Assigning: "pRec" = "pLast".
sqlite-src-3450100/sqlite3_analyzer.c:96133: equal: The address of "pRec->u.r" is equal to "pData0 + (nField - 1)".
sqlite-src-3450100/sqlite3_analyzer.c:96133: equal: The address of "pRec->u.i" is equal to "pData0 + (nField - 1)".
sqlite-src-3450100/sqlite3_analyzer.c:96133: overlapping_assignment: Assigning "pRec->u.i" to "pRec->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3_analyzer.c:96133: target_type: "pRec->u.r" has type "double".
sqlite-src-3450100/sqlite3_analyzer.c:96133: source_type: "pRec->u.i" has type "long long".
#96131|             ** as an integer, then we might as well make it an 8-byte floating
#96132|             ** point value */
#96133|->           pRec->u.r = (double)pRec->u.i;
#96134|             pRec->flags &= ~MEM_IntReal;
#96135|             pRec->flags |= MEM_Real;', 'TRUE POSITIVE', 'Overlapping assignment with type mismatch occurs at line 96133 (`pRec->u.r = (double)pRec->u.i;`), where `double` and `long long` types share memory, with no mitigating checks in the provided code snippet.', 'Direct evidence of overlapping assignment with different types at line **96133**: `pRec->u.r` (type `double`) is assigned the value of `pRec->u.i` (type `long long`), which share overlapping memory locations.

Explicit type casting from `long long` to `double` at line **96133**: `pRec->u.r = (double)pRec->u.i;`, which confirms the mixing of types in the overlapping memory location.

The assignment at line **96133** is a direct match for the reported ''overlapping_assignment'' vulnerability, with no conditional statements or checks in the provided code snippet that would prevent this execution path.

The preceding assignments (lines **96007** and **96072**) establish the equivalence of `pRec`, `pLast`, and `&pData0[nField - 1]`, ensuring that the vulnerable operation (line **96133**) indeed involves overlapping memory locations.

No explicit proof within the provided code snippet suggests that this vulnerability is mitigated or prevented under all circumstances, adhering to the guideline that lack of definitive proof against the vulnerability implies a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:06.94936');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (90, 109, 'def82', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:191115: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3_analyzer.c:191151: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191149|     pCsr->iLangid = iLangVal;
#191150|   
#191151|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191152|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191153|     );', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:191091: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:191127: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191125|     pCsr->iLangid = iLangVal;
#191126|   
#191127|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191128|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191129|     );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:191091: freed_arg: "sqlite3_free" frees "pCsr->filter.zTerm". [Note: The source code implementation of the function has been overridden by a builtin model.]
sqlite-src-3450100/sqlite3.c:191127: pass_freed_arg: Passing freed pointer "pCsr->filter.zTerm" as an argument to "sqlite3Fts3SegReaderCursor".
#191125|     pCsr->iLangid = iLangVal;
#191126|   
#191127|->   rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,
#191128|         pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
#191129|     );
(Example-1) Reason Marked as False Positive:
pCsr.filter is set to NULL and nTerm is set to zero to avoid invalid access.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

', '2025-11-17 21:39:06.949361');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (91, 109, 'def83', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/sqlite3.c:31105: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3.c:31105: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3.c:31105: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3.c:31699: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:31701: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31699|       width -= length;
#31700|       if( width>0 ){
#31701|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31702|         sqlite3_str_append(pAccum, bufpt, length);
#31703|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:31105: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3.c:31105: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3.c:31105: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3.c:31699: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:31701: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31699|       width -= length;
#31700|       if( width>0 ){
#31701|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31702|         sqlite3_str_append(pAccum, bufpt, length);
#31703|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3.c:31105: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3.c:31105: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3.c:31105: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3.c:31699: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3.c:31701: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31699|       width -= length;
#31700|       if( width>0 ){
#31701|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31702|         sqlite3_str_append(pAccum, bufpt, length);
#31703|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-1) Reason Marked as False Positive:
there is check if width is bigger than 0

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/sqlite3_analyzer.c:31129: tainted_data_return: Called function "getIntArg(pArgList)", and a possible return value is known to be less than zero.
sqlite-src-3450100/sqlite3_analyzer.c:31129: cast_overflow: Truncation due to cast operation on "getIntArg(pArgList)" from 63 to 32 bits.
sqlite-src-3450100/sqlite3_analyzer.c:31129: overflow_assign: "width" is assigned from "(int)getIntArg(pArgList)".
sqlite-src-3450100/sqlite3_analyzer.c:31723: overflow: The expression "width -= length" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/sqlite3_analyzer.c:31725: overflow_sink: "width", which might have underflowed, is passed to "sqlite3_str_appendchar(pAccum, width, '' '')".
#31723|       width -= length;
#31724|       if( width>0 ){
#31725|->       if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
#31726|         sqlite3_str_append(pAccum, bufpt, length);
#31727|         if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, '' '');
(Example-2) Reason Marked as False Positive:
there is check if width is bigger than 0

', '2025-11-17 21:39:06.949361');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (92, 109, 'def84', 'OVERRUN', 'sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("\n");
#27456|       oputf("%12.12s: ", "rowseparator");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("\n");
#27456|       oputf("%12.12s: ", "rowseparator");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27454: overrun-buffer-val: Overrunning array "p->colSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27452|             strlen30(p->outfile) ? p->outfile : "stdout");
#27453|       oputf("%12.12s: ", "colseparator");
#27454|->      output_c_string(p->colSeparator);
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
(Example-1) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:27457: overrun-buffer-val: Overrunning array "p->rowSeparator" of 20 bytes by passing it to a function which accesses it at byte offset 2147483646.
#27455|        oputz("
");
#27456|       oputf("%12.12s: ", "rowseparator");
#27457|->      output_c_string(p->rowSeparator);
#27458|        oputz("
");
#27459|       switch( p->statsOn ){
(Example-2) Reason Marked as False Positive:
in anyOfInStr is check to not access it on ~(size_t)0 position.

', '2025-11-17 21:39:06.949362');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (93, 109, 'def85', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77755: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77753|       i++;
#77754|       if( i>=iEnd ) break;
#77755|->     if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|         pEnd = pCArray->apEnd[k];', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77755: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77753|       i++;
#77754|       if( i>=iEnd ) break;
#77755|->     if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|         pEnd = pCArray->apEnd[k];', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77755: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77753|       i++;
#77754|       if( i>=iEnd ) break;
#77755|->     if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|         pEnd = pCArray->apEnd[k];
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77667: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77665|       i++;
#77666|       if( i>=iEnd ) break;
#77667|->     if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|         pSrcEnd = pCArray->apEnd[k];
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949362');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (94, 109, 'def86', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:237133: freed_arg: "fts5ExprAddChildren" frees "pRight".
sqlite-src-3450100/sqlite3_analyzer.c:237150: double_free: Calling "sqlite3Fts5ParseNodeFree" frees pointer "pRight" which has already been freed.
#237148|       assert( pParse->rc!=SQLITE_OK );
#237149|       sqlite3Fts5ParseNodeFree(pLeft);
#237150|->     sqlite3Fts5ParseNodeFree(pRight);
#237151|       sqlite3Fts5ParseNearsetFree(pNear);
#237152|     }', 'TRUE POSITIVE', 'Consecutive frees of `pRight` at lines 237133 and 237150, with no intervening nullification or reassignment, confirm a double-free vulnerability, lacking explicit safeguards or evidence of a harmless second free.', 'Direct evidence of double-free vulnerability: the CVE report explicitly states that `fts5ExprAddChildren` frees `pRight` (line 237133) and subsequently `sqlite3Fts5ParseNodeFree` attempts to free `pRight` again (line 237150).

Code confirmation: the provided source code snippet shows consecutive calls to `sqlite3Fts5ParseNodeFree` for both `pLeft` (line 237149) and `pRight` (line 237150), with no intervening operations that would nullify or reassign `pRight`.

Lack of explicit safeguard: unlike Example-1, there is no conditional statement (e.g., checking a flag like `SQLITE_TRANSIENT`) that would prevent the second free operation in the provided code context.

Lack of evidence for NOOP on second free: unlike Example-2, there is no indication in the provided code that `pRight` is set to 0 after the initial free, which would render the second free operation harmless.

Single vulnerable path identified: the sequence of events at lines 237133 and 237150, confirmed by the surrounding code at lines 237148-237152, demonstrates a potential execution path leading to a double-free vulnerability.', NULL, 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-1) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed
", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }
(Example-2) Reason Marked as False Positive:
members of apWiData is set set to 0 after freeing. Second Freeing will be NOOP

', '2025-11-17 21:39:06.949362');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (95, 109, 'def87', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/shell.c:14849: cast_overflow: Truncation due to cast operation on "nPayload" from 64 to 32 bits.
sqlite-src-3450100/shell.c:14849: overflow_assign: "nLocal" is assigned from "nPayload".
sqlite-src-3450100/shell.c:14874: overflow_sink: "nLocal", which might have overflowed, is passed to "memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#14872|   
#14873|               /* Load the nLocal bytes of payload */
#14874|->             memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);
#14875|               iOff += nLocal;
#14876|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:14849: cast_overflow: Truncation due to cast operation on "nPayload" from 64 to 32 bits.
sqlite-src-3450100/shell.c:14849: overflow_assign: "nLocal" is assigned from "nPayload".
sqlite-src-3450100/shell.c:14874: overflow_sink: "nLocal", which might have overflowed, is passed to "memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal)".
#14872|   
#14873|               /* Load the nLocal bytes of payload */
#14874|->             memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);
#14875|               iOff += nLocal;
#14876|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:14849: cast_overflow: Truncation due to cast operation on "nPayload" from 64 to 32 bits.
sqlite-src-3450100/shell.c:14849: overflow_assign: "nLocal" is assigned from "nPayload".
sqlite-src-3450100/shell.c:14874: overflow_sink: "nLocal", which might have overflowed, is passed to "memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#14872|   
#14873|               /* Load the nLocal bytes of payload */
#14874|->             memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);
#14875|               iOff += nLocal;
#14876|
(Example-1) Reason Marked as False Positive:
It cannot overflow, as there is check nPayload <=X, and X is int.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10124: tainted_data_transitive: Call to function "zipfileGetU16" with tainted argument "*aRead" returns tainted data.
sqlite-src-3450100/shell.c:10124: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10125: overflow: The tainted expression "nExtra" is used in an arithmetic operation. The expression "nExtra" is considered to have possibly overflowed.
sqlite-src-3450100/shell.c:10127: overflow: The expression "96UL + nExtra" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/shell.c:10127: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10132: overflow_sink: "nAlloc", which might have underflowed, is passed to "sqlite3_malloc64(nAlloc)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#10130|       }
#10131|   
#10132|->     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
#10133|       if( pNew==0 ){
#10134|         rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

', '2025-11-17 21:39:06.949363');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (96, 109, 'def88', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77667: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77665|       i++;
#77666|       if( i>=iEnd ) break;
#77667|->     if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|         pSrcEnd = pCArray->apEnd[k];', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77667: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77665|       i++;
#77666|       if( i>=iEnd ) break;
#77667|->     if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|         pSrcEnd = pCArray->apEnd[k];', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77667: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77665|       i++;
#77666|       if( i>=iEnd ) break;
#77667|->     if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|         pSrcEnd = pCArray->apEnd[k];
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77755: overrun-local: Overrunning array "pCArray->ixNx" of 6 4-byte elements at element index 6 (byte offset 27) using index "k" (which evaluates to 6).
#77753|       i++;
#77754|       if( i>=iEnd ) break;
#77755|->     if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|         pEnd = pCArray->apEnd[k];
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949363');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (97, 109, 'def89', 'COPY_PASTE_ERROR', 'sqlite-src-3450100/sqlite3.c:170128: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3.c:170140: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3.c:170140: remediation: Should it say "regEndRowid" instead?
#170138|         csr = p->end.csr;
#170139|         reg = p->end.reg;
#170140|->       if( pMWin->regStartRowid ){
#170141|           assert( pMWin->regEndRowid );
#170142|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:170128: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3.c:170140: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3.c:170140: remediation: Should it say "regEndRowid" instead?
#         csr = p->end.csr;
#         reg = p->end.reg;
#->       if( pMWin->regStartRowid ){
#           assert( pMWin->regEndRowid );
#           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
sqlite-src-3450100/sqlite3.c:170128: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3.c:170140: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3.c:170140: remediation: Should it say "regEndRowid" instead?
#170138|         csr = p->end.csr;
#170139|         reg = p->end.reg;
#170140|->       if( pMWin->regStartRowid ){
#170141|           assert( pMWin->regEndRowid );
#170142|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
(Example-1) Reason Marked as False Positive:
there is also assert for checking in regEndRowid is not NULL. That is sufficient.

** Example-2 **
(Example-2) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
sqlite-src-3450100/sqlite3_analyzer.c:170152: original: "pMWin->regStartRowid" looks like the original copy.
sqlite-src-3450100/sqlite3_analyzer.c:170164: copy_paste_error: "regStartRowid" in "pMWin->regStartRowid" looks like a copy-paste error.
sqlite-src-3450100/sqlite3_analyzer.c:170164: remediation: Should it say "regEndRowid" instead?
#170162|         csr = p->end.csr;
#170163|         reg = p->end.reg;
#170164|->       if( pMWin->regStartRowid ){
#170165|           assert( pMWin->regEndRowid );
#170166|           sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
(Example-2) Reason Marked as False Positive:
there is also assert for checking in regEndRowid is not NULL. That is sufficient.

', '2025-11-17 21:39:06.949363');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (98, 109, 'def90', 'INTEGER_OVERFLOW', 'sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10124: tainted_data_transitive: Call to function "zipfileGetU16" with tainted argument "*aRead" returns tainted data.
sqlite-src-3450100/shell.c:10124: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10125: overflow: The tainted expression "nExtra" is used in an arithmetic operation. The expression "nExtra" is considered to have possibly overflowed.
sqlite-src-3450100/shell.c:10127: overflow: The expression "96UL + nExtra" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/shell.c:10127: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10132: overflow_sink: "nAlloc", which might have underflowed, is passed to "sqlite3_malloc64(nAlloc)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#10130|       }
#10131|   
#10132|->     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
#10133|       if( pNew==0 ){
#10134|         rc = SQLITE_NOMEM;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10124: tainted_data_transitive: Call to function "zipfileGetU16" with tainted argument "*aRead" returns tainted data.
sqlite-src-3450100/shell.c:10124: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10125: overflow: The tainted expression "nExtra" is used in an arithmetic operation. The expression "nExtra" is considered to have possibly overflowed.
sqlite-src-3450100/shell.c:10127: overflow: The expression "96UL + nExtra" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/shell.c:10127: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10132: overflow_sink: "nAlloc", which might have underflowed, is passed to "sqlite3_malloc64(nAlloc)".
#10130|       }
#10131|   
#10132|->     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
#10133|       if( pNew==0 ){
#10134|         rc = SQLITE_NOMEM;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10124: tainted_data_transitive: Call to function "zipfileGetU16" with tainted argument "*aRead" returns tainted data.
sqlite-src-3450100/shell.c:10124: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10125: overflow: The tainted expression "nExtra" is used in an arithmetic operation. The expression "nExtra" is considered to have possibly overflowed.
sqlite-src-3450100/shell.c:10127: overflow: The expression "96UL + nExtra" is deemed overflowed because at least one of its arguments has overflowed.
sqlite-src-3450100/shell.c:10127: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
sqlite-src-3450100/shell.c:10132: overflow_sink: "nAlloc", which might have underflowed, is passed to "sqlite3_malloc64(nAlloc)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#10130|       }
#10131|   
#10132|->     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
#10133|       if( pNew==0 ){
#10134|         rc = SQLITE_NOMEM;
(Example-1) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sqlite-src-3450100/shell.c:10114: tainted_data_argument: The value "*aRead" is considered tainted.
sqlite-src-3450100/shell.c:10137: tainted_data_transitive: Call to function "zipfileReadCDS" with tainted argument "*aRead" transitively taints "pNew->cds.iOffset".
sqlite-src-3450100/shell.c:10179: underflow: The cast of "pNew->cds.iOffset" to a signed type could result in a negative number.
#10177|           }
#10178|         }else{
#10179|->         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
#10180|               (int)pNew->cds.iOffset
#10181|           );
(Example-2) Reason Marked as False Positive:
assigning u16 to i32 does not cause overflow.

', '2025-11-17 21:39:06.949363');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (100, 109, 'def92', 'OVERRUN', 'sqlite-src-3450100/shell.c:12217: strlen_assign: Setting variable "n" to the return value of strlen called with argument "zIn".
sqlite-src-3450100/shell.c:12218: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#12216|   static char *expertDequote(const char *zIn){
#12217|     int n = STRLEN(zIn);
#12218|->   char *zRet = sqlite3_malloc(n);
#12219|   
#12220|     assert( zIn[0]==''\'''' );', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:?????: strlen_assign: Setting variable "n" to the return value of strlen called with argument "zIn".
sqlite-src-3450100/shell.c:?????: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#?????|   static char *expertDequote(const char *zIn){
#?????|     int n = STRLEN(zIn);
#?????|->   char *zRet = sqlite3_malloc(n);
#?????|   
#?????|     assert( zIn[0]==''\'''' );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/shell.c:12217: strlen_assign: Setting variable "n" to the return value of strlen called with argument "zIn".
sqlite-src-3450100/shell.c:12218: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#12216|   static char *expertDequote(const char *zIn){
#12217|     int n = STRLEN(zIn);
#12218|->   char *zRet = sqlite3_malloc(n);
#12219|   
#12220|     assert( zIn[0]==''\'''' );
(Example-1) Reason Marked as False Positive:
the result string in smaller by 2 chars, because quotes are removed. The memory is sufficient.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3_analyzer.c:35667: assignment: Assigning: "i" = "23".
sqlite-src-3450100/sqlite3_analyzer.c:35677: overrun-local: Overrunning array "p->zBuf" of 24 bytes at byte offset 24 using index "i + 1" (which evaluates to 24).
#35675|     if( iRound<0 ){
#35676|       iRound = p->iDP - iRound;
#35677|->     if( iRound==0 && p->zBuf[i+1]>=''5'' ){
#35678|         iRound = 1;
#35679|         p->zBuf[i--] = ''0'';
(Example-2) Reason Marked as False Positive:
There is while that decrements the i at elast once.

', '2025-11-17 21:39:06.949364');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (101, 109, 'def93', 'UNINIT', 'sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204875: uninit_use: Using uninitialized value "opcode".
#204873|              || c==''n'' || c==''r'' || c==''t''
#204874|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204875|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204876|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''\n''
#204877|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c: uninit_use: Using uninitialized value "opcode".
|              || c==''n'' || c==''r'' || c==''t''
|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
|           }else if( c==''\'' || c==''0'' || c==''v'' || c==''\n''
|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204875: uninit_use: Using uninitialized value "opcode".
#204873|              || c==''n'' || c==''r'' || c==''t''
#204874|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204875|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204876|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''
''
#204877|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]
(Example-1) Reason Marked as False Positive:
opcode is intilialized before jumping to the parse_string section.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204899: uninit_use: Using uninitialized value "opcode".
#204897|              || c==''n'' || c==''r'' || c==''t''
#204898|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204899|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204900|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''
''
#204901|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]
(Example-2) Reason Marked as False Positive:
opcode is set ahead of jumping to parse_string flag.

', '2025-11-17 21:39:06.949364');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (102, 109, 'def94', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:82554: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3.c:82558: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3.c:82559: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82557|       }else{
#82558|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82559|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82560|         pMem->z = pMem->zMalloc;
#82561|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:82578: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3_analyzer.c:82582: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3_analyzer.c:82583: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82581|       }else{
#82582|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82583|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82584|         pMem->z = pMem->zMalloc;
#82585|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:82578: alias: Equality between "pMem->z" and "pMem->zMalloc" implies that they are aliases.
sqlite-src-3450100/sqlite3_analyzer.c:82582: freed_arg: "sqlite3Realloc" frees "pMem->z".
sqlite-src-3450100/sqlite3_analyzer.c:82583: double_free: Calling "sqlite3_free" frees pointer "pMem->z" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#82581|       }else{
#82582|         pMem->zMalloc = sqlite3Realloc(pMem->z, n);
#82583|->       if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
#82584|         pMem->z = pMem->zMalloc;
#82585|       }
(Example-1) Reason Marked as False Positive:
pMem->z is freed only when something during realloc goes wrong, which is valid.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/shell.c:11204: freed_arg: "sqlite3_result_text" frees "zRes".
sqlite-src-3450100/shell.c:11205: double_free: Calling "sqlite3_free" frees pointer "zRes" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#11203|       }else{
#11204|         sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
#11205|->       sqlite3_free(zRes);
#11206|       }
#11207|     }
(Example-2) Reason Marked as False Positive:
sqlite3_result_text does not free zRes, when SQLITE_TRANSIENT is set.

', '2025-11-17 21:39:06.949365');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (103, 109, 'def95', 'BAD_FREE', 'sqlite-src-3450100/sqlite3.c:150465: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150478: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150485: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150463|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150464|     if( (rc&0xff)==SQLITE_ABORT ){
#150465|->     sqlite3_free_table(&res.azResult[1]);
#150466|       if( res.zErrMsg ){
#150467|         if( pzErrMsg ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#     if( (rc&0xff)==SQLITE_ABORT ){
#->     sqlite3_free_table(&res.azResult[1]);
#       if( res.zErrMsg ){
#         if( pzErrMsg ){', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3.c:150465: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150478: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150485: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150463|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150464|     if( (rc&0xff)==SQLITE_ABORT ){
#150465|->     sqlite3_free_table(&res.azResult[1]);
#150466|       if( res.zErrMsg ){
#150467|         if( pzErrMsg ){
(Example-1) Reason Marked as False Positive:
res.azResult is preoperly allocated by malloc in line n.140 (src/table.c)

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3_analyzer.c:150489: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150502: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3_analyzer.c:150509: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150487|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150488|     if( (rc&0xff)==SQLITE_ABORT ){
#150489|->     sqlite3_free_table(&res.azResult[1]);
#150490|       if( res.zErrMsg ){
#150491|         if( pzErrMsg ){
(Example-2) Reason Marked as False Positive:
res.azResult is preoperly allocated by malloc in line n.140 (src/table.c)

', '2025-11-17 21:39:06.949365');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (153, 113, 'def8', 'OVERRUN', 'unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;
(Example-1) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1628: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1626|     if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|->   c[i] += y;
# 1629|   
# 1630|
(Example-2) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

', '2025-11-17 21:39:07.010115');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (104, 109, 'def96', 'OVERRUN', 'sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77669: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77667|       if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|->       pSrcEnd = pCArray->apEnd[k];
#77670|       }
#77671|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77669: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77667|       if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|->       pSrcEnd = pCArray->apEnd[k];
#77670|       }
#77671|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77642: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77668: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77669: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77667|       if( pCArray->ixNx[k]<=i ){
#77668|         k++;
#77669|->       pSrcEnd = pCArray->apEnd[k];
#77670|       }
#77671|     }
(Example-1) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
sqlite-src-3450100/sqlite3.c:77725: cond_at_most: Checking "k < 6" implies that "k" may be up to 5 on the true branch.
sqlite-src-3450100/sqlite3.c:77756: incr: Incrementing "k". The value of "k" may now be up to 6.
sqlite-src-3450100/sqlite3.c:77757: overrun-local: Overrunning array "pCArray->apEnd" of 6 8-byte elements at element index 6 (byte offset 55) using index "k" (which evaluates to 6).
#77755|       if( pCArray->ixNx[k]<=i ){
#77756|         k++;
#77757|->       pEnd = pCArray->apEnd[k];
#77758|       }
#77759|     }
(Example-2) Reason Marked as False Positive:
As per upstream this is not a bug:
https://sqlite.org/forum/forumpost/d0e144c233c7b286
Upstream also added some asserts to future releases so that static analysers are not confused.
In my opinion these asserts do not need to be backported.

', '2025-11-17 21:39:06.949366');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (105, 109, 'def97', 'OVERLAPPING_COPY', 'sqlite-src-3450100/sqlite3.c:95983: assign: Assigning: "pLast" = "&pData0[nField - 1]".
sqlite-src-3450100/sqlite3.c:96048: assign: Assigning: "pRec" = "pLast".
sqlite-src-3450100/sqlite3.c:96109: equal: The address of "pRec->u.r" is equal to "pData0 + (nField - 1)".
sqlite-src-3450100/sqlite3.c:96109: equal: The address of "pRec->u.i" is equal to "pData0 + (nField - 1)".
sqlite-src-3450100/sqlite3.c:96109: overlapping_assignment: Assigning "pRec->u.i" to "pRec->u.r", which have overlapping memory locations and different types.
sqlite-src-3450100/sqlite3.c:96109: target_type: "pRec->u.r" has type "double".
sqlite-src-3450100/sqlite3.c:96109: source_type: "pRec->u.i" has type "long long".
#96107|             ** as an integer, then we might as well make it an 8-byte floating
#96108|             ** point value */
#96109|->           pRec->u.r = (double)pRec->u.i;
#96110|             pRec->flags &= ~MEM_IntReal;
#96111|             pRec->flags |= MEM_Real;', 'TRUE POSITIVE', 'Overlapping assignment with type mismatch occurs at `sqlite-src-3450100/sqlite3.c:96109`, where `long long` `pRec->u.i` is cast to `double` `pRec->u.r` in overlapping memory locations (`pData0 + (nField - 1)`), with no explicit mitigation in the provided code.', 'Direct evidence of overlapping assignment with different types at `sqlite-src-3450100/sqlite3.c:96109`: Assigning `pRec->u.i` (type `long long`) to `pRec->u.r` (type `double`), where both share overlapping memory locations.

Explicit type casting from `long long` to `double` at `sqlite-src-3450100/sqlite3.c:96109`: `pRec->u.r = (double)pRec->u.i;`, which confirms the intentional overlap but also introduces a potential vulnerability due to the type mismatch.

The address of both `pRec->u.r` and `pRec->u.i` is confirmed to be equal to `pData0 + (nField - 1)` at `sqlite-src-3450100/sqlite3.c:96109`, demonstrating the memory overlap.

No explicit proof within the provided code that mitigates or prevents the vulnerability described in the CVE (overlapping assignment with different types) is present, adhering to the guideline that lack of definitive proof against the vulnerability leans towards TRUE POSITIVE.

The code''s behavior directly correlates with the vulnerability described in the CVE, focusing solely on the provided information without assuming broader system or environment implications.', 'Evaluate the exploitability of the identified issue by assessing the conditions under which the type casting could lead to security-relevant errors or unexpected behavior.

Analyze the usage of `pRec` and its fields within the broader SQLite codebase to determine if there are constraints or mitigations that reduce the severity of the potential vulnerability.

Investigate input validation and sanitization mechanisms that may be in place before the critical assignment and casting operations to understand the likelihood of malicious input reaching this code path.', 0.0000, '*** Source Code Context ***

code of /shared-data/source/sqlite-src-3450100/src/sqliteInt.h file:
5196| int sqlite3VListNameToNum(VList*,const char*,int);
5197| 
5198| /*
5199| ** Routines to read and write variable-length integers.  These used to
5200| ** be defined locally, but now we use the varint routines in the util.c
5201| ** file.
5202| */
5203| int sqlite3PutVarint(unsigned char*, u64);
5204| u8 sqlite3GetVarint(const unsigned char *, u64 *);
5205| u8 sqlite3GetVarint32(const unsigned char *, u32 *);
5206| int sqlite3VarintLen(u64 v);
5207| 
5208| /*
5209| ** The common case is for a varint to be a single byte.  They following
5210| ** macros handle the common case without a procedure call, but then call
5211| ** the procedure for larger varints.
5212| */
5213| #define getVarint32(A,B)  \
5214|   (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))
5215| #define getVarint32NR(A,B) \
5216|   B=(u32)*(A);if(B>=0x80)sqlite3GetVarint32((A),(u32*)&(B))
5217| #define putVarint32(A,B)  \
5218|   (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\
5219|   sqlite3PutVarint((A),(B)))
5220| #define getVarint    sqlite3GetVarint
5221| #define putVarint    sqlite3PutVarint
5222| 
5223| 
5224| const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
5225| char *sqlite3TableAffinityStr(sqlite3*,const Table*);
5226| void sqlite3TableAffinity(Vdbe*, Table*, int);
5227| char sqlite3CompareAffinity(const Expr *pExpr, char aff2);
5228| int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity);
5229| char sqlite3TableColumnAffinity(const Table*,int);
5230| char sqlite3ExprAffinity(const Expr *pExpr);
5231| int sqlite3ExprDataType(const Expr *pExpr);
5232| int sqlite3Atoi64(const char*, i64*, int, u8);
5233| int sqlite3DecOrHexToI64(const char*, i64*);
5234| void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);
5235| void sqlite3Error(sqlite3*,int);
5236| void sqlite3ErrorClear(sqlite3*);
5237| void sqlite3SystemError(sqlite3*,int);
5238| void *sqlite3HexToBlob(sqlite3*, const char *z, int n);
5239| u8 sqlite3HexToInt(int h);
5240| int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);
5241| 
5242| #if defined(SQLITE_NEED_ERR_NAME)
5243| const char *sqlite3ErrName(int);
5244| #endif
5245| 
5246| #ifndef SQLITE_OMIT_DESERIALIZE
5247| int sqlite3MemdbInit(void);
5248| int sqlite3IsMemdb(const sqlite3_vfs*);
5249| #else
5250| # define sqlite3IsMemdb(X) 0
5251| #endif
5252| 
5253| const char *sqlite3ErrStr(int);
5254| int sqlite3ReadSchema(Parse *pParse);
5255| CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
5256| int sqlite3IsBinary(const CollSeq*);
5257| CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
5258| void sqlite3SetTextEncoding(sqlite3 *db, u8);
5259| CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr);
5260| CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr);
5261| int sqlite3ExprCollSeqMatch(Parse*,const Expr*,const Expr*);
5262| Expr *sqlite3ExprAddCollateToken(const Parse *pParse, Expr*, const Token*, int);
5263| Expr *sqlite3ExprAddCollateString(const Parse*,Expr*,const char*);
5264| Expr *sqlite3ExprSkipCollate(Expr*);
5265| Expr *sqlite3ExprSkipCollateAndLikely(Expr*);
5266| int sqlite3CheckCollSeq(Parse *, CollSeq *);
5267| int sqlite3WritableSchema(sqlite3*);
5268| int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);
5269| void sqlite3VdbeSetChanges(sqlite3 *, i64);
5270| int sqlite3AddInt64(i64*,i64);
5271| int sqlite3SubInt64(i64*,i64);
5272| int sqlite3MulInt64(i64*,i64);
5273| int sqlite3AbsInt32(int);
5274| #ifdef SQLITE_ENABLE_8_3_NAMES
5275| void sqlite3FileSuffix3(const char*, char*);
5276| #else
5277| # define sqlite3FileSuffix3(X,Y)
5278| #endif
5279| u8 sqlite3GetBoolean(const char *z,u8);
5280| 
5281| const void *sqlite3ValueText(sqlite3_value*, u8);
5282| int sqlite3ValueIsOfClass(const sqlite3_value*, void(*)(void*));
5283| int sqlite3ValueBytes(sqlite3_value*, u8);
5284| void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
5285|                         void(*)(void*));
5286| void sqlite3ValueSetNull(sqlite3_value*);
5287| void sqlite3ValueFree(sqlite3_value*);
5288| #ifndef SQLITE_UNTESTABLE
5289| void sqlite3ResultIntReal(sqlite3_context*);
5290| #endif
5291| sqlite3_value *sqlite3ValueNew(sqlite3 *);
5292| #ifndef SQLITE_OMIT_UTF16
5293| char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);
5294| #endif
5295| int sqlite3ValueFromExpr(sqlite3 *, const Expr *, u8, u8, sqlite3_value **);
5296| void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
5297| #ifndef SQLITE_AMALGAMATION
5298| extern const unsigned char sqlite3OpcodeProperty[];
5299| extern const char sqlite3StrBINARY[];
5300| extern const unsigned char sqlite3StdTypeLen[];
5301| extern const char sqlite3StdTypeAffinity[];
5302| extern const char *sqlite3StdType[];
5303| extern const unsigned char sqlite3UpperToLower[];
5304| extern const unsigned char *sqlite3aLTb;
5305| extern const unsigned char *sqlite3aEQb;
5306| extern const unsigned char *sqlite3aGTb;
5307| extern const unsigned char sqlite3CtypeMap[];
5308| extern SQLITE_WSD struct Sqlite3Config sqlite3Config;
5309| extern FuncDefHash sqlite3BuiltinFunctions;
5310| #ifndef SQLITE_OMIT_WSD
5311| extern int sqlite3PendingByte;
5312| #endif
5313| #endif /* SQLITE_AMALGAMATION */
5314| #ifdef VDBE_PROFILE
5315| extern sqlite3_uint64 sqlite3NProfileCnt;
5316| #endif
5317| void sqlite3RootPageMoved(sqlite3*, int, Pgno, Pgno);
5318| void sqlite3Reindex(Parse*, Token*, Token*);
5319| void sqlite3AlterFunctions(void);
5320| void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);
5321| void sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*);
5322| int sqlite3GetToken(const unsigned char *, int *);
5323| void sqlite3NestedParse(Parse*, const char*, ...);
5324| void sqlite3ExpirePreparedStatements(sqlite3*, int);
5325| void sqlite3CodeRhsOfIN(Parse*, Expr*, int);
5326| int sqlite3CodeSubselect(Parse*, Expr*);
5327| void sqlite3SelectPrep(Parse*, Select*, NameContext*);
5328| int sqlite3ExpandSubquery(Parse*, SrcItem*);
5329| void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);
5330| int sqlite3MatchEName(
5331|   const struct ExprList_item*,
5332|   const char*,
5333|   const char*,
5334|   const char*,
5335|   int*
5336| );
5337| Bitmask sqlite3ExprColUsed(Expr*);
5338| u8 sqlite3StrIHash(const char*);
5339| int sqlite3ResolveExprNames(NameContext*, Expr*);
5340| int sqlite3ResolveExprListNames(NameContext*, ExprList*);
5341| void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
5342| int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);
5343| int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
5344| void sqlite3ColumnDefault(Vdbe *, Table *, int, int);
5345| void sqlite3AlterFinishAddColumn(Parse *, Token *);
5346| void sqlite3AlterBeginAddColumn(Parse *, SrcList *);
5347| void sqlite3AlterDropColumn(Parse*, SrcList*, const Token*);
5348| const void *sqlite3RenameTokenMap(Parse*, const void*, const Token*);
5349| void sqlite3RenameTokenRemap(Parse*, const void *pTo, const void *pFrom);
5350| void sqlite3RenameExprUnmap(Parse*, Expr*);
5351| void sqlite3RenameExprlistUnmap(Parse*, ExprList*);
5352| CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
5353| char sqlite3AffinityType(const char*, Column*);
5354| void sqlite3Analyze(Parse*, Token*, Token*);
5355| int sqlite3InvokeBusyHandler(BusyHandler*);
5356| int sqlite3FindDb(sqlite3*, Token*);
5357| int sqlite3FindDbName(sqlite3 *, const char *);
5358| int sqlite3AnalysisLoad(sqlite3*,int iDB);
5359| void sqlite3DeleteIndexSamples(sqlite3*,Index*);
5360| void sqlite3DefaultRowEst(Index*);
5361| void sqlite3RegisterLikeFunctions(sqlite3*, int);
5362| int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);
5363| void sqlite3SchemaClear(void *);
5364| Schema *sqlite3SchemaGet(sqlite3 *, Btree *);
5365| int sqlite3SchemaToIndex(sqlite3 *db, Schema *);
5366| KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);
5367| void sqlite3KeyInfoUnref(KeyInfo*);
5368| KeyInfo *sqlite3KeyInfoRef(KeyInfo*);
5369| KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);
5370| KeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);
5371| const char *sqlite3SelectOpName(int);
5372| int sqlite3HasExplicitNulls(Parse*, ExprList*);
5373| 
5374| #ifdef SQLITE_DEBUG
5375| int sqlite3KeyInfoIsWriteable(KeyInfo*);
5376| #endif
5377| int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
5378|   void (*)(sqlite3_context*,int,sqlite3_value **),
5379|   void (*)(sqlite3_context*,int,sqlite3_value **),
5380|   void (*)(sqlite3_context*),
5381|   void (*)(sqlite3_context*),
5382|   void (*)(sqlite3_context*,int,sqlite3_value **),
5383|   FuncDestructor *pDestructor
5384| );
5385| void sqlite3NoopDestructor(void*);
5386| void *sqlite3OomFault(sqlite3*);
5387| void sqlite3OomClear(sqlite3*);
5388| int sqlite3ApiExit(sqlite3 *db, int);
5389| int sqlite3OpenTempDatabase(Parse *);
5390| 
5391| char *sqlite3RCStrRef(char*);
5392| void sqlite3RCStrUnref(void*);
5393| char *sqlite3RCStrNew(u64);
5394| char *sqlite3RCStrResize(char*,u64);
5395| 
5396| void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);
code of /shared-data/source/sqlite-src-3450100/src/malloc.c file:
159| int sqlite3MallocInit(void){
160|   int rc;
161|   if( sqlite3GlobalConfig.m.xMalloc==0 ){
162|     sqlite3MemSetDefault();
163|   }
164|   mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
165|   if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512
166|       || sqlite3GlobalConfig.nPage<=0 ){
167|     sqlite3GlobalConfig.pPage = 0;
168|     sqlite3GlobalConfig.szPage = 0;
169|   }
170|   rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
171|   if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
172|   return rc;
173| }

*** Examples ***
', '2025-11-17 21:39:06.949366');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (106, 109, 'def98', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed\n", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed\n", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:67037: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3_analyzer.c:67070: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67068|       }
#67069|       WALTRACE(("WAL%p: closed
", pWal));
#67070|->     sqlite3_free((void *)pWal->apWiData);
#67071|       sqlite3_free(pWal);
#67072|     }
(Example-1) Reason Marked as False Positive:
members of apWiData is set set to 0 after freeing. Second Freeing will be NOOP

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:67013: freed_arg: "sqlite3WalCheckpoint" frees "pWal->apWiData".
sqlite-src-3450100/sqlite3.c:67046: double_free: Calling "sqlite3_free" frees pointer "pWal->apWiData" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#67044|       }
#67045|       WALTRACE(("WAL%p: closed
", pWal));
#67046|->     sqlite3_free((void *)pWal->apWiData);
#67047|       sqlite3_free(pWal);
#67048|     }
(Example-2) Reason Marked as False Positive:
Its calling realloc, not free.

', '2025-11-17 21:39:06.949366');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (107, 109, 'def99', 'BAD_FREE', 'sqlite-src-3450100/shell.c:7841: address_free: "sqlite3_result_text" frees address of "pCur->zPath[pCur->nBase]".
# 7839|     switch( i ){
# 7840|       case FSDIR_COLUMN_NAME: {
# 7841|->       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
# 7842|         break;
# 7843|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/shell.c:7841: address_free: "sqlite3_result_text" frees address of "pCur->zPath[pCur->nBase]".
# 7839|     switch( i ){
# 7840|       case FSDIR_COLUMN_NAME: {
# 7841|->       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
# 7842|         break;
# 7843|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/shell.c:7841: address_free: "sqlite3_result_text" frees address of "pCur->zPath[pCur->nBase]".
# 7839|     switch( i ){
# 7840|       case FSDIR_COLUMN_NAME: {
# 7841|->       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
# 7842|         break;
# 7843|       }
(Example-1) Reason Marked as False Positive:
when the SQLITE_TRANSIENT flag is set, the  array is not freed.
That is also this case.

** Example-2 **
(Example-2) Known False Positive:
Error BAD_FREE (CWE-590):
sqlite-src-3450100/sqlite3.c:150465: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150478: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
sqlite-src-3450100/sqlite3.c:150485: address_free: "sqlite3_free_table" frees address of "res.azResult[1]".
#150463|     res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);
#150464|     if( (rc&0xff)==SQLITE_ABORT ){
#150465|->     sqlite3_free_table(&res.azResult[1]);
#150466|       if( res.zErrMsg ){
#150467|         if( pzErrMsg ){
(Example-2) Reason Marked as False Positive:
res.azResult is preoperly allocated by malloc in line n.140 (src/table.c)

', '2025-11-17 21:39:06.949366');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (108, 109, 'def100', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: double_free: Calling "sqlite3DbFree" frees pointer "zOut" which has already been freed.
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-1) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:116587: assign: Assigning: "zBuf1" = "&zOut[nSql * 2LL + 1LL]".
sqlite-src-3450100/sqlite3.c:116588: assign: Assigning: "zBuf2" = "&zOut[nSql * 4LL + 2LL]".
sqlite-src-3450100/sqlite3.c:116627: assign: Assigning: "zReplace" = "zBuf2".
sqlite-src-3450100/sqlite3.c:116643: freed_arg: "sqlite3_result_text" frees "zOut".
sqlite-src-3450100/sqlite3.c:116644: pass_freed_arg: Passing freed pointer "zOut" as an argument to "sqlite3DbFree".
#116642|   
#116643|       sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
#116644|->     sqlite3DbFree(db, zOut);
#116645|     }else{
#116646|       rc = SQLITE_NOMEM;
(Example-2) Reason Marked as False Positive:
memory is not freed when xDel is set to SQLITE_TRANSIENT, which it is.

', '2025-11-17 21:39:06.949367');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (109, 109, 'def101', 'UNINIT', 'sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204899: uninit_use: Using uninitialized value "opcode".
#204897|              || c==''n'' || c==''r'' || c==''t''
#204898|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204899|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204900|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''\n''
#204901|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c: uninit_use: Using uninitialized value "opcode".
#              || c==''n'' || c==''r'' || c==''t''
#              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#           }else if( c==''\'' || c==''0'' || c==''v'' || c==''\n''
#              || (0xe2==(u8)c && 0x80==(u8)z[j+1]', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204869: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3_analyzer.c:204899: uninit_use: Using uninitialized value "opcode".
#204897|              || c==''n'' || c==''r'' || c==''t''
#204898|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204899|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204900|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''
''
#204901|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]
(Example-1) Reason Marked as False Positive:
opcode is set ahead of jumping to parse_string flag.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204845: skipped_decl: Jumping over declaration of "opcode".
sqlite-src-3450100/sqlite3.c:204875: uninit_use: Using uninitialized value "opcode".
#204873|              || c==''n'' || c==''r'' || c==''t''
#204874|              || (c==''u'' && jsonIs4Hex(&z[j+1])) ){
#204875|->           if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;
#204876|           }else if( c==''\'''' || c==''0'' || c==''v'' || c==''
''
#204877|              || (0xe2==(u8)c && 0x80==(u8)z[j+1]
(Example-2) Reason Marked as False Positive:
opcode is intilialized before jumping to the parse_string section.

', '2025-11-17 21:39:06.949367');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (110, 109, 'def102', 'UNINIT', 'sqlite-src-3450100/sqlite3_analyzer.c:204943: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3_analyzer.c:205048: uninit_use: Using uninitialized value "seenE".
#205046|             }
#205047|           }
#205048|->         if( seenE ){
#205049|             pParse->iErr = j;
#205050|             return -1;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3_analyzer.c: uninit_use: Using uninitialized value "seenE".
#             }
#           }
#->         if( seenE ){
#             pParse->iErr = j;
#             return -1;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3_analyzer.c:204943: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3_analyzer.c:205048: uninit_use: Using uninitialized value "seenE".
#205046|             }
#205047|           }
#205048|->         if( seenE ){
#205049|             pParse->iErr = j;
#205050|             return -1;
(Example-1) Reason Marked as False Positive:
seenE is set ahead every jump to parse_number_2

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
sqlite-src-3450100/sqlite3.c:204919: skipped_decl: Jumping over declaration of "seenE".
sqlite-src-3450100/sqlite3.c:205024: uninit_use: Using uninitialized value "seenE".
#205022|             }
#205023|           }
#205024|->         if( seenE ){
#205025|             pParse->iErr = j;
#205026|             return -1;
(Example-2) Reason Marked as False Positive:
seenE is set before entering the goto section.

', '2025-11-17 21:39:06.949367');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (111, 109, 'def103', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK ){', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK );', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3.c:232763: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3.c:232765: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232763|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232764|       }
#232765|->     sqlite3_free(ctx.zOut);
#232766|     }
#232767|     if( rc!=SQLITE_OK ){
(Example-1) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:232787: freed_arg: "sqlite3_result_text" frees "ctx.zOut".
sqlite-src-3450100/sqlite3_analyzer.c:232789: double_free: Calling "sqlite3_free" frees pointer "ctx.zOut" which has already been freed. [Note: The source code implementation of the function has been overridden by a builtin model.]
#232787|         sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
#232788|       }
#232789|->     sqlite3_free(ctx.zOut);
#232790|     }
#232791|     if( rc!=SQLITE_OK ){
(Example-2) Reason Marked as False Positive:
Setting SQLITE_TRANSIENT ensures the memory is not freed.

', '2025-11-17 21:39:06.949368');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (112, 109, 'def104', 'USE_AFTER_FREE', 'sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: double_free: Calling "sqlite3DbFree" frees pointer "p->zErrMsg" which has already been freed.
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-1) Reason Marked as False Positive:
If SQLITE_TRANSIENT set no freeing takes place.
This is the case.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
sqlite-src-3450100/sqlite3_analyzer.c:87915: freed_arg: "sqlite3VdbeTransferError" frees "p->zErrMsg".
sqlite-src-3450100/sqlite3_analyzer.c:87932: pass_freed_arg: Passing freed pointer "p->zErrMsg" as an argument to "sqlite3DbFree".
#87930|   #endif
#87931|     if( p->zErrMsg ){
#87932|->     sqlite3DbFree(db, p->zErrMsg);
#87933|       p->zErrMsg = 0;
#87934|     }
(Example-2) Reason Marked as False Positive:
destructor function is set to SQLITE_TRANSIENT.
That means freeing does not take place in sqlite3VdbeTransferError in this case.

', '2025-11-17 21:39:06.949368');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (113, 96, 'def1', 'UNINIT', 'libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:222:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  220|   
#  221|   		case BPF_LD|BPF_MEM:
#  222|-> 			A = mem[pc->k];
#  223|   			continue;
#  224|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:222:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  220|   
#  221|   (case BPF_LD|BPF_MEM:
#  222|->          A = mem[pc->k];
#  223|            continue;
#  224|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:222:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  220|   
#  221|   		case BPF_LD|BPF_MEM:
#  222|-> 			A = mem[pc->k];
#  223|   			continue;
#  224|
(Example-1) Reason Marked as False Positive:
I tried to ask about this in the Upstream because I myself am unable to deduce this. The answer is that only if an invalid BPF program that does a load from a memory location without storing something there first is used as a filter. But loading an invalid bpf program should not be possible, that would end with an error. This is a key component of libpcap and it would have presented itself long time ago should this be a problem.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:226:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  224|   
#  225|   		case BPF_LDX|BPF_MEM:
#  226|-> 			X = mem[pc->k];
#  227|   			continue;
#  228|
(Example-2) Reason Marked as False Positive:
I tried to ask about this in the Upstream because I myself am unable to deduce this. The answer is that only if an invalid BPF program that does a load from a memory location without storing something there first is used as a filter. But loading an invalid bpf program should not be possible, that would end with an error. This is a key component of libpcap and it would have presented itself long time ago should this be a problem.

', '2025-11-17 21:39:06.975576');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (114, 96, 'def2', 'INTEGER_OVERFLOW', 'libpcap-1.10.4/sf-pcap.c:682:4: underflow: The decrement operator on the unsigned variable "new_bufsize" might result in an underflow.
libpcap-1.10.4/sf-pcap.c:683:4: overflow: The expression "new_bufsize |= new_bufsize >> 1" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:684:4: overflow: The expression "new_bufsize |= new_bufsize >> 2" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:685:4: overflow: The expression "new_bufsize |= new_bufsize >> 4" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:686:4: overflow: The expression "new_bufsize |= new_bufsize >> 8" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:687:4: overflow: The expression "new_bufsize |= new_bufsize >> 16" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:693:4: overflow_sink: "new_bufsize", which might have underflowed, is passed to "grow_buffer(p, new_bufsize)".
#  691|   				new_bufsize = p->snapshot;
#  692|   
#  693|-> 			if (!grow_buffer(p, new_bufsize))
#  694|   				return (-1);
#  695|   		}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpcap-1.10.4/sf-pcap.c:682:4: underflow: The decrement operator on the unsigned variable "new_bufsize" might result in an underflow.
libpcap-1.10.4/sf-pcap.c:683:4: overflow: The expression "new_bufsize |= new_bufsize >> 1" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:684:4: overflow: The expression "new_bufsize |= new_bufsize >> 2" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:685:4: overflow: The expression "new_bufsize |= new_bufsize >> 4" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:686:4: overflow: The expression "new_bufsize |= new_bufsize >> 8" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:687:4: overflow: The expression "new_bufsize |= new_bufsize >> 16" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:693:4: overflow_sink: "new_bufsize", which might have underflowed, is passed to "grow_buffer(p, new_bufsize)".
#  691|    newcom_bufsize = p->snapshot;
#  692|   
#  693|->  if (!grow_buffer(p, new_bufsize))
#  694|    return (-1);
#  695| }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpcap-1.10.4/sf-pcap.c:682:4: underflow: The decrement operator on the unsigned variable "new_bufsize" might result in an underflow.
libpcap-1.10.4/sf-pcap.c:683:4: overflow: The expression "new_bufsize |= new_bufsize >> 1" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:684:4: overflow: The expression "new_bufsize |= new_bufsize >> 2" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:685:4: overflow: The expression "new_bufsize |= new_bufsize >> 4" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:686:4: overflow: The expression "new_bufsize |= new_bufsize >> 8" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:687:4: overflow: The expression "new_bufsize |= new_bufsize >> 16" is deemed underflowed because at least one of its arguments has underflowed.
libpcap-1.10.4/sf-pcap.c:693:4: overflow_sink: "new_bufsize", which might have underflowed, is passed to "grow_buffer(p, new_bufsize)".
#  691|   				new_bufsize = p->snapshot;
#  692|   
#  693|-> 			if (!grow_buffer(p, new_bufsize))
#  694|   				return (-1);
#  695|   		}
(Example-1) Reason Marked as False Positive:
This is a hack to actually get to the next power of two. The analysis is ignoring the new_bufsize++. Even if hdr->caplen is 0 (very unlikely) it will result in 1. p->bufsize is definitely not zero and thus the if condition above checks that hdr->caplen is at least bigger than that.

', '2025-11-17 21:39:06.975578');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (115, 96, 'def3', 'UNINIT', 'libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:226:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  224|   
#  225|   		case BPF_LDX|BPF_MEM:
#  226|-> 			X = mem[pc->k];
#  227|   			continue;
#  228|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:226:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  224|   
#  225|   (case BPF_LDX|BPF_MEM:
#  226|->          X = mem[pc->k];
#  227|            continue;
#  228|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:226:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  224|   
#  225|   		case BPF_LDX|BPF_MEM:
#  226|-> 			X = mem[pc->k];
#  227|   			continue;
#  228|
(Example-1) Reason Marked as False Positive:
I tried to ask about this in the Upstream because I myself am unable to deduce this. The answer is that only if an invalid BPF program that does a load from a memory location without storing something there first is used as a filter. But loading an invalid bpf program should not be possible, that would end with an error. This is a key component of libpcap and it would have presented itself long time ago should this be a problem.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libpcap-1.10.4/bpf_filter.c:99:2: var_decl: Declaring variable "mem" without initializer.
libpcap-1.10.4/bpf_filter.c:222:4: uninit_use: Using uninitialized value "mem[pc->k]".
#  220|   
#  221|   		case BPF_LD|BPF_MEM:
#  222|-> 			A = mem[pc->k];
#  223|   			continue;
#  224|
(Example-2) Reason Marked as False Positive:
I tried to ask about this in the Upstream because I myself am unable to deduce this. The answer is that only if an invalid BPF program that does a load from a memory location without storing something there first is used as a filter. But loading an invalid bpf program should not be possible, that would end with an error. This is a key component of libpcap and it would have presented itself long time ago should this be a problem.

', '2025-11-17 21:39:06.975578');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (116, 107, 'def1', 'INTEGER_OVERFLOW', 'ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: cast_overflow: Truncation due to cast operation on "scolumns" from 32 to 16 bits.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: overflow_assign: "sp->_columns" is assigned from "(short)scolumns".
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:664: overflow_sink: "sp->_columns", which might have overflowed, is passed to "newwin_sp(sp, slines, scolumns, 0, 0)".
#  662|   
#  663|       T(("creating newscr"));
#  664|->     NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
#  665|                                                0, 0);
#  666|       if (NewScreen(sp) == 0) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: cast_overflow: Truncation due to cast operation on "scolumns" from 32 to 16 bits.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: overflow_assign: "sp->_columns" is assigned from "(short)scolumns".
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:664: overflow_sink: "sp->_columns", which might have overflowed, is passed to "newwin_sp(sp, slines, scolumns, 0, 0)".
#  662|   
#  663|       T(("creating newscr"));
#  664|->     NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
#  665|                                                0, 0);
#  666|       if (NewScreen(sp) == 0) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: cast_overflow: Truncation due to cast operation on "scolumns" from 32 to 16 bits.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: overflow_assign: "sp->_columns" is assigned from "(short)scolumns".
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:664: overflow_sink: "sp->_columns", which might have overflowed, is passed to "newwin_sp(sp, slines, scolumns, 0, 0)".
#  662|   
#  663|       T(("creating newscr"));
#  664|->     NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
#  665|                                                0, 0);
#  666|       if (NewScreen(sp) == 0) {
(Example-1) Reason Marked as False Positive:
dimension_limit() called by _nc_makenew() called by newwin() checks if the dimension is valid (signed 16-bit integer in out (default) build configuration). The screen is not created if it the dimensions didn''t fit into the shorter type.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The tainted expression "scolumns" is used in an arithmetic operation. The expression "6 + scolumns" is considered to have possibly overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The expression "(2 + slines) * (6 + scolumns)" is deemed overflowed because at least one of its arguments has overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:445: overflow_sink: "sp->out_limit", which might have underflowed, is passed to "malloc(sp->out_limit)".
#  443|   #endif
#  444|       sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
#  445|->     if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
#  446|   	sp->out_limit = 0;
#  447|       sp->out_inuse = 0;
(Example-2) Reason Marked as False Positive:
The out buffer can be allocated with an incorrectly calculated value (undefined behavior), but there is no overflow in the buffer. It doesn''t matter how large the buffer really is. Also, in our (default) build configuration using 16-bit integers the function will return error after calling newwin() -> _nc_makenew() -> dimension_limit() as the maximum accepted lines and columns is 32767, which don''t cause overflow in the buffer length calculation.

', '2025-11-17 21:39:06.978873');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (117, 107, 'def2', 'COMPILER_WARNING', 'ncurses-6.4-20240127/ncurses/tinfo/write_entry.c: scope_hint: In function make_db_root
ncurses-6.4-20240127/ncurses/tinfo/write_entry.c:157:52: warning[-Wformat-overflow=]: %s directive writing up to 4090 bytes into a region of size between 5 and 4095
#  157 |             _nc_SPRINTF(dst, _nc_SLIMIT(limit) "%s/%s", top, src);
#      |                                                    ^~
/usr/include/bits/stdio2.h:30:10: note: __sprintf_chk output between 2 and 8182 bytes into a destination of size 4096
#   30 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
#      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   31 |                                   __glibc_objsize (__s), __fmt,
#      |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   32 |                                   __va_arg_pack ());
#      |                                   ~~~~~~~~~~~~~~~~~
#  155|       } else {
#  156|   	if ((strlen(top) + strlen(src) + 6) <= limit) {
#  157|-> 	    _nc_SPRINTF(dst, _nc_SLIMIT(limit) "%s/%s", top, src);
#  158|   	    rc = 0;
#  159|   	}', 'TRUE POSITIVE', 'The code at line 157 is potentially vulnerable to format overflow due to insufficient length checking (line 156) and the possibility of _nc_SPRINTF exceeding the specified limit, as hinted by the -Wformat-overflow warning and the __builtin___sprintf_chk note in stdio2.h.', 'The warning **[-Wformat-overflow=]** explicitly indicates a potential format overflow issue at line 157, which aligns with the CVE description of writing up to 4090 bytes into a region of size between 5 and 4095.

The condition at line 156 **((strlen(top) + strlen(src) + 6) <= limit)** checks if the combined length of **top**, **src**, and an additional 6 characters (presumably for the ''/'' and null-terminator) fits within the **limit**. However, this check does not account for the possibility of **_nc_SPRINTF** writing more than the specified length if the **%s** directives are not null-terminated or if **_nc_SLIMIT(limit)** does not effectively limit the output to **limit** bytes.

The note from **/usr/include/bits/stdio2.h:30** mentions **__builtin___sprintf_chk** output can range between 2 and 8182 bytes into a destination of size 4096, which suggests that the actual output size can exceed the **limit** check performed at line 156, especially considering the upper bound (8182) far exceeds the destination size (4096).

There is no explicit proof within the provided code that **_nc_SPRINTF** with **_nc_SLIMIT(limit)** will always prevent overflows for all possible inputs of **top** and **src**, given the warning and the note from **stdio2.h**. Therefore, without definitive proof that all execution paths are safe, the finding cannot be conclusively marked as FALSE POSITIVE.', 'Provide additional documentation or evidence regarding the behavior of `_nc_SPRINTF` with `_nc_SLIMIT(limit)` to clarify its output limitations.

Inspect the implementation of `_nc_SPRINTF` and `_nc_SLIMIT` to understand their interaction and potential for overflow.

Test the function `make_db_root` with boundary and malformed inputs for `top` and `src` to observe the actual behavior in relation to the reported CVE.', 0.0000, '*** Source Code Context ***

code of ncurses/tinfo/write_entry.c file:
144| static int
145| make_db_path(char *dst, const char *src, size_t limit)
146| {
147|     int rc = -1;
148|     const char *top = _nc_tic_dir(NULL);
149| 
150|     if (src == top || _nc_is_abs_path(src)) {
151| 	if (strlen(src) + 1 <= limit) {
152| 	    _nc_STRCPY(dst, src, limit);
153| 	    rc = 0;
154| 	}
155|     } else {
156| 	if ((strlen(top) + strlen(src) + 6) <= limit) {
157| 	    _nc_SPRINTF(dst, _nc_SLIMIT(limit) "%s/%s", top, src);
158| 	    rc = 0;
159| 	}
160|     }
161| #if USE_HASHED_DB
162|     if (rc == 0) {
163| 	static const char suffix[] = DBM_SUFFIX;
164| 	size_t have = strlen(dst);
165| 	size_t need = strlen(suffix);
166| 	if (have > need && strcmp(dst + (int) (have - need), suffix)) {
167| 	    if (have + need <= limit) {
168| 		_nc_STRCAT(dst, suffix, limit);
169| 	    } else {
170| 		rc = -1;
171| 	    }
172| 	} else if (_nc_is_dir_path(dst)) {
173| 	    rc = -1;
174| 	}
175|     }
176| #endif
177|     return rc;
178| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COMPILER_WARNING (CWE-569):
ncurses-6.2-20200222/configure: scope_hint: In function ''int main()''
ncurses-6.2-20200222/configure:23734:32: warning[-Wbool-compare]: comparison of constant ''0'' with boolean expression is always true
#23734 |                 bool x = true;
#      |                     ~~~~~~~~~~ ^   
#23732|   	FILE *fp = fopen("cf_test.out", "w");
#23733|   	if (fp != 0) {
#23734|-> 		bool x = true;
#23735|   		if ((bool)(-x) >= 0)
#23736|   			fputs("unsigned ", fp);
(Example-1) Reason Marked as False Positive:


', '2025-11-17 21:39:06.978874');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (118, 107, 'def3', 'INTEGER_OVERFLOW', 'ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The tainted expression "scolumns" is used in an arithmetic operation. The expression "6 + scolumns" is considered to have possibly overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The expression "(2 + slines) * (6 + scolumns)" is deemed overflowed because at least one of its arguments has overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:445: overflow_sink: "sp->out_limit", which might have underflowed, is passed to "malloc(sp->out_limit)".
#  443|   #endif
#  444|       sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
#  445|->     if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
#  446|   	sp->out_limit = 0;
#  447|       sp->out_inuse = 0;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The tainted expression "scolumns" is used in an arithmetic operation. The expression "6 + scolumns" is considered to have possibly overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The expression "(2 + slines) * (6 + scolumns)" is deemed overflowed because at least one of its arguments has overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:445: overflow_sink: "sp->out_limit", which might have underflowed, is passed to "malloc(sp->out_limit)".
#  443|   #endif
#  444|       sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
#  445|->     if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
#  446|    sp->out_limit = 0;
#  447|       sp->out_inuse = 0;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The tainted expression "scolumns" is used in an arithmetic operation. The expression "6 + scolumns" is considered to have possibly overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The expression "(2 + slines) * (6 + scolumns)" is deemed overflowed because at least one of its arguments has overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:445: overflow_sink: "sp->out_limit", which might have underflowed, is passed to "malloc(sp->out_limit)".
#  443|   #endif
#  444|       sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
#  445|->     if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
#  446|   	sp->out_limit = 0;
#  447|       sp->out_inuse = 0;
(Example-1) Reason Marked as False Positive:
The out buffer can be allocated with an incorrectly calculated value (undefined behavior), but there is no overflow in the buffer. It doesn''t matter how large the buffer really is. Also, in our (default) build configuration using 16-bit integers the function will return error after calling newwin() -> _nc_makenew() -> dimension_limit() as the maximum accepted lines and columns is 32767, which don''t cause overflow in the buffer length calculation.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: cast_overflow: Truncation due to cast operation on "scolumns" from 32 to 16 bits.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:435: overflow_assign: "sp->_columns" is assigned from "(short)scolumns".
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:664: overflow_sink: "sp->_columns", which might have overflowed, is passed to "newwin_sp(sp, slines, scolumns, 0, 0)".
#  662|   
#  663|       T(("creating newscr"));
#  664|->     NewScreen(sp) = NCURSES_SP_NAME(newwin) (NCURSES_SP_ARGx slines, scolumns,
#  665|                                                0, 0);
#  666|       if (NewScreen(sp) == 0) {
(Example-2) Reason Marked as False Positive:
dimension_limit() called by _nc_makenew() called by newwin() checks if the dimension is valid (signed 16-bit integer in out (default) build configuration). The screen is not created if it the dimensions didn''t fit into the shorter type.

', '2025-11-17 21:39:06.978875');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (119, 107, 'def4', 'INTEGER_OVERFLOW', 'ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: tainted_data_return: Called function "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))", and a possible return value may be less than zero.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1107: overflow: The expression "grabbed += (size_t)res" might be negative, but is used in a context that treats it as unsigned.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: overflow: The expression "3 - (int)grabbed" is deemed underflowed because at least one of its arguments has underflowed.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: overflow_sink: "(size_t)(3 - (int)grabbed)", which might have underflowed, is passed to "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1108|   
# 1109|   	/* For VIO mouse we add extra bit 64 to disambiguate button-up. */
# 1110|-> 	res = (int) read(
# 1111|   #if USE_EMX_MOUSE
# 1112|   			    (M_FD(sp) >= 0) ? M_FD(sp) : sp->_ifd,', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: ncurses-6.4-20240127/ncurses/base/lib_mouse.c: tainted_data_return: Called function "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))", and a possible return value may be less than zero.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c: overflow: The expression "grabbed += (size_t)res" might be negative, but is used in a context that treats it as unsigned.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c: overflow: The expression "3 - (int)grabbed" is deemed underflowed because at least one of its arguments has underflowed.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c: overflow_sink: "(size_t)(3 - (int)grabbed)", which might have underflowed, is passed to "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: tainted_data_return: Called function "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))", and a possible return value may be less than zero.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1107: overflow: The expression "grabbed += (size_t)res" might be negative, but is used in a context that treats it as unsigned.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: overflow: The expression "3 - (int)grabbed" is deemed underflowed because at least one of its arguments has underflowed.
ncurses-6.4-20240127/ncurses/base/lib_mouse.c:1110: overflow_sink: "(size_t)(3 - (int)grabbed)", which might have underflowed, is passed to "read(sp->_ifd, kbuf + grabbed, (size_t)(3 - (int)grabbed))". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1108|   
# 1109|   	/* For VIO mouse we add extra bit 64 to disambiguate button-up. */
# 1110|-> 	res = (int) read(
# 1111|   #if USE_EMX_MOUSE
# 1112|   			    (M_FD(sp) >= 0) ? M_FD(sp) : sp->_ifd,
(Example-1) Reason Marked as False Positive:
After the read() call there is a check for -1 and the loop breaks. The variable grabbed cannot be negative.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:390: tainted_data_argument: The value returned in "scolumns" is considered tainted.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The tainted expression "scolumns" is used in an arithmetic operation. The expression "6 + scolumns" is considered to have possibly overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: overflow: The expression "(2 + slines) * (6 + scolumns)" is deemed overflowed because at least one of its arguments has overflowed.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
ncurses-6.4-20240127/ncurses/base/lib_set_term.c:445: overflow_sink: "sp->out_limit", which might have underflowed, is passed to "malloc(sp->out_limit)".
#  443|   #endif
#  444|       sp->out_limit = (size_t) ((2 + slines) * (6 + scolumns));
#  445|->     if ((sp->out_buffer = malloc(sp->out_limit)) == 0)
#  446|   	sp->out_limit = 0;
#  447|       sp->out_inuse = 0;
(Example-2) Reason Marked as False Positive:
The out buffer can be allocated with an incorrectly calculated value (undefined behavior), but there is no overflow in the buffer. It doesn''t matter how large the buffer really is. Also, in our (default) build configuration using 16-bit integers the function will return error after calling newwin() -> _nc_makenew() -> dimension_limit() as the maximum accepted lines and columns is 32767, which don''t cause overflow in the buffer length calculation.

', '2025-11-17 21:39:06.978875');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (120, 106, 'def1', 'USE_AFTER_FREE', 'nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1952: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1950|   		if (verdict < 0) {
# 1951|   			statusline(ALERT, _("Error reading temp file: %s"), strerror(errno));
# 1952|-> 			fclose(thefile);
# 1953|   			goto cleanup_and_exit;
# 1954|   		} else if (verdict > 0) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1952: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1950|   	if (verdict < 0) {
# 1951|   	statusline(ALERT, _("Error reading temp file: %s"), strerror(errno));
# 1952|-> 	fclose(thefile);
# 1953|   	goto cleanup_and_exit;
# 1954|   	} else if (verdict > 0) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1952: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1950|   		if (verdict < 0) {
# 1951|   			statusline(ALERT, _("Error reading temp file: %s"), strerror(errno));
# 1952|-> 			fclose(thefile);
# 1953|   			goto cleanup_and_exit;
# 1954|   		} else if (verdict > 0) {
(Example-1) Reason Marked as False Positive:
`copy_file` copies `source` to `thefile` and the third argument decides if `thefile` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `thefile` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-5.6.1/src/files.c:1932: freed_arg: "copy_file" frees "thefile".
nano-5.6.1/src/files.c:1936: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1934|   		if (verdict < 0) {
# 1935|   			statusline(ALERT, _("Error reading temp file: %s"), strerror(errno));
# 1936|-> 			fclose(thefile);
# 1937|   			goto cleanup_and_exit;
# 1938|   		} else if (verdict > 0) {
(Example-2) Reason Marked as False Positive:
`copy_file` copies `source` to `thefile` and the third argument decides if `thefile` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `thefile` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

', '2025-11-17 21:39:06.983975');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (121, 106, 'def2', 'UNINIT', 'nano-7.2/src/browser.c:390: var_decl: Declaring variable "dir" without initializer.
nano-7.2/src/browser.c:417: uninit_use: Using uninitialized value "dir".
#  415|           }
#  416|   
#  417|->         if (dir != NULL) {
#  418|                   /* Get the file list, and set gauge and piles in the process. */
#  419|                   read_the_list(path, dir);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/browser.c:390: var_decl: Declaring variable "dir" without initializer.
nano-7.2/src/browser.c:417: uninit_use: Using uninitialized value "dir".
#  415|           }
#  416|   
#  417|->         if (dir != NULL) {
#  418|                   /* Get the file list, and set gauge and piles in the process. */
#  419|                   read_the_list(path, dir);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
nano-7.2/src/browser.c:390: var_decl: Declaring variable "dir" without initializer.
nano-7.2/src/browser.c:417: uninit_use: Using uninitialized value "dir".
#  415|           }
#  416|   
#  417|->         if (dir != NULL) {
#  418|                   /* Get the file list, and set gauge and piles in the process. */
#  419|                   read_the_list(path, dir);
(Example-1) Reason Marked as False Positive:
If the code is executed for the first time, the initialization depends on the `path` variable.  If `path` is not `NULL`, `dir` will be initialized.  Let''s assume that `path` is `NULL`.  Since this is the first execution, `filelist` will be `NULL` as well and function will return and `dir` will not be accessed.  Therefore, the uninitialized read cannot happen.  Subsequent jumps to the `read_directory_contents` label will be therefore ok as well.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
nano-5.6.1/lib/regexec.c:1393: alloc_fn: Calling "malloc" which returns uninitialized memory.
nano-5.6.1/lib/regexec.c:1393: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 48UL)", which points to uninitialized data.
nano-5.6.1/lib/regexec.c:1406: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
nano-5.6.1/lib/regexec.c:1406: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1404|       {
# 1405|         regmatch_list_free (&prev_match);
# 1406|->       free_fail_stack_return (fs);
# 1407|         return REG_ESPACE;
# 1408|       }
(Example-2) Reason Marked as False Positive:
The `free_fail_stack_return` function frees the structure only if this condition is true: `for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)` and `fs->num` is initialized to zero in this case.

', '2025-11-17 21:39:06.983977');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (122, 106, 'def3', 'USE_AFTER_FREE', 'nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1956: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1954|   		} else if (verdict > 0) {
# 1955|   			statusline(ALERT, _("Error writing %s: %s"), realname, strerror(errno));
# 1956|-> 			fclose(thefile);
# 1957|   			goto cleanup_and_exit;
# 1958|   		}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1956: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1954|    } else if (verdict > 0) {
# 1955|    statusline(ALERT, _("Error writing %s: %s"), realname, strerror(errno));
# 1956|->    fclose(thefile);
# 1957|    goto cleanup_and_exit;
# 1958|    }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-7.2/src/files.c:1948: freed_arg: "copy_file" frees "thefile".
nano-7.2/src/files.c:1956: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1954|   		} else if (verdict > 0) {
# 1955|   			statusline(ALERT, _("Error writing %s: %s"), realname, strerror(errno));
# 1956|-> 			fclose(thefile);
# 1957|   			goto cleanup_and_exit;
# 1958|   		}
(Example-1) Reason Marked as False Positive:
`copy_file` copies `source` to `thefile` and the third argument decides if `thefile` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `thefile` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-5.6.1/src/files.c:1932: freed_arg: "copy_file" frees "thefile".
nano-5.6.1/src/files.c:1940: use_closed_file: Calling "fclose" uses file handle "thefile" after closing it.
# 1938|   		} else if (verdict > 0) {
# 1939|   			statusline(ALERT, _("Error writing %s: %s"), realname, strerror(errno));
# 1940|-> 			fclose(thefile);
# 1941|   			goto cleanup_and_exit;
# 1942|   		}
(Example-2) Reason Marked as False Positive:
`copy_file` copies `source` to `thefile` and the third argument decides if `thefile` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `thefile` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

', '2025-11-17 21:39:06.983977');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (123, 106, 'def4', 'RESOURCE_LEAK', 'nano-7.2/src/files.c:177: open_fn: Returning handle opened by "open". [Note: The source code implementation of the function has been overridden by a user model.]
nano-7.2/src/files.c:177: var_assign: Assigning: "fd" = handle returned from "open(lockfilename, 193, 438)".
nano-7.2/src/files.c:179: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:179: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:185: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:185: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:187: leaked_handle: Handle variable "fd" going out of scope leaks the handle.
#  185|   		if (fd > 0)
#  186|   			close(fd);
#  187|-> 		return FALSE;
#  188|   	}
#  189|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:177: open_fn: Returning handle opened by "open". [Note: The source code implementation of the function has been overridden by a user model.]
nano-7.2/src/files.c:177: var_assign: Assigning: "fd" = handle returned from "open(lockfilename, 193, 438)".
nano-7.2/src/files.c:179: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:179: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:185: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:185: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:187: leaked_handle: Handle variable "fd" going out of scope leaks the handle.
#  185|   _if (fd > 0)
#  186|   _close(fd);
#  187|-> _return FALSE;
#  188|   }
#  189|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-7.2/src/files.c:177: open_fn: Returning handle opened by "open". [Note: The source code implementation of the function has been overridden by a user model.]
nano-7.2/src/files.c:177: var_assign: Assigning: "fd" = handle returned from "open(lockfilename, 193, 438)".
nano-7.2/src/files.c:179: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:179: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:185: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-7.2/src/files.c:185: remediation: Did you intend to include equality with zero?
nano-7.2/src/files.c:187: leaked_handle: Handle variable "fd" going out of scope leaks the handle.
#  185|   		if (fd > 0)
#  186|   			close(fd);
#  187|-> 		return FALSE;
#  188|   	}
#  189|
(Example-1) Reason Marked as False Positive:
I''m 99% percent sure that this is a false positive because nano expects that fd 0 points to a tty (or pipe if `-` is passed one of the arguments) and that it will be open during its whole execution.  If stdin is closed before nano starts, it will produce an error message and exit immediately.  Therefore, all `open` calls in nano should either return `-1` or a valid fd greater than 0.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-5.6.1/src/files.c:170: open_fn: Returning handle opened by "open". [Note: The source code implementation of the function has been overridden by a user model.]
nano-5.6.1/src/files.c:170: var_assign: Assigning: "fd" = handle returned from "open(lockfilename, 193, 438)".
nano-5.6.1/src/files.c:172: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-5.6.1/src/files.c:172: remediation: Did you intend to include equality with zero?
nano-5.6.1/src/files.c:178: off_by_one: Testing whether handle "fd" is strictly greater than zero is suspicious.  "fd" leaks when it is zero.
nano-5.6.1/src/files.c:178: remediation: Did you intend to include equality with zero?
nano-5.6.1/src/files.c:180: leaked_handle: Handle variable "fd" going out of scope leaks the handle.
#  178|   		if (fd > 0)
#  179|   			close(fd);
#  180|-> 		return FALSE;
#  181|   	}
#  182|
(Example-2) Reason Marked as False Positive:
I''m 99% percent sure that this is a false positive because nano expects that fd 0 points to a tty (or pipe if `-` is passed one of the arguments) and that it will be open during its whole execution.  If stdin is closed before nano starts, it will produce an error message and exit immediately.  Therefore, all `open` calls in nano should either return `-1` or a valid fd greater than 0.

', '2025-11-17 21:39:06.983978');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (124, 106, 'def5', 'RESOURCE_LEAK', 'nano-7.2/src/text.c:2055: alloc_arg: "open_file" allocates memory that is stored into "stream".
nano-7.2/src/text.c:2058: leaked_storage: Variable "stream" going out of scope leaks the storage it points to.
# 2056|   
# 2057|   	if (descriptor < 0)
# 2058|-> 		return FALSE;
# 2059|   
# 2060|   #ifndef NANO_TINY', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/text.c:2055: alloc_arg: "open_file" allocates memory that is stored into "stream".
nano-7.2/src/text.c:2058: leaked_storage: Variable "stream" going out of scope leaks the storage it points to.
# 2056|   
# 2057|    if (descriptor < 0)
# 2058|->  return FALSE;
# 2059|   
# 2060|   #ifndef NANO_TINY', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-7.2/src/text.c:2055: alloc_arg: "open_file" allocates memory that is stored into "stream".
nano-7.2/src/text.c:2058: leaked_storage: Variable "stream" going out of scope leaks the storage it points to.
# 2056|   
# 2057|   	if (descriptor < 0)
# 2058|-> 		return FALSE;
# 2059|   
# 2060|   #ifndef NANO_TINY
(Example-1) Reason Marked as False Positive:
open_file returns -1 only on failure and resources allocated by that function are properly freed in such case.  Therefore, will not point to an open stream.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-5.6.1/src/text.c:2055: alloc_arg: "open_file" allocates memory that is stored into "stream".
nano-5.6.1/src/text.c:2058: leaked_storage: Variable "stream" going out of scope leaks the storage it points to.
# 2056|   
# 2057|   	if (descriptor < 0)
# 2058|-> 		return FALSE;
# 2059|   
# 2060|   	cutbuffer = NULL;
(Example-2) Reason Marked as False Positive:
`open_file` returns `-1` only on failure and resources allocated by that function are properly freed in such case.  Therefore, `stream` will not point to an open stream.

', '2025-11-17 21:39:06.983978');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (125, 106, 'def6', 'USE_AFTER_FREE', 'nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1683: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1681|   		goto failure;
# 1682|   	} else if (verdict > 0) {
# 1683|-> 		fclose(backup_file);
# 1684|   		goto problem;
# 1685|   	}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1683: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1681|   .goto failure;
# 1682|   } else if (verdict > 0) {
# 1683|->  fclose(backup_file);
# 1684|    goto problem;
# 1685|   }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1683: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1681|   		goto failure;
# 1682|   	} else if (verdict > 0) {
# 1683|-> 		fclose(backup_file);
# 1684|   		goto problem;
# 1685|   	}
(Example-1) Reason Marked as False Positive:
`copy_file` copies `original` to `backup_file` and the third argument decides if `backup_file` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `backup_file` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-5.6.1/src/files.c:1667: freed_arg: "copy_file" frees "backup_file".
nano-5.6.1/src/files.c:1674: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1672|   		goto failure;
# 1673|   	} else if (verdict > 0) {
# 1674|-> 		fclose(backup_file);
# 1675|   		goto problem;
# 1676|   	}
(Example-2) Reason Marked as False Positive:
`copy_file` copies `original` to `backup_file` and the third argument decides if `backup_file` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `backup_file` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

', '2025-11-17 21:39:06.983978');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (126, 106, 'def7', 'COMPILER_WARNING', 'nano-7.2/src/history.c: scope_hint: In function save_poshistory
nano-7.2/src/history.c:456:44: warning[-Wstringop-overflow=]: writing 1 byte into a region of size 0
#  456 |                 path_and_place[length - 1] = ''\n'';
#      |                                            ^
nano-7.2/src/utils.c:293:25: note: at offset -1 into destination object of size [44, 9223372036854775807] allocated by malloc
#  293 |         void *section = malloc(howmuch);
#      |                         ^
#  454|   		length = recode_LF_to_NUL(path_and_place);
#  455|   		/* Restore the terminating newline. */
#  456|-> 		path_and_place[length - 1] = ''\n'';
#  457|   
#  458|   		if (fwrite(path_and_place, 1, length, histfile) < length)', 'TRUE POSITIVE', 'No explicit check ensures `length > 0` before writing to `path_and_place[length - 1]` at `history.c:456`, potentially leading to an out-of-bounds write if `recode_LF_to_NUL` returns 0, aligning with the warning of writing into a region of size 0.', 'The warning **writing 1 byte into a region of size 0** at `history.c:456` suggests a potential buffer overflow or out-of-bounds write.

The line in question, `path_and_place[length - 1] = ''
'';`, attempts to write a newline character at the index `length - 1`.

The `length` variable is assigned the return value of `recode_LF_to_NUL(path_and_place);` at `history.c:454`.

There is no explicit check in the provided code to ensure `length` is greater than 0 before performing the write at `history.c:456`.

If `recode_LF_to_NUL(path_and_place);` returns 0 (which is possible if the input string does not contain any LF characters to recode), `path_and_place[length - 1]` would access an index out of bounds (since `length - 1` would be `-1`), aligning with the warning of writing into a region of size 0.

The allocation note at `utils.c:293` indicates the memory for `path_and_place` was dynamically allocated, but the size allocated (`strlen(item->filename) + 44` at `history.c:449`) does not directly influence the safety of the write at `history.c:456` without knowing the return behavior of `recode_LF_to_NUL` for empty or specific inputs.

Given the lack of explicit bounds checking for `length` before the write operation, and the direct correlation with the CVE''s description of writing into a region of size 0, there is a potential vulnerability.', 'Obtain and analyze the implementation of `recode_LF_to_NUL` to determine its impact on the buffer size and potential for overflow.

Investigate error handling mechanisms within `save_poshistory` to understand how allocation failures or `recode_LF_to_NUL` errors are managed.

Assess the exploitability of the potential buffer overflow in the context of the `fwrite` operation at `history.c:458`.', 0.0000, '*** Source Code Context ***

code of src/history.c file:
428| void save_poshistory(void)
429| {
430| 	FILE *histfile = fopen(poshistname, "wb");
431| 	struct stat fileinfo;
432| 	poshiststruct *item;
433| 
434| 	if (histfile == NULL) {
435| 		jot_error(N_("Error writing %s: %s"), poshistname, strerror(errno));
436| 		return;
437| 	}
438| 
439| 	/* Don''t allow others to read or write the history file. */
440| 	if (chmod(poshistname, S_IRUSR | S_IWUSR) < 0)
441| 		jot_error(N_("Cannot limit permissions on %s: %s"), poshistname, strerror(errno));
442| 
443| 	for (item = position_history; item != NULL; item = item->next) {
444| 		char *path_and_place;
445| 		size_t length;
446| 
447| 		/* Assume 20 decimal positions each for line and column number,
448| 		 * plus two spaces, plus the line feed, plus the null byte. */
449| 		path_and_place = nmalloc(strlen(item->filename) + 44);
450| 		sprintf(path_and_place, "%s %zd %zd
",
451| 								item->filename, item->linenumber, item->columnnumber);
452| 
453| 		/* Encode newlines in filenames as NULs. */
454| 		length = recode_LF_to_NUL(path_and_place);
455| 		/* Restore the terminating newline. */
456| 		path_and_place[length - 1] = ''
'';
457| 
458| 		if (fwrite(path_and_place, 1, length, histfile) < length)
459| 			jot_error(N_("Error writing %s: %s"), poshistname, strerror(errno));
460| 
461| 		free(path_and_place);
462| 	}
463| 
464| 	if (fclose(histfile) == EOF)
465| 		jot_error(N_("Error writing %s: %s"), poshistname, strerror(errno));
466| 
467| 	if (stat(poshistname, &fileinfo) == 0)
468| 		latest_timestamp = fileinfo.st_mtime;
469| }

code of src/utils.c file:
291| void *nmalloc(size_t howmuch)
292| {
293| 	void *section = malloc(howmuch);
294| 
295| 	if (section == NULL)
296| 		die(_("Nano is out of memory!
"));
297| 
298| 	return section;
299| }

code of /shared-data/source/nano-7.2/src/prototypes.h file:
538| 
539| /* All functions in utils.c. */
540| void get_homedir(void);
541| const char *tail(const char *path);
542| char *concatenate(const char *path, const char *name);
543| int digits(ssize_t n);
544| bool parse_num(const char *str, ssize_t *result);
545| bool parse_line_column(const char *str, ssize_t *line, ssize_t *column);
546| void recode_NUL_to_LF(char *string, size_t length);
547| size_t recode_LF_to_NUL(char *string);
548| #if !defined(ENABLE_TINY) || defined(ENABLE_TABCOMP) || defined(ENABLE_BROWSER)
549| void free_chararray(char **array, size_t len);
550| #endif
551| #ifdef ENABLE_SPELLER
552| bool is_separate_word(size_t position, size_t length, const char *buf);
553| #endif
554| const char *strstrwrapper(const char *haystack, const char *needle,
555| 		const char *start);
556| void *nmalloc(size_t howmuch);
557| void *nrealloc(void *ptr, size_t howmuch);
558| char *measured_copy(const char *string, size_t count);
559| char *mallocstrcpy(char *dest, const char *src);
560| char *copy_of(const char *string);
561| char *free_and_assign(char *dest, char *src);
562| size_t get_page_start(size_t column);
563| size_t xplustabs(void);
564| size_t actual_x(const char *text, size_t column);
565| size_t wideness(const char *text, size_t maxlen);
566| size_t breadth(const char *text);
567| void new_magicline(void);
568| #if !defined(NANO_TINY) || defined(ENABLE_HELP)
569| void remove_magicline(void);
570| #endif
571| #ifndef NANO_TINY
572| bool mark_is_before_cursor(void);
573| void get_region(linestruct **top, size_t *top_x, linestruct **bot, size_t *bot_x);
574| void get_range(linestruct **top, linestruct **bot);
575| #endif
576| size_t number_of_characters_in(const linestruct *begin, const linestruct *end);
577| #if !defined(NANO_TINY) || defined(ENABLE_SPELLER) || defined (ENABLE_LINTER) || defined (ENABLE_FORMATTER)
578| linestruct *line_from_number(ssize_t number);
579| #endif
580| 
581| /* Most functions in winio.c. */
582| #ifndef NANO_TINY
583| void record_macro(void);
584| void run_macro(void);
585| #endif
586| void reserve_space_for(size_t newsize);
587| size_t waiting_keycodes(void);
588| #ifdef ENABLE_NANORC
589| void implant(const char *string);
590| #endif
591| int get_input(WINDOW *win);
592| int get_kbinput(WINDOW *win, bool showcursor);
593| char *get_verbatim_kbinput(WINDOW *win, size_t *count);
594| #ifdef ENABLE_MOUSE
595| int get_mouseinput(int *mouse_y, int *mouse_x, bool allow_shortcuts);
596| #endif
597| void blank_edit(void);
598| void blank_statusbar(void);
599| void wipe_statusbar(void);
600| void blank_bottombars(void);

*** Examples ***
', '2025-11-17 21:39:06.983979');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (127, 106, 'def8', 'RESOURCE_LEAK', 'nano-7.2/src/files.c:461: alloc_arg: "open_file" allocates memory that is stored into "f".
nano-7.2/src/files.c:492: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  490|   
#  491|   	free(realname);
#  492|-> 	return TRUE;
#  493|   }
#  494|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:461: alloc_arg: "open_file" allocates memory that is stored into "f".
nano-7.2/src/files.c:492: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  490|   
#  491|    free(realname);
#  492|-> return TRUE;
#  493|   }
#  494|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-7.2/src/files.c:461: alloc_arg: "open_file" allocates memory that is stored into "f".
nano-7.2/src/files.c:492: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  490|   
#  491|   	free(realname);
#  492|-> 	return TRUE;
#  493|   }
#  494|
(Example-1) Reason Marked as False Positive:
`f` will point an open file stream if and only if `open_file` returns value greater than 0.  This handle is then passed to the `read_file` function and this function calles `fclose(f)` and all possible code paths to this line from its own entry point.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-5.6.1/src/files.c:439: alloc_arg: "open_file" allocates memory that is stored into "f".
nano-5.6.1/src/files.c:473: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  471|   #endif
#  472|   	free(realname);
#  473|-> 	return TRUE;
#  474|   }
#  475|
(Example-2) Reason Marked as False Positive:
`f` will point an open file stream if and only if `open_file` returns value greater than 0.  This handle is then passed to the `read_file` function and this function calles `fclose(f)` and all possible code paths to this line from its own entry point.

', '2025-11-17 21:39:06.983979');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (128, 106, 'def9', 'RESOURCE_LEAK', 'nano-7.2/src/text.c:2031: alloc_fn: Storage is returned from allocation function "copy_of".
nano-7.2/src/text.c:2031: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-7.2/src/text.c:2032: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-7.2/src/text.c:2043: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2041|   	(*arguments)[count - 2] = filename;
# 2042|   	(*arguments)[count - 1] = NULL;
# 2043|-> }
# 2044|   #endif
# 2045|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/text.c:2031: alloc_fn: Storage is returned from allocation function "copy_of".
nano-7.2/src/text.c:2031: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-7.2/src/text.c:2032: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-7.2/src/text.c:2043: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2041|   	(*arguments)[count - 2] = filename;
# 2042|   	(*arguments)[count - 1] = NULL;
# 2043|-> }
# 2044|   #endif
# 2045|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-7.2/src/text.c:2031: alloc_fn: Storage is returned from allocation function "copy_of".
nano-7.2/src/text.c:2031: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-7.2/src/text.c:2032: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-7.2/src/text.c:2043: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2041|   	(*arguments)[count - 2] = filename;
# 2042|   	(*arguments)[count - 1] = NULL;
# 2043|-> }
# 2044|   #endif
# 2045|
(Example-1) Reason Marked as False Positive:
The leak is entended because this function duplicates and splits the `command` string into an array of strings that will be passed to `execve(2)`.  Nano will then fork.  If the given `execve(2)` calls in its chidren succeed, there is nothing to free and if they fail, `nano` will immediately call `exit(3)`.  Otherwise, `the parent process will correctly free the string regardless of `fork(2)`''s return value.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-5.6.1/src/text.c:2033: alloc_fn: Storage is returned from allocation function "copy_of".
nano-5.6.1/src/text.c:2033: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-5.6.1/src/text.c:2034: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-5.6.1/src/text.c:2045: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2043|   	(*arguments)[count - 2] = filename;
# 2044|   	(*arguments)[count - 1] = NULL;
# 2045|-> }
# 2046|   
# 2047|   /* Open the specified file, and if that succeeds, remove the text of the marked
(Example-2) Reason Marked as False Positive:
The leak is intended because this function duplicates and splits the `command` string into an array of strings that will be passed to `execve(2)`.  Nano will then fork.  If the given `execve(2)` calls in its children succeed, there is nothing to free and if they fail, `nano` will immediately call `exit(3)`.  Otherwise, `the parent process will correctly free the string regardless of `fork(2)`''s return value.

', '2025-11-17 21:39:06.983979');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (129, 106, 'def10', 'USE_AFTER_FREE', 'nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1680: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1678|   	if (original == NULL || verdict < 0) {
# 1679|   		warn_and_briefly_pause(_("Cannot read original file"));
# 1680|-> 		fclose(backup_file);
# 1681|   		goto failure;
# 1682|   	} else if (verdict > 0) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1680: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1678|    if (original == NULL || verdict < 0) {
# 1679|       warn_and_briefly_pause((_("Cannot read original file"))
# 1680|->       fclose(backup_file);
# 1681|       goto failure;
# 1682|    } else if (verdict > 0) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-7.2/src/files.c:1676: freed_arg: "copy_file" frees "backup_file".
nano-7.2/src/files.c:1680: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1678|   	if (original == NULL || verdict < 0) {
# 1679|   		warn_and_briefly_pause(_("Cannot read original file"));
# 1680|-> 		fclose(backup_file);
# 1681|   		goto failure;
# 1682|   	} else if (verdict > 0) {
(Example-1) Reason Marked as False Positive:
`copy_file` copies `original` to `backup_file` and the third argument decides if `backup_file` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `backup_file` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-672):
nano-5.6.1/src/files.c:1667: freed_arg: "copy_file" frees "backup_file".
nano-5.6.1/src/files.c:1671: use_closed_file: Calling "fclose" uses file handle "backup_file" after closing it.
# 1669|   	if (original == NULL || verdict < 0) {
# 1670|   		warn_and_briefly_pause(_("Cannot read original file"));
# 1671|-> 		fclose(backup_file);
# 1672|   		goto failure;
# 1673|   	} else if (verdict > 0) {
(Example-2) Reason Marked as False Positive:
`copy_file` copies `original` to `backup_file` and the third argument decides if `backup_file` should be automatically closed after the copying is done.  Since this flag is set to `FALSE`, `backup_file` is still open when `copy_file` returns and `fclose` is, therefore, called only once.

', '2025-11-17 21:39:06.98398');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (130, 106, 'def11', 'BAD_ALLOC_STRLEN', 'nano-7.2/src/files.c:1409: bad_alloc_strlen: Using "strlen(slash + 1)" instead of "strlen(slash) + 1" as an argument to "nrealloc" might be an under-allocation.
# 1407|   		/* Upon success, re-add the last component of the original path. */
# 1408|   		if (target) {
# 1409|-> 			target = nrealloc(target, strlen(target) + strlen(slash + 1) + 1);
# 1410|   			strcat(target, slash + 1);
# 1411|   		}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: nano-7.2/src/files.c:1409: bad_alloc_strlen: Using "strlen(slash + 1)" instead of "strlen(slash) + 1" as an argument to "nrealloc" might be an under-allocation.
# 1407|    /* Upon success, re-add the last component of the original path. */
# 1408|    if (target) {
# 1409|-> target = nrealloc(target, strlen(target) + strlen(slash + 1) + 1);
# 1410|    strcat(target, slash + 1);
# 1411|    }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BAD_ALLOC_STRLEN (CWE-131):
nano-7.2/src/files.c:1409: bad_alloc_strlen: Using "strlen(slash + 1)" instead of "strlen(slash) + 1" as an argument to "nrealloc" might be an under-allocation.
# 1407|   		/* Upon success, re-add the last component of the original path. */
# 1408|   		if (target) {
# 1409|-> 			target = nrealloc(target, strlen(target) + strlen(slash + 1) + 1);
# 1410|   			strcat(target, slash + 1);
# 1411|   		}
(Example-1) Reason Marked as False Positive:
The next line appends the string starting at `slash + 1` to the `target` string.  Therefore, it is correct to use `strlen(slash + 1)` to compule length of this substring.

', '2025-11-17 21:39:06.98398');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (131, 106, 'def12', 'RESOURCE_LEAK', 'nano-7.2/src/text.c:2716: alloc_fn: Storage is returned from allocation function "nmalloc".
nano-7.2/src/text.c:2716: var_assign: Assigning: "curlint" = storage returned from "nmalloc(48UL)".
nano-7.2/src/text.c:2727: var_assign: Assigning: "lints" = "curlint".
nano-7.2/src/text.c:2745: leaked_storage: Variable "curlint" going out of scope leaks the storage it points to.
nano-7.2/src/text.c:2745: leaked_storage: Variable "lints" going out of scope leaks the storage it points to.
# 2743|   	if (!WIFEXITED(lint_status) || WEXITSTATUS(lint_status) > 2) {
# 2744|   		statusline(ALERT, _("Error invoking ''%s''"), openfile->syntax->linter);
# 2745|-> 		return;
# 2746|   	}
# 2747|', 'FALSE POSITIVE', 'Memory allocated for `curlint`/`lints` at line 2716 is not leaked at line 2745, as its scope extends beyond this point and is explicitly freed in the loop starting at line 2896, ensuring proper deallocation regardless of the early return.', 'The reported leak occurs at line 2745, where `curlint` and `lints` allegedly go out of scope, leaking allocated storage.

However, examining the code, `curlint` is assigned to `lints` at line 2727, and `lints` is not local to the if-statement block ending at line 2745.

The scope of `lints` extends beyond line 2745, as evidenced by its usage in subsequent code blocks (e.g., lines 2763-2902).

At the end of the `do_linter` function, there is a deliberate free of all `lintstruct`s, including the one `curlint`/`lints` points to, starting at line 2896: `for (curlint = lints; curlint != NULL;) { ... free(tmplint); }`

This loop ensures that all dynamically allocated memory for `lintstruct`s, including the one allegedly leaked, is properly deallocated before the function fully returns.

Given this explicit deallocation, the reported leak at line 2745 is not actually a leak, as the memory is freed later in the function, regardless of the early return at line 2745.', NULL, 0.0000, '*** Source Code Context ***

code of src/text.c file:
2571| void do_linter(void)
2572| {
2573| #if defined(HAVE_FORK) && defined(HAVE_WAITPID)
2574| 	char *lintings, *pointer, *onelint;
2575| 	long pipesize;
2576| 	size_t buffersize, bytesread, totalread;
2577| 	bool parsesuccess = FALSE;
2578| 	int lint_status, lint_fd[2];
2579| 	pid_t pid_lint;
2580| 	bool helpless = ISSET(NO_HELP);
2581| 	lintstruct *lints = NULL, *tmplint = NULL, *curlint = NULL;
2582| 	time_t last_wait = 0;
2583| 
2584| 	ran_a_tool = TRUE;
2585| 
2586| 	if (in_restricted_mode())
2587| 		return;
2588| 
2589| 	if (!openfile->syntax || !openfile->syntax->linter) {
2590| 		statusline(AHEM, _("No linter is defined for this type of file"));
2591| 		return;
2592| 	}
2593| 
2594| #ifndef NANO_TINY
2595| 	openfile->mark = NULL;
2596| #endif
2597| 	edit_refresh();
2598| 
2599| 	if (openfile->modified) {
2600| 		int choice = ask_user(YESORNO, _("Save modified buffer before linting?"));
2601| 
2602| 		if (choice == CANCEL) {
2603| 			statusbar(_("Cancelled"));
2604| 			return;
2605| 		} else if (choice == YES && (write_it_out(FALSE, FALSE) != 1))
2606| 			return;
2607| 	}
2608| 
2609| 	/* Create a pipe up front. */
2610| 	if (pipe(lint_fd) == -1) {
2611| 		statusline(ALERT, _("Could not create pipe: %s"), strerror(errno));
2612| 		return;
2613| 	}
2614| 
2615| 	blank_bottombars();
2616| 	currmenu = MLINTER;
2617| 	statusbar(_("Invoking linter..."));
2618| 
2619| 	/* Fork a process to run the linter in. */
2620| 	if ((pid_lint = fork()) == 0) {
2621| 		char **lintargs = NULL;
2622| 
2623| 		/* Redirect standard output and standard error into the pipe. */
2624| 		if (dup2(lint_fd[1], STDOUT_FILENO) < 0)
2625| 			exit(7);
2626| 		if (dup2(lint_fd[1], STDERR_FILENO) < 0)
2627| 			exit(8);
2628| 
2629| 		close(lint_fd[0]);
2630| 		close(lint_fd[1]);
2631| 
2632| 		construct_argument_list(&lintargs, openfile->syntax->linter, openfile->filename);
2633| 
2634| 		/* Start the linter program; we are using $PATH. */
2635| 		execvp(lintargs[0], lintargs);
2636| 
2637| 		/* This is only reached when the linter is not found. */
2638| 		exit(9);
2639| 	}
2640| 
2641| 	/* Parent continues here. */
2642| 	close(lint_fd[1]);
2643| 
2644| 	/* If the child process was not forked successfully... */
2645| 	if (pid_lint < 0) {
2646| 		statusline(ALERT, _("Could not fork: %s"), strerror(errno));
2647| 		close(lint_fd[0]);
2648| 		return;
2649| 	}
2650| 
2651| 	/* Get the system pipe buffer size. */
2652| 	pipesize = fpathconf(lint_fd[0], _PC_PIPE_BUF);
2653| 
2654| 	if (pipesize < 1) {
2655| 		statusline(ALERT, _("Could not get size of pipe buffer"));
2656| 		close(lint_fd[0]);
2657| 		return;
2658| 	}
2659| 
2660| 	/* Block resizing signals while reading from the pipe. */
2661| 	block_sigwinch(TRUE);
2662| 
2663| 	/* Read in the returned syntax errors. */
2664| 	totalread = 0;
2665| 	buffersize = pipesize + 1;
2666| 	lintings = nmalloc(buffersize);
2667| 	pointer = lintings;
2668| 
2669| 	while ((bytesread = read(lint_fd[0], pointer, pipesize)) > 0) {
2670| 		totalread += bytesread;
2671| 		buffersize += pipesize;
2672| 		lintings = nrealloc(lintings, buffersize);
2673| 		pointer = lintings + totalread;
2674| 	}
2675| 
2676| 	*pointer = ''\0'';
2677| 	close(lint_fd[0]);
2678| 
2679| 	block_sigwinch(FALSE);
2680| 
2681| 	pointer = lintings;
2682| 	onelint = lintings;
2683| 
2684| 	/* Now parse the output of the linter. */
2685| 	while (*pointer != ''\0'') {
2686| 		if ((*pointer == ''\r'') || (*pointer == ''
'')) {
2687| 			*pointer = ''\0'';
2688| 			if (onelint != pointer) {
2689| 				char *filename, *linestring, *colstring;
2690| 				char *complaint = copy_of(onelint);
2691| 				char *spacer = strstr(complaint, " ");
2692| 
2693| 				/* The recognized format is "filename:line:column: message",
2694| 				 * where ":column" may be absent or be ",column" instead. */
2695| 				if ((filename = strtok(onelint, ":")) && spacer) {
2696| 					if ((linestring = strtok(NULL, ":"))) {
2697| 						if ((colstring = strtok(NULL, " "))) {
2698| 							ssize_t linenumber = strtol(linestring, NULL, 10);
2699| 							ssize_t colnumber = strtol(colstring, NULL, 10);
2700| 
2701| 							if (linenumber <= 0) {
2702| 								free(complaint);
2703| 								pointer++;
2704| 								continue;
2705| 							}
2706| 
2707| 							if (colnumber <= 0) {
2708| 								colnumber = 1;
2709| 								strtok(linestring, ",");
2710| 								if ((colstring = strtok(NULL, ",")))
2711| 									colnumber = strtol(colstring, NULL, 10);
2712| 							}
2713| 
2714| 							parsesuccess = TRUE;
2715| 							tmplint = curlint;
2716| 							curlint = nmalloc(sizeof(lintstruct));
2717| 							curlint->next = NULL;
2718| 							curlint->prev = tmplint;
2719| 							if (curlint->prev != NULL)
2720| 								curlint->prev->next = curlint;
2721| 							curlint->filename = copy_of(filename);
2722| 							curlint->lineno = linenumber;
2723| 							curlint->colno = colnumber;
2724| 							curlint->msg = copy_of(spacer + 1);
2725| 
2726| 							if (lints == NULL)
2727| 								lints = curlint;
2728| 						}
2729| 					}
2730| 				}
2731| 				free(complaint);
2732| 			}
2733| 			onelint = pointer + 1;
2734| 		}
2735| 		pointer++;
2736| 	}
2737| 
2738| 	free(lintings);
2739| 
2740| 	/* Process the end of the linting process. */
2741| 	waitpid(pid_lint, &lint_status, 0);
2742| 
2743| 	if (!WIFEXITED(lint_status) || WEXITSTATUS(lint_status) > 2) {
2744| 		statusline(ALERT, _("Error invoking ''%s''"), openfile->syntax->linter);
2745| 		return;
2746| 	}
2747| 
2748| 	if (!parsesuccess) {
2749| 		statusline(REMARK, _("Got 0 parsable lines from command: %s"),
2750| 						openfile->syntax->linter);
2751| 		return;
2752| 	}
2753| 
2754| 	if (helpless && LINES > 5) {
2755| 		UNSET(NO_HELP);
2756| 		window_init();
2757| 	}
2758| 
2759| 	/* Show that we are in the linter now. */
2760| 	titlebar(NULL);
2761| 	bottombars(MLINTER);
2762| 
2763| 	tmplint = NULL;
2764| 	curlint = lints;
2765| 
2766| 	while (TRUE) {
2767| 		int kbinput;
2768| 		functionptrtype function;
2769| 		struct stat lintfileinfo;
2770| 
2771| 		if (stat(curlint->filename, &lintfileinfo) != -1 &&
2772| 					(openfile->statinfo == NULL ||
2773| 					openfile->statinfo->st_ino != lintfileinfo.st_ino)) {
2774| #ifdef ENABLE_MULTIBUFFER
2775| 			const openfilestruct *started_at = openfile;
2776| 
2777| 			openfile = openfile->next;
2778| 			while (openfile != started_at && (openfile->statinfo == NULL ||
2779| 						openfile->statinfo->st_ino != lintfileinfo.st_ino))
2780| 				openfile = openfile->next;
2781| 
2782| 			if (openfile->statinfo == NULL ||
2783| 						openfile->statinfo->st_ino != lintfileinfo.st_ino) {
2784| 				char *msg = nmalloc(1024 + strlen(curlint->filename));
2785| 				int choice;
2786| 
2787| 				sprintf(msg, _("This message is for unopened file %s,"
2788| 							" open it in a new buffer?"), curlint->filename);
2789| 				choice = ask_user(YESORNO, msg);
2790| 				currmenu = MLINTER;
2791| 				free(msg);
2792| 
2793| 				if (choice == CANCEL) {
2794| 					statusbar(_("Cancelled"));
2795| 					break;
2796| 				} else if (choice == YES) {
2797| 					open_buffer(curlint->filename, TRUE);
2798| 				} else {
2799| #endif
2800| 					char *dontwantfile = copy_of(curlint->filename);
2801| 					lintstruct *restlint = NULL;
2802| 
2803| 					while (curlint != NULL) {
2804| 						if (strcmp(curlint->filename, dontwantfile) == 0) {
2805| 							if (curlint == lints)
2806| 								lints = curlint->next;
2807| 							else
2808| 								curlint->prev->next = curlint->next;
2809| 							if (curlint->next != NULL)
2810| 								curlint->next->prev = curlint->prev;
2811| 							tmplint = curlint;
2812| 							curlint = curlint->next;
2813| 							free(tmplint->msg);
2814| 							free(tmplint->filename);
2815| 							free(tmplint);
2816| 						} else {
2817| 							if (restlint == NULL)
2818| 								restlint = curlint;
2819| 							curlint = curlint->next;
2820| 						}
2821| 					}
2822| 
2823| 					free(dontwantfile);
2824| 
2825| 					if (restlint == NULL) {
2826| 						statusline(REMARK, _("No messages for this file"));
2827| 						break;
2828| 					} else {
2829| 						curlint = restlint;
2830| 						continue;
2831| 					}
2832| #ifdef ENABLE_MULTIBUFFER
2833| 				}
2834| 			}
2835| #endif
2836| 		}
2837| 
2838| 		if (tmplint != curlint) {
2839| 			/* Put the cursor at the reported position, but don''t go beyond EOL
2840| 			 * when the second number is a column number instead of an index. */
2841| 			goto_line_posx(curlint->lineno, curlint->colno - 1);
2842| 			openfile->current_x = actual_x(openfile->current->data, openfile->placewewant);
2843| 			titlebar(NULL);
2844| 			adjust_viewport(CENTERING);
2845| #ifdef ENABLE_LINENUMBERS
2846| 			confirm_margin();
2847| #endif
2848| 			edit_refresh();
2849| 			statusline(NOTICE, curlint->msg);
2850| 			bottombars(MLINTER);
2851| 		}
2852| 
2853| 		/* Place the cursor to indicate the affected line. */
2854| 		place_the_cursor();
2855| 		wnoutrefresh(midwin);
2856| 
2857| 		kbinput = get_kbinput(footwin, VISIBLE);
2858| 
2859| #ifndef NANO_TINY
2860| 		if (kbinput == KEY_WINCH)
2861| 			continue;
2862| #endif
2863| 		function = func_from_key(kbinput);
2864| 		tmplint = curlint;
2865| 
2866| 		if (function == do_cancel || function == do_enter) {
2867| 			wipe_statusbar();
2868| 			break;
2869| 		} else if (function == do_help) {
2870| 			tmplint = NULL;
2871| 			do_help();
2872| 		} else if (function == do_page_up || function == to_prev_block) {
2873| 			if (curlint->prev != NULL)
2874| 				curlint = curlint->prev;
2875| 			else if (last_wait != time(NULL)) {
2876| 				statusbar(_("At first message"));
2877| 				beep();
2878| 				napms(600);
2879| 				last_wait = time(NULL);
2880| 				statusline(NOTICE, curlint->msg);
2881| 			}
2882| 		} else if (function == do_page_down || function == to_next_block) {
2883| 			if (curlint->next != NULL)
2884| 				curlint = curlint->next;
2885| 			else if (last_wait != time(NULL)) {
2886| 				statusbar(_("At last message"));
2887| 				beep();
2888| 				napms(600);
2889| 				last_wait = time(NULL);
2890| 				statusline(NOTICE, curlint->msg);
2891| 			}
2892| 		} else
2893| 			beep();
2894| 	}
2895| 
2896| 	for (curlint = lints; curlint != NULL;) {
2897| 		tmplint = curlint;
2898| 		curlint = curlint->next;
2899| 		free(tmplint->msg);
2900| 		free(tmplint->filename);
2901| 		free(tmplint);
2902| 	}
2903| 
2904| 	if (helpless) {
2905| 		SET(NO_HELP);
2906| 		window_init();
2907| 		refresh_needed = TRUE;
2908| 	}
2909| 
2910| 	lastmessage = VACUUM;
2911| 	currmenu = MMOST;
2912| 	titlebar(NULL);
2913| #endif
2914| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-7.2/src/text.c:2031: alloc_fn: Storage is returned from allocation function "copy_of".
nano-7.2/src/text.c:2031: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-7.2/src/text.c:2032: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-7.2/src/text.c:2043: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2041|   	(*arguments)[count - 2] = filename;
# 2042|   	(*arguments)[count - 1] = NULL;
# 2043|-> }
# 2044|   #endif
# 2045|
(Example-1) Reason Marked as False Positive:
The leak is entended because this function duplicates and splits the `command` string into an array of strings that will be passed to `execve(2)`.  Nano will then fork.  If the given `execve(2)` calls in its chidren succeed, there is nothing to free and if they fail, `nano` will immediately call `exit(3)`.  Otherwise, `the parent process will correctly free the string regardless of `fork(2)`''s return value.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
nano-5.6.1/src/text.c:2033: alloc_fn: Storage is returned from allocation function "copy_of".
nano-5.6.1/src/text.c:2033: var_assign: Assigning: "copy_of_command" = storage returned from "copy_of(command)".
nano-5.6.1/src/text.c:2034: noescape: Resource "copy_of_command" is not freed or pointed-to in "strtok".
nano-5.6.1/src/text.c:2045: leaked_storage: Variable "copy_of_command" going out of scope leaks the storage it points to.
# 2043|   	(*arguments)[count - 2] = filename;
# 2044|   	(*arguments)[count - 1] = NULL;
# 2045|-> }
# 2046|   
# 2047|   /* Open the specified file, and if that succeeds, remove the text of the marked
(Example-2) Reason Marked as False Positive:
The leak is intended because this function duplicates and splits the `command` string into an array of strings that will be passed to `execve(2)`.  Nano will then fork.  If the given `execve(2)` calls in its children succeed, there is nothing to free and if they fail, `nano` will immediately call `exit(3)`.  Otherwise, `the parent process will correctly free the string regardless of `fork(2)`''s return value.

', '2025-11-17 21:39:06.98398');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (132, 99, 'def1', 'OVERRUN', 'libpng-1.6.40/pngwutil.c:529: assignment: Assigning: "avail_in" = "4294967295U".
libpng-1.6.40/pngwutil.c:536: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail_in". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:580: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  578|   
#  579|            /* Compress the data */
#  580|->          ret = deflate(&png_ptr->zstream,
#  581|                input_len > 0 ? Z_NO_FLUSH : Z_FINISH);
#  582|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/pngwutil.c:529: assignment: Assigning: "avail_in" = "4294967295U".
libpng-1.6.40/pngwutil.c:536: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail_in". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:580: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  578|   
#  579|            /* Compress the data */
#  580|->          ret = deflate(&png_ptr->zstream,
#  581|                input_len > 0 ? Z_NO_FLUSH : Z_FINISH);
#  582|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngwutil.c:529: assignment: Assigning: "avail_in" = "4294967295U".
libpng-1.6.40/pngwutil.c:536: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail_in". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:580: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  578|   
#  579|            /* Compress the data */
#  580|->          ret = deflate(&png_ptr->zstream,
#  581|                input_len > 0 ? Z_NO_FLUSH : Z_FINISH);
#  582|
(Example-1) Reason Marked as False Positive:
False positive but reason wasn''t provided.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngwutil.c:973: assignment: Assigning: "avail" = "4294967295U".
libpng-1.6.40/pngwutil.c:978: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:981: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  979|         input_len -= avail;
#  980|   
#  981|->       ret = deflate(&png_ptr->zstream, input_len > 0 ? Z_NO_FLUSH : flush);
#  982|   
#  983|         /* Include as-yet unconsumed input */
(Example-2) Reason Marked as False Positive:
False positive but reason wasn''t provided.

', '2025-11-17 21:39:06.990491');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (133, 99, 'def2', 'UNINIT', 'libpng-1.6.40/pngrutil.c:1818: var_decl: Declaring variable "readbuf" without initializer.
libpng-1.6.40/pngrutil.c:1913: uninit_use_in_call: Using uninitialized value "*readbuf" when calling "png_set_tRNS".
# 1911|       * png_info.  Fix this.
# 1912|       */
# 1913|->    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
# 1914|          &(png_ptr->trans_color));
# 1915|   }', 'TRUE POSITIVE', 'Unchanged default value indicates a failure in value replacement, confirming the issue''s validity.', 'This is a default value, if it''s not replaced, something went wrong', 'Conduct a thorough code review of `pngrutil.c` to trace all possible execution paths that lead to the `png_set_tRNS` call, focusing on any assignments to `readbuf` before its use.

Analyze the `png_set_tRNS` function to understand the security implications of passing an uninitialized `readbuf`, including potential information leaks or memory corruption.

Verify if there are any compiler flags or configurations that might affect the initialization or behavior of uninitialized variables in the libpng-1.6.40 build process.', 0.0000, '*** Source Code Context ***

code of pngrutil.c file:
1815| void /* PRIVATE */
1816| png_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1817| {
1818|    png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
1819| 
1820|    png_debug(1, "in png_handle_tRNS");
1821| 
1822|    if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
1823|       png_chunk_error(png_ptr, "missing IHDR");
1824| 
1825|    else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
1826|    {
1827|       png_crc_finish(png_ptr, length);
1828|       png_chunk_benign_error(png_ptr, "out of place");
1829|       return;
1830|    }
1831| 
1832|    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)
1833|    {
1834|       png_crc_finish(png_ptr, length);
1835|       png_chunk_benign_error(png_ptr, "duplicate");
1836|       return;
1837|    }
1838| 
1839|    if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
1840|    {
1841|       png_byte buf[2];
1842| 
1843|       if (length != 2)
1844|       {
1845|          png_crc_finish(png_ptr, length);
1846|          png_chunk_benign_error(png_ptr, "invalid");
1847|          return;
1848|       }
1849| 
1850|       png_crc_read(png_ptr, buf, 2);
1851|       png_ptr->num_trans = 1;
1852|       png_ptr->trans_color.gray = png_get_uint_16(buf);
1853|    }
1854| 
1855|    else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
1856|    {
1857|       png_byte buf[6];
1858| 
1859|       if (length != 6)
1860|       {
1861|          png_crc_finish(png_ptr, length);
1862|          png_chunk_benign_error(png_ptr, "invalid");
1863|          return;
1864|       }
1865| 
1866|       png_crc_read(png_ptr, buf, length);
1867|       png_ptr->num_trans = 1;
1868|       png_ptr->trans_color.red = png_get_uint_16(buf);
1869|       png_ptr->trans_color.green = png_get_uint_16(buf + 2);
1870|       png_ptr->trans_color.blue = png_get_uint_16(buf + 4);
1871|    }
1872| 
1873|    else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
1874|    {
1875|       if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)
1876|       {
1877|          /* TODO: is this actually an error in the ISO spec? */
1878|          png_crc_finish(png_ptr, length);
1879|          png_chunk_benign_error(png_ptr, "out of place");
1880|          return;
1881|       }
1882| 
1883|       if (length > (unsigned int) png_ptr->num_palette ||
1884|          length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||
1885|          length == 0)
1886|       {
1887|          png_crc_finish(png_ptr, length);
1888|          png_chunk_benign_error(png_ptr, "invalid");
1889|          return;
1890|       }
1891| 
1892|       png_crc_read(png_ptr, readbuf, length);
1893|       png_ptr->num_trans = (png_uint_16)length;
1894|    }
1895| 
1896|    else
1897|    {
1898|       png_crc_finish(png_ptr, length);
1899|       png_chunk_benign_error(png_ptr, "invalid with alpha channel");
1900|       return;
1901|    }
1902| 
1903|    if (png_crc_finish(png_ptr, 0) != 0)
1904|    {
1905|       png_ptr->num_trans = 0;
1906|       return;
1907|    }
1908| 
1909|    /* TODO: this is a horrible side effect in the palette case because the
1910|     * png_struct ends up with a pointer to the tRNS buffer owned by the
1911|     * png_info.  Fix this.
1912|     */
1913|    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
1914|        &(png_ptr->trans_color));
1915| }


*** Examples ***
', '2025-11-17 21:39:06.990492');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (134, 99, 'def3', 'INTEGER_OVERFLOW', 'libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1362: overflow: The expression "writepos += cb" is deemed underflowed because at least one of its arguments has underflowed.
libpng-1.6.40/contrib/libtests/pngvalid.c:1316: deref_overflow: "writepos++", which might have underflowed, is passed to "ps->new.buffer[writepos++]".
# 1314|            --st;
# 1315|            chunklen = (chunklen << 8) + b;
# 1316|->          ps->new.buffer[writepos++] = b;
# 1317|            ++chunkpos;
# 1318|         }', 'FALSE POSITIVE', 'Decrement operator `--st` at line 1314 is protected from underflow by the enclosing `while (st > 0)` loop (line 1306), ensuring `st` is always greater than 0 before being decremented.', 'The decrement operator `--st` at line 1314 is within a `while (st > 0)` loop (line 1306), ensuring `st` is always greater than 0 before being decremented, preventing underflow.

The assignment `cb = st` at line 1351 is irrelevant to the underflow concern since `st` is proven to be > 0 at all times, as per the while loop condition.

The potential overflow at line 1362 (`writepos += cb`) is deemed underflowed due to `st`, but since `st` cannot underflow (as justified in point 1), this concern is mitigated.

The dereference overflow at line 1316 (`ps->new.buffer[writepos++]`) related to `writepos` is not directly linked to the underflow concern of `st`. However, given `st`''s proven safety, and without evidence of `writepos` exceeding buffer limits within this context, this specific `st`-related underflow concern is addressed.

Direct correlation with provided examples (Example-1 and Example-2) further supports this conclusion, as both highlight the protective nature of the `while (st > 0)` loop against underflow.', NULL, 0.0000, '*** Source Code Context ***

code of contrib/libtests/pngvalid.c file:
1282| static void PNGCBAPI
1283| store_write(png_structp ppIn, png_bytep pb, size_t st)
1284| {
1285|    png_const_structp pp = ppIn;
1286|    png_store *ps = voidcast(png_store*, png_get_io_ptr(pp));
1287|    size_t writepos = ps->writepos;
1288|    png_uint_32 chunkpos = ps->chunkpos;
1289|    png_uint_32 chunktype = ps->chunktype;
1290|    png_uint_32 chunklen = ps->chunklen;
1291| 
1292|    if (ps->pwrite != pp)
1293|       png_error(pp, "store state damaged");
1294| 
1295|    /* Technically this is legal, but in practice libpng never writes more than
1296|     * the maximum chunk size at once so if it happens something weird has
1297|     * changed inside libpng (probably).
1298|     */
1299|    if (st > 0x7fffffffU)
1300|       png_error(pp, "unexpected write size");
1301| 
1302|    /* Now process the bytes to be written.  Do this in units of the space in the
1303|     * output (write) buffer or, at the start 4 bytes for the chunk type and
1304|     * length limited in any case by the amount of data.
1305|     */
1306|    while (st > 0)
1307|    {
1308|       if (writepos >= STORE_BUFFER_SIZE)
1309|          store_storenew(ps), writepos = 0;
1310| 
1311|       if (chunkpos < 4)
1312|       {
1313|          png_byte b = *pb++;
1314|          --st;
1315|          chunklen = (chunklen << 8) + b;
1316|          ps->new.buffer[writepos++] = b;
1317|          ++chunkpos;
1318|       }
1319| 
1320|       else if (chunkpos < 8)
1321|       {
1322|          png_byte b = *pb++;
1323|          --st;
1324|          chunktype = (chunktype << 8) + b;
1325|          ps->new.buffer[writepos++] = b;
1326| 
1327|          if (++chunkpos == 8)
1328|          {
1329|             chunklen &= 0xffffffffU;
1330|             if (chunklen > 0x7fffffffU)
1331|                png_error(pp, "chunk length too great");
1332| 
1333|             chunktype &= 0xffffffffU;
1334|             if (chunktype == CHUNK_IDAT)
1335|             {
1336|                if (chunklen > ~ps->IDAT_size)
1337|                   png_error(pp, "pngvalid internal image too large");
1338| 
1339|                ps->IDAT_size += chunklen;
1340|             }
1341| 
1342|             else if (!valid_chunktype(chunktype))
1343|                png_error(pp, "invalid chunk type");
1344| 
1345|             chunklen += 12; /* for header and CRC */
1346|          }
1347|       }
1348| 
1349|       else /* chunkpos >= 8 */
1350|       {
1351|          size_t cb = st;
1352| 
1353|          if (cb > STORE_BUFFER_SIZE - writepos)
1354|             cb = STORE_BUFFER_SIZE - writepos;
1355| 
1356|          if (cb  > chunklen - chunkpos/* bytes left in chunk*/)
1357|             cb = (size_t)/*SAFE*/(chunklen - chunkpos);
1358| 
1359|          memcpy(ps->new.buffer + writepos, pb, cb);
1360|          chunkpos += (png_uint_32)/*SAFE*/cb;
1361|          pb += cb;
1362|          writepos += cb;
1363|          st -= cb;
1364| 
1365|          if (chunkpos >= chunklen) /* must be equal */
1366|             chunkpos = chunktype = chunklen = 0;
1367|       }
1368|    } /* while (st > 0) */
1369| 
1370|    ps->writepos = writepos;
1371|    ps->chunkpos = chunkpos;
1372|    ps->chunktype = chunktype;
1373|    ps->chunklen = chunklen;
1374| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1362: overflow: The expression "writepos += cb" is deemed underflowed because at least one of its arguments has underflowed.
libpng-1.6.40/contrib/libtests/pngvalid.c:1316: deref_overflow: "writepos++", which might have underflowed, is passed to "ps->new.buffer[writepos++]".
# 1314|            --st;
# 1315|            chunklen = (chunklen << 8) + b;
# 1316|->          ps->new.buffer[writepos++] = b;
# 1317|            ++chunkpos;
# 1318|         }
(Example-1) Reason Marked as False Positive:
st must be >0; see the while condition

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1359: overflow_sink: "cb", which might have underflowed, is passed to "memcpy(ps->new.buffer + writepos, pb, cb)". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1357|               cb = (size_t)/*SAFE*/(chunklen - chunkpos);
# 1358|   
# 1359|->          memcpy(ps->new.buffer + writepos, pb, cb);
# 1360|            chunkpos += (png_uint_32)/*SAFE*/cb;
# 1361|            pb += cb;
(Example-2) Reason Marked as False Positive:
st cannot underflow -> protected by the while condition

', '2025-11-17 21:39:06.990493');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (408, 102, 'def11', 'OVERRUN', 'glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1044: assignment: Assigning: "yystacksize" = "200L".
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1131: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1142: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 8 bytes).
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1158: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 8 bytes.
# 1156|         YY_IGNORE_USELESS_CAST_END
# 1157|   
# 1158|->       if (yyss + yystacksize - 1 <= yyssp)
# 1159|           YYABORT;
# 1160|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1044: assignment: Assigning: "yystacksize" = "200L".
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1131: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1142: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 8 bytes).
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1158: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 8 bytes.
# 1156|         YY_IGNORE_USELESS_CAST_END
# 1157|   
# 1158|->       if (yyss + yystacksize - 1 <= yyssp)
# 1159|           YYABORT;
# 1160|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1044: assignment: Assigning: "yystacksize" = "200L".
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1131: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1142: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 8 bytes).
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1158: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 8 bytes.
# 1156|         YY_IGNORE_USELESS_CAST_END
# 1157|   
# 1158|->       if (yyss + yystacksize - 1 <= yyssp)
# 1159|           YYABORT;
# 1160|       }
(Example-1) Reason Marked as False Positive:
The stack is resized with YYSTACK_ALLOC

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|   	do
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118805');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (135, 99, 'def4', 'OVERRUN', 'libpng-1.6.40/contrib/libtests/pngvalid.c:5055: identity_transfer: Passing field "pi->num_palette" (indirectly, via argument 2) to function "png_get_PLTE", which assigns it to "*npalette".
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_at_least: Checking "i <= 0" implies that "*npalette", "i" and "pi->num_palette" are at least 1 on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_between: Checking "i > 256" implies that "*npalette", "i" and "pi->num_palette" are between 1 and 256 (inclusive) on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5072: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "palette + *npalette". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5070|          * white/opaque which is the flag value stored above.)
# 5071|          */
# 5072|->       memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);
# 5073|      }
# 5074|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/contrib/libtests/pngvalid.c:5055: identity_transfer: Passing field "pi->num_palette" (indirectly, via argument 2) to function "png_get_PLTE", which assigns it to "*npalette".
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_at_least: Checking "i <= 0" implies that "*npalette", "i" and "pi->num_palette" are at least 1 on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_between: Checking "i > 256" implies that "*npalette", "i" and "pi->num_palette" are between 1 and 256 (inclusive) on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5072: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "palette + *npalette".
# 5070|          * white/opaque which is the flag value stored above.)
# 5071|          */
# 5072|->       memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);
# 5073|      }
# 5074|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/contrib/libtests/pngvalid.c:5055: identity_transfer: Passing field "pi->num_palette" (indirectly, via argument 2) to function "png_get_PLTE", which assigns it to "*npalette".
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_at_least: Checking "i <= 0" implies that "*npalette", "i" and "pi->num_palette" are at least 1 on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5059: cond_between: Checking "i > 256" implies that "*npalette", "i" and "pi->num_palette" are between 1 and 256 (inclusive) on the false branch.
libpng-1.6.40/contrib/libtests/pngvalid.c:5072: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "palette + *npalette". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5070|          * white/opaque which is the flag value stored above.)
# 5071|          */
# 5072|->       memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette);
# 5073|      }
# 5074|
(Example-1) Reason Marked as False Positive:
if npalette us 256, then memset writes 0 bytes

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2632: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2662: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
# 2660|         errmsg = "truncated";
# 2661|   
# 2662|->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
# 2663|         errmsg = "unknown compression type";
# 2664|
(Example-2) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

', '2025-11-17 21:39:06.990493');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (136, 99, 'def5', 'OVERRUN', 'libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2632: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2662: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
# 2660|         errmsg = "truncated";
# 2661|   
# 2662|->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
# 2663|         errmsg = "unknown compression type";
# 2664|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/pngrutil.c: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
#         errmsg = "truncated";
#   
#->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
#         errmsg = "unknown compression type";
# ', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2632: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2662: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
# 2660|         errmsg = "truncated";
# 2661|   
# 2662|->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
# 2663|         errmsg = "unknown compression type";
# 2664|
(Example-1) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2673: overrun-buffer-arg: Overrunning dynamic array "png_ptr->read_buffer" by passing it to a function that accesses it at byte "keyword_length + 2U - 1".
# 2671|          * and text chunks.
# 2672|          */
# 2673|->       if (png_decompress_chunk(png_ptr, length, keyword_length+2,
# 2674|             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
# 2675|         {
(Example-2) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

', '2025-11-17 21:39:06.990494');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (137, 99, 'def6', 'OVERRUN', 'libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2673: overrun-buffer-arg: Overrunning dynamic array "png_ptr->read_buffer" by passing it to a function that accesses it at byte "keyword_length + 2U - 1".
# 2671|          * and text chunks.
# 2672|          */
# 2673|->       if (png_decompress_chunk(png_ptr, length, keyword_length+2,
# 2674|             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
# 2675|         {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2673: overrun-buffer-arg: Overrunning dynamic array "png_ptr->read_buffer" by passing it to a function that accesses it at byte "keyword_length + 2U - 1".
# 2671|          * and text chunks.
# 2672|          */
# 2673|->       if (png_decompress_chunk(png_ptr, length, keyword_length+2,
# 2674|             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
# 2675|         {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "png_ptr->read_buffer".
libpng-1.6.40/pngrutil.c:2673: overrun-buffer-arg: Overrunning dynamic array "png_ptr->read_buffer" by passing it to a function that accesses it at byte "keyword_length + 2U - 1".
# 2671|          * and text chunks.
# 2672|          */
# 2673|->       if (png_decompress_chunk(png_ptr, length, keyword_length+2,
# 2674|             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
# 2675|         {
(Example-1) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2632: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2662: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
# 2660|         errmsg = "truncated";
# 2661|   
# 2662|->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
# 2663|         errmsg = "unknown compression type";
# 2664|
(Example-2) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

', '2025-11-17 21:39:06.990494');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (138, 99, 'def7', 'INTEGER_OVERFLOW', 'libpng-1.6.40/contrib/tools/pngfix.c:2984: tainted_data_argument: The value returned in "file_crc" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3068: underflow: The cast of "file_crc >> 24" to a signed type could result in a negative number.
# 3066|               ch = buffer[(++nused) & 7];
# 3067|   
# 3068|->          crc = crc_one_byte(crc, file_crc >> 24);
# 3069|            file_crc = (file_crc << 8) + ch;
# 3070|         }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/contrib/tools/pngfix.c:2984: tainted_data_argument: The value returned in "file_crc" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3068: underflow: The cast of "file_crc >> 24" to a signed type could result in a negative number.
# 3066|               ch = buffer[(++nused) & 7];
# 3067|   
# 3068|->          crc = crc_one_byte(crc, file_crc >> 24);
# 3069|            file_crc = (file_crc << 8) + ch;
# 3070|         }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/tools/pngfix.c:2984: tainted_data_argument: The value returned in "file_crc" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3068: underflow: The cast of "file_crc >> 24" to a signed type could result in a negative number.
# 3066|               ch = buffer[(++nused) & 7];
# 3067|   
# 3068|->          crc = crc_one_byte(crc, file_crc >> 24);
# 3069|            file_crc = (file_crc << 8) + ch;
# 3070|         }
(Example-1) Reason Marked as False Positive:
doesn''t matter, only lower 8 bits are used in crc_ony_byte()

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/tools/pngfix.c:3417: tainted_data_return: The value returned by "reread_byte(file)" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3417: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
libpng-1.6.40/contrib/tools/pngfix.c:3436: underflow: The cast of "b" to a signed type could result in a negative number.
# 3434|                     }
# 3435|   
# 3436|->                   chunk->write_crc = crc_one_byte(chunk->write_crc, b);
# 3437|                     break;
# 3438|
(Example-2) Reason Marked as False Positive:
doesn''t matter, only the lowest 8 bytes of "b" are used by crc_one_byte

', '2025-11-17 21:39:06.990494');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (139, 99, 'def8', 'OVERRUN', 'libpng-1.6.40/png.c:1137: alias: Assigning: "errmsg" = ""duplicate"". "errmsg" now points to byte 0 of ""duplicate"" (which consists of 10 bytes).
libpng-1.6.40/png.c:1165: overrun-buffer-val: Overrunning buffer pointed to by "errmsg" of 10 bytes by passing it to a function which accesses it at byte offset 14.
# 1163|      /* Error exit - errmsg has been set. */
# 1164|      colorspace->flags |= PNG_COLORSPACE_INVALID;
# 1165|->    png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);
# 1166|   }
# 1167|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/png.c:1137: alias: Assigning: "errmsg" = "duplicate". "errmsg" now points to byte 0 of "duplicate" (which consists of 10 bytes).
libpng-1.6.40/png.c:1165: overrun-buffer-val: Overrunning buffer pointed to by "errmsg" of 10 bytes by passing it to a function which accesses it at byte offset 14.
# 1163|      /* Error exit - errmsg has been set. */
# 1164|      colorspace->flags |= PNG_COLORSPACE_INVALID;
# 1165|->    png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);
# 1166|   }
# 1167|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/png.c:1137: alias: Assigning: "errmsg" = ""duplicate"". "errmsg" now points to byte 0 of ""duplicate"" (which consists of 10 bytes).
libpng-1.6.40/png.c:1165: overrun-buffer-val: Overrunning buffer pointed to by "errmsg" of 10 bytes by passing it to a function which accesses it at byte offset 14.
# 1163|      /* Error exit - errmsg has been set. */
# 1164|      colorspace->flags |= PNG_COLORSPACE_INVALID;
# 1165|->    png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);
# 1166|   }
# 1167|
(Example-1) Reason Marked as False Positive:
it may overrun only if the message starts with "#", which is not this case

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2746: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length + 1U + 1" bytes.
libpng-1.6.40/pngrutil.c:2746: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length + 1U, 1)".
libpng-1.6.40/pngrutil.c:2761: symbolic_compare: Tracking "prefix_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2774: symbolic_compare: Tracking "prefix_length + 5U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2777: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "prefix_length".
# 2775|         errmsg = "truncated";
# 2776|   
# 2777|->    else if (buffer[prefix_length+1] == 0 ||
# 2778|         (buffer[prefix_length+1] == 1 &&
# 2779|         buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
(Example-2) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

', '2025-11-17 21:39:06.990494');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (140, 99, 'def9', 'OVERRUN', 'libpng-1.6.40/pngwutil.c:973: assignment: Assigning: "avail" = "4294967295U".
libpng-1.6.40/pngwutil.c:978: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:981: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  979|         input_len -= avail;
#  980|   
#  981|->       ret = deflate(&png_ptr->zstream, input_len > 0 ? Z_NO_FLUSH : flush);
#  982|   
#  983|         /* Include as-yet unconsumed input */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/pngwutil.c:973: assignment: Assigning: "avail" = "4294967295U".
libpng-1.6.40/pngwutil.c:978: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:981: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  979|         input_len -= avail;
#  980|   
#  981|->       ret = deflate(&png_ptr->zstream, input_len > 0 ? Z_NO_FLUSH : flush);
#  982|   
#  983|         /* Include as-yet unconsumed input */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngwutil.c:973: assignment: Assigning: "avail" = "4294967295U".
libpng-1.6.40/pngwutil.c:978: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:981: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  979|         input_len -= avail;
#  980|   
#  981|->       ret = deflate(&png_ptr->zstream, input_len > 0 ? Z_NO_FLUSH : flush);
#  982|   
#  983|         /* Include as-yet unconsumed input */
(Example-1) Reason Marked as False Positive:
False positive but reason wasn''t provided.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngwutil.c:529: assignment: Assigning: "avail_in" = "4294967295U".
libpng-1.6.40/pngwutil.c:536: assignment: Assigning: "png_ptr->zstream.avail_in" = "avail_in". The value of "png_ptr->zstream.avail_in" is now 4294967295.
libpng-1.6.40/pngwutil.c:580: overrun-buffer-arg: Calling "deflate" with "png_ptr->zstream.next_in" and "png_ptr->zstream.avail_in" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  578|   
#  579|            /* Compress the data */
#  580|->          ret = deflate(&png_ptr->zstream,
#  581|                input_len > 0 ? Z_NO_FLUSH : Z_FINISH);
#  582|
(Example-2) Reason Marked as False Positive:
False positive but reason wasn''t provided.

', '2025-11-17 21:39:06.990495');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (141, 99, 'def10', 'INTEGER_OVERFLOW', 'libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1359: overflow_sink: "cb", which might have underflowed, is passed to "memcpy(ps->new.buffer + writepos, pb, cb)". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1357|               cb = (size_t)/*SAFE*/(chunklen - chunkpos);
# 1358|   
# 1359|->          memcpy(ps->new.buffer + writepos, pb, cb);
# 1360|            chunkpos += (png_uint_32)/*SAFE*/cb;
# 1361|            pb += cb;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1359: overflow_sink: "cb", which might have underflowed, is passed to "memcpy(ps->new.buffer + writepos, pb, cb".
# 1357|               cb = (size_t)/*SAFE*/(chunklen - chunkpos);
# 1358|   
# 1359|->          memcpy(ps->new.buffer + writepos, pb, cb);
# 1360|            chunkpos += (png_uint_32)/*SAFE*/cb;
# 1361|            pb += cb;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1359: overflow_sink: "cb", which might have underflowed, is passed to "memcpy(ps->new.buffer + writepos, pb, cb)". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1357|               cb = (size_t)/*SAFE*/(chunklen - chunkpos);
# 1358|   
# 1359|->          memcpy(ps->new.buffer + writepos, pb, cb);
# 1360|            chunkpos += (png_uint_32)/*SAFE*/cb;
# 1361|            pb += cb;
(Example-1) Reason Marked as False Positive:
st cannot underflow -> protected by the while condition

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/libtests/pngvalid.c:1314: underflow: The decrement operator on the unsigned variable "st" might result in an underflow.
libpng-1.6.40/contrib/libtests/pngvalid.c:1351: assign: Assigning: "cb" = "st".
libpng-1.6.40/contrib/libtests/pngvalid.c:1362: overflow: The expression "writepos += cb" is deemed underflowed because at least one of its arguments has underflowed.
libpng-1.6.40/contrib/libtests/pngvalid.c:1316: deref_overflow: "writepos++", which might have underflowed, is passed to "ps->new.buffer[writepos++]".
# 1314|            --st;
# 1315|            chunklen = (chunklen << 8) + b;
# 1316|->          ps->new.buffer[writepos++] = b;
# 1317|            ++chunkpos;
# 1318|         }
(Example-2) Reason Marked as False Positive:
st must be >0; see the while condition

', '2025-11-17 21:39:06.990495');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (142, 99, 'def11', 'INTEGER_OVERFLOW', 'libpng-1.6.40/contrib/tools/pngfix.c:3417: tainted_data_return: The value returned by "reread_byte(file)" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3417: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
libpng-1.6.40/contrib/tools/pngfix.c:3436: underflow: The cast of "b" to a signed type could result in a negative number.
# 3434|                     }
# 3435|   
# 3436|->                   chunk->write_crc = crc_one_byte(chunk->write_crc, b);
# 3437|                     break;
# 3438|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/contrib/tools/pngfix.c: tainted_data_return: The value returned by "reread_byte(file)" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
libpng-1.6.40/contrib/tools/pngfix.c: underflow: The cast of "b" to a signed type could result in a negative number.
# ... (method names and call order match, line numbers ignored)
#->                   chunk->write_crc = crc_one_byte(chunk->write_crc, b);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/tools/pngfix.c:3417: tainted_data_return: The value returned by "reread_byte(file)" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3417: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
libpng-1.6.40/contrib/tools/pngfix.c:3436: underflow: The cast of "b" to a signed type could result in a negative number.
# 3434|                     }
# 3435|   
# 3436|->                   chunk->write_crc = crc_one_byte(chunk->write_crc, b);
# 3437|                     break;
# 3438|
(Example-1) Reason Marked as False Positive:
doesn''t matter, only the lowest 8 bytes of "b" are used by crc_one_byte

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
libpng-1.6.40/contrib/tools/pngfix.c:2984: tainted_data_argument: The value returned in "file_crc" is considered tainted.
libpng-1.6.40/contrib/tools/pngfix.c:3068: underflow: The cast of "file_crc >> 24" to a signed type could result in a negative number.
# 3066|               ch = buffer[(++nused) & 7];
# 3067|   
# 3068|->          crc = crc_one_byte(crc, file_crc >> 24);
# 3069|            file_crc = (file_crc << 8) + ch;
# 3070|         }
(Example-2) Reason Marked as False Positive:
doesn''t matter, only lower 8 bits are used in crc_ony_byte()

', '2025-11-17 21:39:06.990495');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (143, 99, 'def12', 'OVERRUN', 'libpng-1.6.40/pngrutil.c:2746: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length + 1U + 1" bytes.
libpng-1.6.40/pngrutil.c:2746: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length + 1U, 1)".
libpng-1.6.40/pngrutil.c:2761: symbolic_compare: Tracking "prefix_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2774: symbolic_compare: Tracking "prefix_length + 5U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2777: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "prefix_length".
# 2775|         errmsg = "truncated";
# 2776|   
# 2777|->    else if (buffer[prefix_length+1] == 0 ||
# 2778|         (buffer[prefix_length+1] == 1 &&
# 2779|         buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libpng-1.6.40/pngrutil.c: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length + 1U + 1" bytes.
libpng-1.6.40/pngrutil.c: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length + 1U, 1)".
libpng-1.6.40/pngrutil.c: symbolic_compare: Tracking "prefix_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c: symbolic_compare: Tracking "prefix_length + 5U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "prefix_length".
#         errmsg = "truncated";
#   
#->    else if (buffer[prefix_length+1] == 0 ||
#         (buffer[prefix_length+1] == 1 &&
#         buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2746: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length + 1U + 1" bytes.
libpng-1.6.40/pngrutil.c:2746: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length + 1U, 1)".
libpng-1.6.40/pngrutil.c:2761: symbolic_compare: Tracking "prefix_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2774: symbolic_compare: Tracking "prefix_length + 5U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2777: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "prefix_length".
# 2775|         errmsg = "truncated";
# 2776|   
# 2777|->    else if (buffer[prefix_length+1] == 0 ||
# 2778|         (buffer[prefix_length+1] == 1 &&
# 2779|         buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
(Example-1) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libpng-1.6.40/pngrutil.c:2632: buffer_alloc: Calling allocating function "png_read_buffer" which allocates "length" bytes.
libpng-1.6.40/pngrutil.c:2632: var_assign: Assigning: "buffer" = "png_read_buffer(png_ptr, length, 2)".
libpng-1.6.40/pngrutil.c:2647: symbolic_compare: Tracking "keyword_length" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2659: symbolic_compare: Tracking "keyword_length + 3U" since "length" is tracked with "buffer".
libpng-1.6.40/pngrutil.c:2662: overrun-local: Overrunning dynamic array "buffer" at offset corresponding to index variable "keyword_length".
# 2660|         errmsg = "truncated";
# 2661|   
# 2662|->    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
# 2663|         errmsg = "unknown compression type";
# 2664|
(Example-2) Reason Marked as False Positive:
keyword_length is <= 79 and >=1 due to previous if

', '2025-11-17 21:39:06.990496');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (144, 95, 'def1', 'UNINIT', 'libconfig-1.7.3/lib/grammar.c:1110: var_decl: Declaring variable "yylval" without initializer.
libconfig-1.7.3/lib/grammar.c:1802: uninit_use: Using uninitialized value "yylval".
# 1800|   
# 1801|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1802|->   *++yyvsp = yylval;
# 1803|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1804|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libconfig-1.7.3/lib/grammar.c: var_decl: Declaring variable "yylval" without initializer.
libconfig-1.7.3/lib/grammar.c: uninit_use: Using uninitialized value "yylval".
#     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
#->   *++yyvsp = yylval;
#     YY_IGNORE_MAYBE_UNINITIALIZED_END', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libconfig-1.7.3/lib/grammar.c:1110: var_decl: Declaring variable "yylval" without initializer.
libconfig-1.7.3/lib/grammar.c:1802: uninit_use: Using uninitialized value "yylval".
# 1800|   
# 1801|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1802|->   *++yyvsp = yylval;
# 1803|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1804|
(Example-1) Reason Marked as False Positive:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN

', '2025-11-17 21:39:07.004235');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (145, 95, 'def2', 'OVERRUN', 'libconfig-1.7.3/lib/grammar.c:1161: assignment: Assigning: "yystacksize" = "200UL".
libconfig-1.7.3/lib/grammar.c:1214: assignment: Assigning: "yystacksize" *= "2UL". The value of "yystacksize" is now 400.
libconfig-1.7.3/lib/grammar.c:1224: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to element 0 of "yyptr->yyss_alloc" (which consists of 4 2-byte elements).
libconfig-1.7.3/lib/grammar.c:1239: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 798 of an array of 8 bytes.
# 1237|                     (unsigned long int) yystacksize));
# 1238|   
# 1239|->       if (yyss + yystacksize - 1 <= yyssp)
# 1240|           YYABORT;
# 1241|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libconfig-1.7.3/lib/grammar.c: assignment: Assigning: "yystacksize" = "200UL".
libconfig-1.7.3/lib/grammar.c: assignment: Assigning: "yystacksize" *= "2UL". The value of "yystacksize" is now 400.
libconfig-1.7.3/lib/grammar.c: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to element 0 of "yyptr->yyss_alloc" (which consists of 4 2-byte elements).
libconfig-1.7.3/lib/grammar.c: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 798 of an array of 8 bytes.
# ... (matching stack frame)
# 1239|->       if (yyss + yystacksize - 1 <= yyssp)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libconfig-1.7.3/lib/grammar.c:1161: assignment: Assigning: "yystacksize" = "200UL".
libconfig-1.7.3/lib/grammar.c:1214: assignment: Assigning: "yystacksize" *= "2UL". The value of "yystacksize" is now 400.
libconfig-1.7.3/lib/grammar.c:1224: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to element 0 of "yyptr->yyss_alloc" (which consists of 4 2-byte elements).
libconfig-1.7.3/lib/grammar.c:1239: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 798 of an array of 8 bytes.
# 1237|                     (unsigned long int) yystacksize));
# 1238|   
# 1239|->       if (yyss + yystacksize - 1 <= yyssp)
# 1240|           YYABORT;
# 1241|       }
(Example-1) Reason Marked as False Positive:
memory not accessed, just comparing addresses

', '2025-11-17 21:39:07.004237');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (146, 113, 'def1', 'BUFFER_SIZE', 'unzip60/envargs.c:121: overlapping_buffer: The source buffer "argstart + 1" potentially overlaps with the destination buffer "argstart", which results in undefined behavior for "strcpy".
unzip60/envargs.c:121: remediation: Replace "strcpy(dest, src)" with "memmove(dest, src, strlen(src)+1)".
#  119|               /* remove escape characters */
#  120|               while ((argstart = MBSCHR(argstart, ''\\'')) != (char *)NULL) {
#  121|->                 strcpy(argstart, argstart + 1);
#  122|                   if (*argstart)
#  123|                       ++argstart;', 'TRUE POSITIVE', 'The `strcpy` call at `unzip60/envargs.c:121` inherently introduces undefined behavior due to overlapping source (`argstart + 1`) and destination (`argstart`) buffers, as explicitly warned against in the C standard (C11 7.24.2.3p2), with no mitigating implementation provided in the given code context.', 'The CVE report specifically highlights the line `strcpy(argstart, argstart + 1)` at `unzip60/envargs.c:121` as the source of the vulnerability.

The `strcpy` function is used with overlapping buffers: the source buffer is `argstart + 1` and the destination buffer is `argstart`. This is explicitly stated in the CVE report and can be verified in the provided code snippet.

According to the C standard, `strcpy` does not handle overlapping buffers, leading to undefined behavior in such cases (C11 7.24.2.3p2).

The provided code snippet does not include any implementation of `strcpy` that would suggest a deviation from the standard library behavior. Thus, we must assume standard `strcpy` behavior.

The loop at lines 119-123 iterates until no more backslashes (`''\''`) are found in the string, starting from `argstart`. This implies that `argstart` is a valid, non-NULL pointer to a character within a string, making the `strcpy` call potentially overlapping when copying from `argstart + 1` to `argstart`.

The suggested remediation to replace `strcpy` with `memmove` (which is safe for overlapping buffers) further supports the conclusion that the original code is vulnerable to undefined behavior due to overlapping buffers.

Given the direct correlation between the code''s behavior and the vulnerability described in the CVE, and without any evidence in the provided code that would mitigate this vulnerability, the finding cannot be considered a FALSE POSITIVE.', NULL, 0.0000, '*** Source Code Context ***

code of envargs.c file:
49| int envargs(Pargc, Pargv, envstr, envstr2)
50|     int *Pargc;
51|     char ***Pargv;
52|     ZCONST char *envstr, *envstr2;
53| {
54|     char *envptr;       /* value returned by getenv */
55|     char *bufptr;       /* copy of env info */
56|     int argc = 0;       /* internal arg count */
57|     register int ch;    /* spare temp value */
58|     char **argv;        /* internal arg vector */
59|     char **argvect;     /* copy of vector address */
60| 
61|     /* see if anything in the environment */
62|     if ((envptr = getenv(envstr)) != (char *)NULL)        /* usual var */
63|         while (ISspace(*envptr))        /* must discard leading spaces */
64|             envptr++;
65|     if (envptr == (char *)NULL || *envptr == ''\0'')
66|         if ((envptr = getenv(envstr2)) != (char *)NULL)   /* alternate var */
67|             while (ISspace(*envptr))
68|                 envptr++;
69|     if (envptr == (char *)NULL || *envptr == ''\0'')
70|         return PK_OK;
71| 
72|     bufptr = malloc(1 + strlen(envptr));
73|     if (bufptr == (char *)NULL)
74|         return PK_MEM;
75| #if ((defined(WIN32) || defined(WINDLL)) && !defined(_WIN32_WCE))
76| # ifdef WIN32
77|     if (IsWinNT()) {
78|         /* SPC: don''t know codepage of ''real'' WinNT console */
79|         strcpy(bufptr, envptr);
80|     } else {
81|         /* Win95 environment is DOS and uses OEM character coding */
82|         OEM_TO_INTERN(envptr, bufptr);
83|     }
84| # else /* !WIN32 */
85|     /* DOS (Win 3.x) environment uses OEM codepage */
86|     OEM_TO_INTERN(envptr, bufptr);
87| # endif
88| #else /* !((WIN32 || WINDLL) && !_WIN32_WCE) */
89|     strcpy(bufptr, envptr);
90| #endif /* ?((WIN32 || WINDLL) && !_WIN32_WCE) */
91| 
92|     /* count the args so we can allocate room for them */
93|     argc = count_args(bufptr);
94|     /* allocate a vector large enough for all args */
95|     argv = (char **)malloc((argc + *Pargc + 1) * sizeof(char *));
96|     if (argv == (char **)NULL) {
97|         free(bufptr);
98|         return PK_MEM;
99|     }
100|     argvect = argv;
101| 
102|     /* copy the program name first, that''s always true */
103|     *(argv++) = *((*Pargv)++);
104| 
105|     /* copy the environment args next, may be changed */
106|     do {
107| #if defined(AMIGA) || defined(UNIX)
108|         if (*bufptr == ''"'') {
109|             char *argstart = ++bufptr;
110| 
111|             *(argv++) = argstart;
112|             for (ch = *bufptr; ch != ''\0'' && ch != ''\"'';
113|                  ch = *PREINCSTR(bufptr))
114|                 if (ch == ''\\'' && bufptr[1] != ''\0'')
115|                     ++bufptr;           /* advance to char after backslash */
116|             if (ch != ''\0'')
117|                 *(bufptr++) = ''\0'';     /* overwrite trailing " */
118| 
119|             /* remove escape characters */
120|             while ((argstart = MBSCHR(argstart, ''\\'')) != (char *)NULL) {
121|                 strcpy(argstart, argstart + 1);
122|                 if (*argstart)
123|                     ++argstart;
124|             }
125|         } else {
126|             *(argv++) = bufptr;
127|             while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
128|                 INCSTR(bufptr);
129|             if (ch != ''\0'')
130|                 *(bufptr++) = ''\0'';
131|         }
132| #else
133| #ifdef DOS_FLX_NLM_OS2_W32
134|         /* we do not support backslash-quoting of quotes in quoted
135|          * strings under DOS_FLX_NLM_OS2_W32, because backslashes are
136|          * directory separators and double quotes are illegal in filenames */
137|         if (*bufptr == ''"'') {
138|             *(argv++) = ++bufptr;
139|             while ((ch = *bufptr) != ''\0'' && ch != ''\"'')
140|                 INCSTR(bufptr);
141|             if (ch != ''\0'')
142|                 *(bufptr++) = ''\0'';
143|         } else {
144|             *(argv++) = bufptr;
145|             while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
146|                 INCSTR(bufptr);
147|             if (ch != ''\0'')
148|                 *(bufptr++) = ''\0'';
149|         }
150| #else
151|         *(argv++) = bufptr;
152|         while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
153|             INCSTR(bufptr);
154|         if (ch != ''\0'')
155|             *(bufptr++) = ''\0'';
156| #endif /* ?DOS_FLX_NLM_OS2_W32 */
157| #endif /* ?(AMIGA || UNIX) */
158|         while ((ch = *bufptr) != ''\0'' && ISspace(ch))
159|             INCSTR(bufptr);
160|     } while (ch);
161| 
162|     /* now save old argc and copy in the old args */
163|     argc += *Pargc;
164|     while (--(*Pargc))
165|         *(argv++) = *((*Pargv)++);
166| 
167|     /* finally, add a NULL after the last arg, like Unix */
168|     *argv = (char *)NULL;
169| 
170|     /* save the values and return, indicating succes */
171|     *Pargv = argvect;
172|     *Pargc = argc;
173| 
174|     return PK_OK;
175| }


*** Examples ***
', '2025-11-17 21:39:07.010108');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (147, 113, 'def2', 'OVERRUN', 'unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1628: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1626|     if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|->   c[i] += y;
# 1629|   
# 1630|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1628: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1626|     if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|->   c[i] += y;
# 1629|   
# 1630|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1628: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1626|     if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|->   c[i] += y;
# 1629|   
# 1630|
(Example-1) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;
(Example-2) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

', '2025-11-17 21:39:07.010112');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (148, 113, 'def3', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010113');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (149, 113, 'def4', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "w++", which might have underflowed, is passed to "G.area.Slide[w++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)', 'TRUE POSITIVE', 'Tainted data from `readbyte()` is used in unsigned contexts without explicit sanitization (line 406), potentially leading to unexpected behavior, underflows (lines 414, 418, 420, 444), and dereferencing issues (line 464), with no clear guarantees of safety across all execution paths.', '1. **Tainted Data Usage**: The value returned by `readbyte()` is considered tainted (unzip60/explode.c:406). This indicates potential user-controlled input, which, if not properly sanitized, can lead to security vulnerabilities.

2. **Signed to Unsigned Conversion**: The expression `(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k` might treat a negative value as unsigned (unzip60/explode.c:406). This could potentially lead to unexpected behavior if the tainted data is crafted to exploit this conversion.

3. **Potential Underflow**: Multiple expressions are deemed underflowed because at least one of their arguments has underflowed (e.g., unzip60/explode.c:414, 418, 420, 444). While the code might be designed to handle these underflows, without explicit proof of safety in all execution paths, this remains a concern.

4. **Assignment and Usage of Potentially Underflowed Value**: The value `d` is assigned from an expression deemed underflowed (`(unsigned int)b & mdl`, unzip60/explode.c:420) and later used in critical operations (e.g., `d &= 0xffffL`, `65536L - (((d &= 0xffffL) > w) ? d : w)`). This could lead to incorrect program behavior if `d` is not within expected bounds.

5. **Cast Overflow Risk**: An assignment with a cast to a different type might trigger an overflow (unzip60/explode.c:444), which, combined with the use of potentially tainted and underflowed values, increases the risk of a vulnerability.

6. **Dereference with Potentially Underflowed Index**: `w++`, which might have underflowed, is used to index `G.area.Slide[w++]` (unzip60/explode.c:464). If `w` is not validated to be within bounds, this could lead to a buffer overflow or underflow, potentially allowing arbitrary code execution or information disclosure.

7. **Lack of Explicit Safety Guarantees**: Given the complexity of the operations and the involvement of potentially tainted data, without explicit checks or documentation ensuring the safety of all execution paths, the risk of a vulnerability cannot be ruled out.', 'Investigate the nature and constraints of the `readbyte()` function to determine the feasibility of tainted data exploitation.

Verify the intent and safety of the signed to unsigned conversion in the specific context of the `explode.c` functionality.

Analyze the bit operations (e.g., shifts, masking) to understand if they are designed to prevent or mitigate underflow/overflow conditions.

Examine the calling code and documentation for `G.area.Slide` and `flush` functions to assess the validity of the dereference and overflow concerns.', 0.0000, '*** Source Code Context ***

code of explode.c file:
371| static int explode_nolit(__G__ tl, td, bl, bd, bdl)
372|      __GDEF
373| struct huft *tl, *td;   /* length and distance decoder tables */
374| unsigned bl, bd;        /* number of bits decoded by tl[] and td[] */
375| unsigned bdl;           /* number of distance low bits */
376| /* Decompress the imploded data using uncoded literals and a sliding
377|    window (of size 2^(6+bdl) bytes). */
378| {
379|   zusz_t s;             /* bytes to decompress */
380|   register unsigned e;  /* table entry flag/number of extra bits */
381|   unsigned n, d;        /* length and index for copy */
382|   unsigned w;           /* current window position */
383|   struct huft *t;       /* pointer to table entry */
384|   unsigned ml, md;      /* masks for bl and bd bits */
385|   unsigned mdl;         /* mask for bdl (distance lower) bits */
386|   register ulg b;       /* bit buffer */
387|   register unsigned k;  /* number of bits in bit buffer */
388|   unsigned u;           /* true if unflushed */
389|   int retval = 0;       /* error code returned: initialized to "no error" */
390| 
391| 
392|   /* explode the coded data */
393|   b = k = w = 0;                /* initialize bit buffer, window */
394|   u = 1;                        /* buffer unflushed */
395|   ml = mask_bits[bl];           /* precompute masks for speed */
396|   md = mask_bits[bd];
397|   mdl = mask_bits[bdl];
398|   s = G.lrec.ucsize;
399|   while (s > 0)                 /* do until ucsize bytes uncompressed */
400|   {
401|     NEEDBITS(1)
402|     if (b & 1)                  /* then literal--get eight bits */
403|     {
404|       DUMPBITS(1)
405|       s--;
406|       NEEDBITS(8)
407|       redirSlide[w++] = (uch)b;
408|       if (w == wszimpl)
409|       {
410|         if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
411|           return retval;
412|         w = u = 0;
413|       }
414|       DUMPBITS(8)
415|     }
416|     else                        /* else distance/length */
417|     {
418|       DUMPBITS(1)
419|       NEEDBITS(bdl)             /* get distance low bits */
420|       d = (unsigned)b & mdl;
421|       DUMPBITS(bdl)
422|       DECODEHUFT(td, bd, md)    /* get coded distance high bits */
423|       d = w - d - t->v.n;       /* construct offset */
424|       DECODEHUFT(tl, bl, ml)    /* get coded length */
425|       n = t->v.n;
426|       if (e)                    /* get length extra bits */
427|       {
428|         NEEDBITS(8)
429|         n += (unsigned)b & 0xff;
430|         DUMPBITS(8)
431|       }
432| 
433|       /* do the copy */
434|       s = (s > (zusz_t)n ? s - (zusz_t)n : 0);
435|       do {
436| #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
437|         if (G.redirect_slide) {
438|           /* &= w/ wszimpl not needed and wrong if redirect */
439|           if (d >= wszimpl)
440|             return 1;
441|           e = wszimpl - (d > w ? d : w);
442|         } else
443| #endif
444|           e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
445|         if (e > n) e = n;
446|         n -= e;
447|         if (u && w <= d)
448|         {
449|           memzero(redirSlide + w, e);
450|           w += e;
451|           d += e;
452|         }
453|         else
454| #ifndef NOMEMCPY
455|           if (w - d >= e)       /* (this test assumes unsigned comparison) */
456|           {
457|             memcpy(redirSlide + w, redirSlide + d, e);
458|             w += e;
459|             d += e;
460|           }
461|           else                  /* do it slow to avoid memcpy() overlap */
462| #endif /* !NOMEMCPY */
463|             do {
464|               redirSlide[w++] = redirSlide[d++];
465|             } while (--e);
466|         if (w == wszimpl)
467|         {
468|           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
469|             return retval;
470|           w = u = 0;
471|         }
472|       } while (n);
473|     }
474|   }
475| 
476|   /* flush out redirSlide */
477|   if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
478|     return retval;
479|   if (G.csize + G.incnt + (k >> 3))   /* should have read csize bytes, but */
480|   {                        /* sometimes read one too many:  k>>3 compensates */
481|     G.used_csize = G.lrec.csize - G.csize - G.incnt - (k >> 3);
482|     return 5;
483|   }
484|   return 0;
485| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010113');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (150, 113, 'def5', 'OVERRUN', 'unzip60/inflate.c:977: cond_at_most: Checking "e < 31U" implies that "e" and "t->e" may be up to 30 on the true branch.
unzip60/inflate.c:981: overrun-local: Overrunning array "mask_bits" of 17 4-byte elements at element index 30 (byte offset 123) using index "e" (which evaluates to 30).
#  979|           /* get length of block to copy */
#  980|           NEEDBITS(e)
#  981|->         n = t->v.n + ((unsigned)b & mask_bits[e]);
#  982|           DUMPBITS(e)
#  983|', 'TRUE POSITIVE', 'Accessing `mask_bits[30]` at line 981 exceeds the array''s bounds (valid indices 0-16), directly correlating with CWE-119: Buffer Overflow, as `e < 31U` (line 977) does not prevent `e` from being 30.', 'The CVE report explicitly states an `overrun-local` error at line 981, indicating an array index out-of-bounds access.

The condition `e < 31U` at line 977 only ensures `e` is less than 31, but does not prevent `e` from being exactly 30.

At line 981, the index `e` is used to access `mask_bits[e]`, with the report specifying that `e` evaluates to 30.

The `mask_bits` array is described as having 17 4-byte elements, meaning its valid indices are 0 through 16.

Accessing `mask_bits[30]` exceeds the array''s bounds (since 30 is beyond the last valid index of 16), directly correlating with the described vulnerability (CWE-119: Buffer Overflow).

No explicit bounds checking or handling is shown in the provided code to prevent this out-of-bounds access when `e` is 30.

Uncertainty about the broader system or environment does not mitigate the explicit vulnerability shown in the provided code snippet.', NULL, 0.0000, '*** Source Code Context ***

code of inflate.c file:
977|       if (e < 31)               /* then it''s a length */

981|         n = t->v.n + ((unsigned)b & mask_bits[e]);


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1624: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
# 1622|     /* Adjust last length count to fill out codes, if needed */
# 1623|     for (y = 1 << j; j < i; j++, y <<= 1)
# 1624|->     if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|     if ((y -= c[i]) < 0)
(Example-1) Reason Marked as False Positive:
i is between 1 and BMAX, line 1623 checks that j < i, array C is of the size BMAX+1

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;
(Example-2) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

', '2025-11-17 21:39:07.010114');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (151, 113, 'def6', 'OVERRUN', 'unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1624: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
# 1622|     /* Adjust last length count to fill out codes, if needed */
# 1623|     for (y = 1 << j; j < i; j++, y <<= 1)
# 1624|->     if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|     if ((y -= c[i]) < 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1624: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
# 1622|     /* Adjust last length count to fill out codes, if needed */
# 1623|     for (y = 1 << j; j < i; j++, y <<= 1)
# 1624|->     if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|     if ((y -= c[i]) < 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1624: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
# 1622|     /* Adjust last length count to fill out codes, if needed */
# 1623|     for (y = 1 << j; j < i; j++, y <<= 1)
# 1624|->     if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|     if ((y -= c[i]) < 0)
(Example-1) Reason Marked as False Positive:
i is between 1 and BMAX, line 1623 checks that j < i, array C is of the size BMAX+1

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;
(Example-2) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

', '2025-11-17 21:39:07.010114');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (152, 113, 'def7', 'COMPILER_WARNING', 'unzip60/unzpriv.h:2728:53: warning[-Wformat-overflow=]: %s directive writing up to 74535 bytes into a region of size 65528
# 2728 |        (*G.message)((zvoid *)&G, (uch *)(buf), (ulg)sprintf sprf_arg, (flag))
/usr/include/bits/stdio2.h:30:10: note: __sprintf_chk output between 10 and 74545 bytes into a destination of size 65536
#   30 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
#      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   31 |                                   __glibc_objsize (__s), __fmt,
#      |                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   32 |                                   __va_arg_pack ());
#      |                                   ~~~~~~~~~~~~~~~~~
# 2726|   #    ifdef INT_SPRINTF  /* optimized version for "int sprintf()" flavour */
# 2727|   #      define Info(buf,flag,sprf_arg) \
# 2728|->        (*G.message)((zvoid *)&G, (uch *)(buf), (ulg)sprintf sprf_arg, (flag))
# 2729|   #    else          /* generic version, does not use sprintf() return value */
# 2730|   #      define Info(buf,flag,sprf_arg) \', 'TRUE POSITIVE', 'Direct buffer overflow risk exists at `unzip60/unzpriv.h:2728:53` due to `sprintf` potentially writing up to 74535 bytes into a 65528-byte buffer, with no explicit bounds checking in the provided `Info` macro''s `INT_SPRINTF` branch.', '**Direct Buffer Overflow Risk**: The warning at `unzip60/unzpriv.h:2728:53` indicates a potential format overflow, where `sprintf` may write up to **74535 bytes** into a buffer of size **65528** (as per the note in `/usr/include/bits/stdio2.h:30:10`, the actual buffer size is **65536**, but the difference doesn''t negate the overflow risk). This discrepancy poses a clear buffer overflow risk.

**Explicit Vulnerable Path Identified** (Line 2728)**: The `Info` macro, when defined with `INT_SPRINTF`, directly invokes `sprintf` with a variable argument list (`sprf_arg`) without explicitly checking the buffer''s capacity against the potential output size of `sprintf`. This lack of bounds checking creates a vulnerable execution path.

**Unclear Buffer Size Validation** (Lines 2726-2730)**: The provided code snippet does not explicitly show any buffer size validation that would prevent the overflow for the `sprintf` operation within the `Info` macro''s `INT_SPRINTF` branch. The absence of clear, preventative measures against buffer overflow in the provided context supports the TRUE POSITIVE finding.

**Dependency on External Buffer Size** (Implicit in `/usr/include/bits/stdio2.h:30:10`)**: The buffer size (**65536**) is noted in an external include, not within the provided `unzpriv.h` code. This external dependency doesn''t negate the vulnerability but highlights that the issue''s resolution may involve ensuring alignment with external buffer size expectations.

**Syntax and Warning Alignment** (Lines 2728 and `/usr/include/bits/stdio2.h:30:10`)**: The warning directly correlates with the syntax used in the `Info` macro, specifically the `sprintf` call without explicit output size limitation, reinforcing the TRUE POSITIVE conclusion.', 'Examine the allocation and sizing logic for the buffer `buf` to confirm its actual size in the context of `unzpriv.h`.

Verify if any implicit or explicit buffer size validations or mitigations exist in the surrounding code or in the `G.message` function that could prevent the buffer overflow.

Investigate if compiler flags or project settings might influence the behavior of `sprintf` or the reported buffer sizes.', 0.0000, '*** Source Code Context ***

code of unzpriv.h file:
2628| #endif
2629| #ifdef SET_SYMLINK_ATTRIBS
2630|    int  set_symlnk_attribs  OF((__GPRO__ slinkentry *slnk_entry));  /* local */
2631| #endif
2632| #ifdef SET_DIR_ATTRIB
2633|    int   defer_dir_attribs  OF((__GPRO__ direntry **pd));           /* local */
2634|    int   set_direc_attribs  OF((__GPRO__ direntry *d));             /* local */
2635| #endif
2636| #ifdef TIMESTAMP
2637| # ifdef WIN32
2638|    int   stamp_file      OF((__GPRO__
2639|                              ZCONST char *fname, time_t modtime));  /* local */
2640| # else
2641|    int   stamp_file      OF((ZCONST char *fname, time_t modtime));  /* local */
2642| # endif
2643| #endif
2644| #ifdef NEED_ISO_OEM_INIT
2645|    void  prepare_ISO_OEM_translat   OF((__GPRO));                   /* local */
2646| #endif
2647| #if (defined(MALLOC_WORK) && defined(MY_ZCALLOC))
2648|    zvoid far *zcalloc    OF((unsigned int, unsigned int));
2649|    zvoid zcfree          OF((zvoid far *));
2650| #endif /* MALLOC_WORK && MY_ZCALLOC */
2651| #ifdef SYSTEM_SPECIFIC_CTOR
2652|    void  SYSTEM_SPECIFIC_CTOR   OF((__GPRO));                       /* local */
2653| #endif
2654| #ifdef SYSTEM_SPECIFIC_DTOR
2655|    void  SYSTEM_SPECIFIC_DTOR   OF((__GPRO));                       /* local */
2656| #endif
2657| 
2658| 
2659| 
2660| 
2661| 
2662| /************/
2663| /*  Macros  */
2664| /************/
2665| 
2666| #ifndef MAX
2667| #  define MAX(a,b)   ((a) > (b) ? (a) : (b))
2668| #endif
2669| #ifndef MIN
2670| #  define MIN(a,b)   ((a) < (b) ? (a) : (b))
2671| #endif
2672| 
2673| #ifdef DEBUG
2674| #  if (defined(THEOS) && defined(NO_BOGUS_SPC))
2675| #    define NO_DEBUG_IN_MACROS
2676| #    define Trace(x)   _fprintf x
2677| #  else
2678| #    define Trace(x)   fprintf x
2679| #  endif
2680| #else
2681| #  define Trace(x)
2682| #endif
2683| 
2684| #ifdef DEBUG_TIME
2685| #  define TTrace(x)  fprintf x
2686| #else
2687| #  define TTrace(x)
2688| #endif
2689| 
2690| #ifdef NO_DEBUG_IN_MACROS
2691| #  define MTrace(x)
2692| #else
2693| #  define MTrace(x)  Trace(x)
2694| #endif
2695| 
2696| #if (defined(UNIX) || defined(T20_VMS)) /* generally old systems */
2697| #  define ToLower(x)   ((char)(isupper((int)x)? tolower((int)x) : x))
2698| #else
2699| #  define ToLower      tolower          /* assumed "smart"; used in match() */
2700| #endif
2701| 
2702| #ifdef USE_STRM_INPUT
2703|    /* ``Replace'''' the unbuffered UNIX style I/O function with similar
2704|     * standard C functions from <stdio.h>.
2705|     */
2706| #  define read(fd,buf,n) fread((buf),1,(n),(FILE *)(fd))
2707| #  ifdef zlseek
2708| #    undef zlseek
2709| #  endif
2710| #  define zlseek(fd,o,w) zfseeko((FILE *)(fd),(o),(w))
2711| #  define close(fd) fclose((FILE *)(fd))
2712| #endif /* USE_STRM_INPUT */
2713| 
2714| /* The return value of the Info() "macro function" is never checked in
2715|  * UnZip. Otherwise, to get the same behaviour as for (*G.message)(), the
2716|  * Info() definition for "FUNZIP" would have to be corrected:
2717|  * #define Info(buf,flag,sprf_arg) \
2718|  *      (fputs((char *)(sprintf sprf_arg, (buf)), \
2719|  *             (flag)&1? stderr : stdout) < 0)
2720|  */
2721| #ifndef Info   /* may already have been defined for redirection */
2722| #  ifdef FUNZIP
2723| #    define Info(buf,flag,sprf_arg) \
2724|      fputs((char *)(sprintf sprf_arg, (buf)), (flag)&1? stderr : stdout)
2725| #  else
2726| #    ifdef INT_SPRINTF  /* optimized version for "int sprintf()" flavour */
2727| #      define Info(buf,flag,sprf_arg) \
2728|        (*G.message)((zvoid *)&G, (uch *)(buf), (ulg)sprintf sprf_arg, (flag))
2729| #    else          /* generic version, does not use sprintf() return value */
2730| #      define Info(buf,flag,sprf_arg) \
2731|        (*G.message)((zvoid *)&G, (uch *)(buf), \
2732|                      (ulg)(sprintf sprf_arg, strlen((char *)(buf))), (flag))
2733| #    endif
2734| #  endif
2735| #endif /* !Info */
2736| 
2737| /*  This wrapper macro around fzofft() is just defined to "hide" the
2738|  *  argument needed to reference the global storage buffers.
2739|  */
2740| #define FmZofft(val, pre, post) fzofft(__G__ val, pre, post)
2741| 
2742| /*  The following macro wrappers around the fnfilter function are used many
2743|  *  times to prepare archive entry names or name components for displaying
2744|  *  listings and (warning/error) messages. They use sections in the upper half
2745|  *  of ''slide'' as buffer, since their output is normally fed through the
2746|  *  Info() macro with ''slide'' (the start of this area) as message buffer.
2747|  */
2748| #define FnFilter1(fname) \
2749|         fnfilter((fname), slide + (extent)(WSIZE>>1), (extent)(WSIZE>>2))
2750| #define FnFilter2(fname) \
2751|         fnfilter((fname), slide + (extent)((WSIZE>>1) + (WSIZE>>2)),\
2752|                  (extent)(WSIZE>>2))
2753| 
2754| #ifndef FUNZIP   /* used only in inflate.c */
2755| #  define MESSAGE(str,len,flag)  (*G.message)((zvoid *)&G,(str),(len),(flag))
2756| #endif
2757| 
2758| #if 0            /* Optimization: use the (const) result of crc32(0L,NULL,0) */
2759| #  define CRCVAL_INITIAL  crc32(0L, NULL, 0)
2760| #else
2761| #  define CRCVAL_INITIAL  0L
2762| #endif
2763| 
2764| #ifdef SYMLINKS
2765|    /* This macro defines the Zip "made by" hosts that are considered
2766|       to support storing symbolic link entries. */
2767| #  define SYMLINK_HOST(hn) ((hn) == UNIX_ || (hn) == ATARI_ || \
2768|       (hn) == ATHEOS_ || (hn) == BEOS_ || (hn) == VMS_)
2769| #endif
2770| 
2771| #ifndef TEST_NTSD               /* "NTSD valid?" checking function */
2772| #  define TEST_NTSD     NULL    /*   ... is not available */
2773| #endif
2774| 
2775| #define SKIP_(length) if(length&&((error=do_string(__G__ length,SKIP))!=0))\
2776|   {error_in_archive=error; if(error>1) return error;}
2777| 
2778| /*
2779|  *  Skip a variable-length field, and report any errors.  Used in zipinfo.c
2780|  *  and unzip.c in several functions.
2781|  *
2782|  *  macro SKIP_(length)
2783|  *      ush length;
2784|  *  {
2785|  *      if (length && ((error = do_string(length, SKIP)) != 0)) {
2786|  *          error_in_archive = error;   /-* might be warning *-/
2787|  *          if (error > 1)              /-* fatal *-/
2788|  *              return (error);
2789|  *      }
2790|  *  }
2791|  *
2792|  */
2793| 
2794| 
2795| #ifdef FUNZIP
2796| #  define FLUSH(w)  flush(__G__ (ulg)(w))
2797| #  define NEXTBYTE  getc(G.in)   /* redefined in crypt.h if full version */
2798| #else
2799| #  define FLUSH(w)  ((G.mem_mode) ? memflush(__G__ redirSlide,(ulg)(w)) \
2800|                                   : flush(__G__ redirSlide,(ulg)(w),0))
2801| #  define NEXTBYTE  (G.incnt-- > 0 ? (int)(*G.inptr++) : readbyte(__G))
2802| #endif
2803| 
2804| 
2805| #define READBITS(nbits,zdest) {if(nbits>G.bits_left) {int temp; G.zipeof=1;\
2806|   while (G.bits_left<=8*(int)(sizeof(G.bitbuf)-1) && (temp=NEXTBYTE)!=EOF) {\
2807|   G.bitbuf|=(ulg)temp<<G.bits_left; G.bits_left+=8; G.zipeof=0;}}\
2808|   zdest=(shrint)((unsigned)G.bitbuf&mask_bits[nbits]);G.bitbuf>>=nbits;\
2809|   G.bits_left-=nbits;}
2810| 
2811| /*
2812|  * macro READBITS(nbits,zdest)    * only used by unreduce and unshrink *
2813|  *  {
2814|  *      if (nbits > G.bits_left) {  * fill G.bitbuf, 8*sizeof(ulg) bits *
2815|  *          int temp;
2816|  *
2817|  *          G.zipeof = 1;
2818|  *          while (G.bits_left <= 8*(int)(sizeof(G.bitbuf)-1) &&
2819|  *                 (temp = NEXTBYTE) != EOF) {
2820|  *              G.bitbuf |= (ulg)temp << G.bits_left;
2821|  *              G.bits_left += 8;
2822|  *              G.zipeof = 0;
2823|  *          }
2824|  *      }
2825|  *      zdest = (shrint)((unsigned)G.bitbuf & mask_bits[nbits]);
2826|  *      G.bitbuf >>= nbits;
2827|  *      G.bits_left -= nbits;
2828|  *  }


*** Examples ***
', '2025-11-17 21:39:07.010114');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (154, 113, 'def9', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:407: deref_overflow: "w++", which might have underflowed, is passed to "G.area.Slide[w++]".
#  405|         s--;
#  406|         NEEDBITS(8)
#  407|->       redirSlide[w++] = (uch)b;
#  408|         if (w == wszimpl)
#  409|         {', 'TRUE POSITIVE', 'Tainted data from `readbyte()` is used without validation (line 406), combined with potential signed-to-unsigned conversion issues and underflow in bitwise/arithmetic operations (lines 406, 414, 418, 420, 444, 450), and dereferencing with possible underflow (line 407), all without explicit safety guarantees in the provided code.', '1. **Tainted Data Usage**: The value returned by `readbyte()` is considered tainted (line 406). This indicates a potential security issue, as untrusted data is being used without proper sanitization or validation.

2. **Signed-to-Unsigned Conversion**: The expression `(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k` might treat a negative value as unsigned (line 406). This could lead to unexpected behavior if the result of `readbyte()` or the dereferenced `*G.inptr++` is negative, potentially causing an integer overflow when assigned to an unsigned variable.

3. **Potential Underflow**: Multiple expressions (lines 414, 418, 420, 444, and 450) are deemed underflowed because at least one of their arguments has underflowed. While the code uses unsigned types, which wrap around on underflow, this behavior can still lead to unexpected results, especially in the context of bit shifting and arithmetic operations.

4. **Dereference with Potential Underflow**: The variable `w++`, which might have underflowed, is passed to `G.area.Slide[w++]` (line 407). If `w` has indeed underflowed (wrapped around due to being an unsigned type), this could result in accessing an unintended index in the `G.area.Slide` array, potentially leading to a buffer overflow or out-of-bounds access.

5. **Lack of Explicit Safety Guarantees**: Within the provided code snippet, there are no explicit checks or guarantees that prevent the aforementioned issues from occurring. The code''s reliance on unsigned types to prevent underflow/overflow issues does not mitigate the potential for unexpected behavior when dealing with tainted data or the specific arithmetic/bitwise operations involved.', 'Provide a detailed explanation of the `readbyte()` function''s behavior, including its return value range and how it affects the subsequent operations.

Analyze the `G` structure, focusing on `G.incnt`, `G.inptr`, and `G.area.Slide`, to understand their roles in the context of the reported CVE.

Investigate the expected behavior of the bit shifting and arithmetic operations (e.g., `<< k`, `>>= 8`, `>>= 1`, `& mdl`) with potentially tainted data to assess the likelihood of exploitable vulnerabilities.

Evaluate the impact of unsigned type wrapping in the context of this specific code, considering whether it mitigates or exacerbates potential security issues.', 0.0000, '*** Source Code Context ***

code of explode.c file:
371| static int explode_nolit(__G__ tl, td, bl, bd, bdl)
372|      __GDEF
373| struct huft *tl, *td;   /* length and distance decoder tables */
374| unsigned bl, bd;        /* number of bits decoded by tl[] and td[] */
375| unsigned bdl;           /* number of distance low bits */
376| /* Decompress the imploded data using uncoded literals and a sliding
377|    window (of size 2^(6+bdl) bytes). */
378| {
379|   zusz_t s;             /* bytes to decompress */
380|   register unsigned e;  /* table entry flag/number of extra bits */
381|   unsigned n, d;        /* length and index for copy */
382|   unsigned w;           /* current window position */
383|   struct huft *t;       /* pointer to table entry */
384|   unsigned ml, md;      /* masks for bl and bd bits */
385|   unsigned mdl;         /* mask for bdl (distance lower) bits */
386|   register ulg b;       /* bit buffer */
387|   register unsigned k;  /* number of bits in bit buffer */
388|   unsigned u;           /* true if unflushed */
389|   int retval = 0;       /* error code returned: initialized to "no error" */
390| 
391| 
392|   /* explode the coded data */
393|   b = k = w = 0;                /* initialize bit buffer, window */
394|   u = 1;                        /* buffer unflushed */
395|   ml = mask_bits[bl];           /* precompute masks for speed */
396|   md = mask_bits[bd];
397|   mdl = mask_bits[bdl];
398|   s = G.lrec.ucsize;
399|   while (s > 0)                 /* do until ucsize bytes uncompressed */
400|   {
401|     NEEDBITS(1)
402|     if (b & 1)                  /* then literal--get eight bits */
403|     {
404|       DUMPBITS(1)
405|       s--;
406|       NEEDBITS(8)
407|       redirSlide[w++] = (uch)b;
408|       if (w == wszimpl)
409|       {
410|         if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
411|           return retval;
412|         w = u = 0;
413|       }
414|       DUMPBITS(8)
415|     }
416|     else                        /* else distance/length */
417|     {
418|       DUMPBITS(1)
419|       NEEDBITS(bdl)             /* get distance low bits */
420|       d = (unsigned)b & mdl;
421|       DUMPBITS(bdl)
422|       DECODEHUFT(td, bd, md)    /* get coded distance high bits */
423|       d = w - d - t->v.n;       /* construct offset */
424|       DECODEHUFT(tl, bl, ml)    /* get coded length */
425|       n = t->v.n;
426|       if (e)                    /* get length extra bits */
427|       {
428|         NEEDBITS(8)
429|         n += (unsigned)b & 0xff;
430|         DUMPBITS(8)
431|       }
432| 
433|       /* do the copy */
434|       s = (s > (zusz_t)n ? s - (zusz_t)n : 0);
435|       do {
436| #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
437|         if (G.redirect_slide) {
438|           /* &= w/ wszimpl not needed and wrong if redirect */
439|           if (d >= wszimpl)
440|             return 1;
441|           e = wszimpl - (d > w ? d : w);
442|         } else
443| #endif
444|           e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
445|         if (e > n) e = n;
446|         n -= e;
447|         if (u && w <= d)
448|         {
449|           memzero(redirSlide + w, e);
450|           w += e;
451|           d += e;
452|         }
453|         else
454| #ifndef NOMEMCPY
455|           if (w - d >= e)       /* (this test assumes unsigned comparison) */
456|           {
457|             memcpy(redirSlide + w, redirSlide + d, e);
458|             w += e;
459|             d += e;
460|           }
461|           else                  /* do it slow to avoid memcpy() overlap */
462| #endif /* !NOMEMCPY */
463|             do {
464|               redirSlide[w++] = redirSlide[d++];
465|             } while (--e);
466|         if (w == wszimpl)
467|         {
468|           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
469|             return retval;
470|           w = u = 0;
471|         }
472|       } while (n);
473|     }
474|   }
475| 
476|   /* flush out redirSlide */
477|   if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
478|     return retval;
479|   if (G.csize + G.incnt + (k >> 3))   /* should have read csize bytes, but */
480|   {                        /* sometimes read one too many:  k>>3 compensates */
481|     G.used_csize = G.lrec.csize - G.csize - G.incnt - (k >> 3);
482|     return 5;
483|   }
484|   return 0;
485| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010115');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (155, 113, 'def10', 'INTEGER_OVERFLOW', 'unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010115');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (156, 113, 'def11', 'RESOURCE_LEAK', 'unzip60/unzip.c:1089: alloc_arg: "envargs" allocates memory that is stored into "argv".
unzip60/unzip.c:1302: leaked_storage: Returning without freeing "argv" leaks the storage that it points to.
# 1300|           check_for_windows("UnZip");
# 1301|   #endif
# 1302|->     return(retcode);
# 1303|   
# 1304|   } /* end main()/unzip() */', 'TRUE POSITIVE', 'Memory allocated for `argv` in `envargs.c` (line 95) is stored and used in `unzip.c` but lacks a guaranteed `free` call before `unzip.c:1302` return, as `cleanup_and_exit` (line 1281) doesn''t explicitly free `argv` in the provided context.', 'The CVE report snippet explicitly mentions a memory allocation in `envargs` (unzip60/unzip.c:1089) that is stored into `argv`. This is confirmed by the `envargs.c` code, where memory is allocated for `argv` (line 95: `argv = (char **)malloc((argc + *Pargc + 1) * sizeof(char *));`).

The allocated memory for `argv` is indeed stored and used throughout the `unzip.c` code, as seen in the manipulation and usage of `argv` in both `unzip.c` (e.g., lines 1031-1033, 1135-1155) and `envargs.c` (e.g., lines 103-168).

The CVE report snippet also highlights a `leaked_storage` issue at `unzip.c:1302`, where the function returns without freeing the allocated memory for `argv`. Upon examining the provided `unzip.c` code, there is no explicit `free` call for the `argv` memory allocation before the `return(retcode)` statement at line 1302.

Although there are conditional statements and function calls before the return statement (e.g., `cleanup_and_exit` label), there is no guarantee within the **provided code context** that all execution paths leading to `unzip.c:1302` will have freed the `argv` memory. Specifically, the `cleanup_and_exit` label (line 1281) does not explicitly free `argv` in the given code snippet.

Given the direct correlation between the allocated memory in `envargs` (stored in `argv`) and the lack of a guaranteed `free` call for this memory before the return at `unzip.c:1302`, at least one execution path potentially leads to the described memory leak vulnerability.', 'Obtain and analyze the implementation of the `envargs` function to confirm its memory allocation behavior.

Investigate the broader codebase for any memory management functions or mechanisms that might interact with `argv` before the return at line 1302.

Verify if there are any platform-specific or compiler optimizations that could implicitly handle the memory deallocation of `argv`.', 0.0000, '*** Source Code Context ***

code of unzip.c file:
989|         G.incnt = 1;
990| 
991|         test_char = NEXTBYTE;           /* Should get ''a''. */
992|         if (test_char == ''a'')
993|         {
994|             test_char = NEXTBYTE;       /* Should get EOF, not ''b''. */
995|         }
996|         if (test_char != EOF)
997|         {
998|             Info(slide, 0x401, ((char *)slide,
999|  "NEXTBYTE macro failed.  Try compiling with ALT_NEXTBYTE defined?"));
1000| 
1001|             retcode = PK_BADERR;
1002|             goto cleanup_and_exit;
1003|         }
1004|     }
1005| #endif /* DEBUG */
1006| 
1007| /*---------------------------------------------------------------------------
1008|     First figure out if we''re running in UnZip mode or ZipInfo mode, and put
1009|     the appropriate environment-variable options into the queue.  Then rip
1010|     through any command-line options lurking about...
1011|   ---------------------------------------------------------------------------*/
1012| 
1013| #ifdef SFX
1014|     G.argv0 = argv[0];
1015| #if (defined(OS2) || defined(WIN32))
1016|     G.zipfn = GetLoadPath(__G);/* non-MSC NT puts path into G.filename[] */
1017| #else
1018|     G.zipfn = G.argv0;
1019| #endif
1020| 
1021| #ifdef VMSCLI
1022|     {
1023|         ulg status = vms_unzip_cmdline(&argc, &argv);
1024|         if (!(status & 1)) {
1025|             retcode = (int)status;
1026|             goto cleanup_and_exit;
1027|         }
1028|     }
1029| #endif /* VMSCLI */
1030| 
1031|     uO.zipinfo_mode = FALSE;
1032|     error = uz_opts(__G__ &argc, &argv);   /* UnZipSFX call only */
1033| 
1034| #else /* !SFX */
1035| 
1036| #ifdef RISCOS
1037|     /* get the extensions to swap from environment */
1038|     getRISCOSexts(ENV_UNZIPEXTS);
1039| #endif
1040| 
1041| #ifdef MSDOS
1042|     /* extract MKS extended argument list from environment (before envargs!) */
1043|     mksargs(&argc, &argv);
1044| #endif
1045| 
1046| #ifdef VMSCLI
1047|     {
1048|         ulg status = vms_unzip_cmdline(&argc, &argv);
1049|         if (!(status & 1)) {
1050|             retcode = (int)status;
1051|             goto cleanup_and_exit;
1052|         }
1053|     }
1054| #endif /* VMSCLI */
1055| 
1056|     G.noargs = (argc == 1);   /* no options, no zipfile, no anything */
1057| 
1058| #ifndef NO_ZIPINFO
1059|     for (p = argv[0] + strlen(argv[0]); p >= argv[0]; --p) {
1060|         if (*p == DIR_END
1061| #ifdef DIR_END2
1062|             || *p == DIR_END2
1063| #endif
1064|            )
1065|             break;
1066|     }
1067|     ++p;
1068| 
1069| #ifdef THEOS
1070|     if (strncmp(p, "ZIPINFO.",8) == 0 || strstr(p, ".ZIPINFO:") != NULL ||
1071|         strncmp(p, "II.",3) == 0 || strstr(p, ".II:") != NULL ||
1072| #else
1073|     if (STRNICMP(p, LoadFarStringSmall(Zipnfo), 7) == 0 ||
1074|         STRNICMP(p, "ii", 2) == 0 ||
1075| #endif
1076|         (argc > 1 && strncmp(argv[1], "-Z", 2) == 0))
1077|     {
1078|         uO.zipinfo_mode = TRUE;
1079| #ifndef _WIN32_WCE /* Win CE does not support environment variables */
1080|         if ((error = envargs(&argc, &argv, LoadFarStringSmall(EnvZipInfo),
1081|                              LoadFarStringSmall2(EnvZipInfo2))) != PK_OK)
1082|             perror(LoadFarString(NoMemEnvArguments));
1083| #endif
1084|     } else
1085| #endif /* !NO_ZIPINFO */
1086|     {
1087|         uO.zipinfo_mode = FALSE;
1088| #ifndef _WIN32_WCE /* Win CE does not support environment variables */
1089|         if ((error = envargs(&argc, &argv, LoadFarStringSmall(EnvUnZip),
1090|                              LoadFarStringSmall2(EnvUnZip2))) != PK_OK)
1091|             perror(LoadFarString(NoMemEnvArguments));
1092| #endif
1093|     }
1094| 
1095|     if (!error) {
1096|         /* Check the length of all passed command line parameters.
1097|          * Command arguments might get sent through the Info() message
1098|          * system, which uses the sliding window area as string buffer.
1099|          * As arguments may additionally get fed through one of the FnFilter
1100|          * macros, we require all command line arguments to be shorter than
1101|          * WSIZE/4 (and ca. 2 standard line widths for fixed message text).
1102|          */
1103|         for (i = 1 ; i < argc; i++) {
1104|            if (strlen(argv[i]) > ((WSIZE>>2) - 160)) {
1105|                Info(slide, 0x401, ((char *)slide,
1106|                  LoadFarString(CmdLineParamTooLong), i));
1107|                retcode = PK_PARAM;
1108|                goto cleanup_and_exit;
1109|            }
1110|         }
1111| #ifndef NO_ZIPINFO
1112|         if (uO.zipinfo_mode)
1113|             error = zi_opts(__G__ &argc, &argv);
1114|         else
1115| #endif /* !NO_ZIPINFO */
1116|             error = uz_opts(__G__ &argc, &argv);
1117|     }
1118| 
1119| #endif /* ?SFX */
1120| 
1121|     if ((argc < 0) || error) {
1122|         retcode = error;
1123|         goto cleanup_and_exit;
1124|     }
1125| 
1126| /*---------------------------------------------------------------------------
1127|     Now get the zipfile name from the command line and then process any re-
1128|     maining options and file specifications.
1129|   ---------------------------------------------------------------------------*/
1130| 
1131| #ifdef DOS_FLX_H68_NLM_OS2_W32
1132|     /* convert MSDOS-style ''backward slash'' directory separators to Unix-style
1133|      * ''forward slashes'' for user''s convenience (include zipfile name itself)
1134|      */
1135| #ifdef SFX
1136|     for (G.pfnames = argv, i = argc;  i > 0;  --i) {
1137| #else
1138|     /* argc does not include the zipfile specification */
1139|     for (G.pfnames = argv, i = argc+1;  i > 0;  --i) {
1140| #endif
1141| #ifdef __human68k__
1142|         extern char *_toslash(char *);
1143|         _toslash(*G.pfnames);
1144| #else /* !__human68k__ */
1145|         char *q = *G.pfnames;
1146| 
1147|         while (*q != ''\0'') {
1148|             if (*q == ''\\'')
1149|                 *q = ''/'';
1150|             INCSTR(q);
1151|         }
1152| #endif /* ?__human68k__ */
1153|         ++G.pfnames;
1154|     }
1155| #endif /* DOS_FLX_H68_NLM_OS2_W32 */
1156| 
1157| #ifndef SFX
1158|     G.wildzipfn = *argv++;
1159| #endif
1160| 
1161| #if (defined(SFX) && !defined(SFX_EXDIR)) /* only check for -x */
1162| 
1163|     G.filespecs = argc;
1164|     G.xfilespecs = 0;
1165| 
1166|     if (argc > 0) {
1167|         char **pp = argv-1;
1168| 
1169|         G.pfnames = argv;
1170|         while (*++pp)
1171|             if (strcmp(*pp, "-x") == 0) {
1172|                 if (pp > argv) {
1173|                     *pp = 0;              /* terminate G.pfnames */
1174|                     G.filespecs = pp - G.pfnames;
1175|                 } else {
1176|                     G.pfnames = (char **)fnames;  /* defaults */
1177|                     G.filespecs = 0;
1178|                 }
1179|                 G.pxnames = pp + 1;      /* excluded-names ptr: _after_ -x */
1180|                 G.xfilespecs = argc - G.filespecs - 1;
1181|                 break;                    /* skip rest of args */
1182|             }
1183|         G.process_all_files = FALSE;
1184|     } else
1185|         G.process_all_files = TRUE;      /* for speed */
1186| 
1187| #else /* !SFX || SFX_EXDIR */             /* check for -x or -d */
1188| 
1189|     G.filespecs = argc;

1202| #else
1203|             if (!uO.exdir && strncmp(*pp, "-d", 2) == 0) {
1204| #endif
1205|                 int firstarg = (pp == argv);
1206| 
1207|                 uO.exdir = (*pp) + 2;
1208|                 if (in_files) {      /* ... zipfile ... -d exdir ... */
1209|                     *pp = (char *)NULL;         /* terminate G.pfnames */
1210|                     G.filespecs = pp - G.pfnames;
1211|                     in_files = FALSE;
1212|                 } else if (in_xfiles) {
1213|                     *pp = (char *)NULL;         /* terminate G.pxnames */
1214|                     G.xfilespecs = pp - G.pxnames;
1215|                     /* "... -x xlist -d exdir":  nothing left */
1216|                 }
1217|                 /* first check for "-dexdir", then for "-d exdir" */
1218|                 if (*uO.exdir == ''\0'') {
1219|                     if (*++pp)
1220|                         uO.exdir = *pp;
1221|                     else {
1222|                         Info(slide, 0x401, ((char *)slide,
1223|                           LoadFarString(MustGiveExdir)));
1224|                         /* don''t extract here by accident */
1225|                         retcode = PK_PARAM;
1226|                         goto cleanup_and_exit;
1227|                     }
1228|                 }
1229|                 if (firstarg) { /* ... zipfile -d exdir ... */
1230|                     if (pp[1]) {
1231|                         G.pfnames = pp + 1;  /* argv+2 */
1232|                         G.filespecs = argc - (G.pfnames-argv);  /* for now... */
1233|                     } else {
1234|                         G.process_all_files = TRUE;
1235|                         G.pfnames = (char **)fnames;  /* GRR: necessary? */
1236|                         G.filespecs = 0;     /* GRR: necessary? */
1237|                         break;
1238|                     }
1239|                 }
1240|             } else if (!in_xfiles) {
1241|                 if (strcmp(*pp, "-x") == 0) {
1242|                     in_xfiles = TRUE;
1243|                     if (pp == G.pfnames) {
1244|                         G.pfnames = (char **)fnames;  /* defaults */
1245|                         G.filespecs = 0;
1246|                     } else if (in_files) {
1247|                         *pp = 0;                   /* terminate G.pfnames */
1248|                         G.filespecs = pp - G.pfnames;  /* adjust count */
1249|                         in_files = FALSE;
1250|                     }
1251|                     G.pxnames = pp + 1; /* excluded-names ptr starts after -x */
1252|                     G.xfilespecs = argc - (G.pxnames-argv);  /* anything left */
1253|                 } else
1254|                     in_files = TRUE;
1255|             }
1256|         }
1257|     } else
1258|         G.process_all_files = TRUE;      /* for speed */
1259| 
1260|     if (uO.exdir != (char *)NULL && !G.extract_flag)    /* -d ignored */
1261|         Info(slide, 0x401, ((char *)slide, LoadFarString(NotExtracting)));
1262| #endif /* ?(SFX && !SFX_EXDIR) */
1263| 
1264| #ifdef UNICODE_SUPPORT
1265|     /* set Unicode-escape-all if option -U used */
1266|     if (uO.U_flag == 1)
1267| # ifdef UNICODE_WCHAR
1268|         G.unicode_escape_all = TRUE;
1269| # else
1270|         Info(slide, 0x401, ((char *)slide, LoadFarString(UTF8EscapeUnSupp)));
1271| # endif
1272| #endif
1273| 
1274| 
1275| /*---------------------------------------------------------------------------
1276|     Okey dokey, we have everything we need to get started.  Let''s roll.
1277|   ---------------------------------------------------------------------------*/
1278| 
1279|     retcode = process_zipfiles(__G);
1280| 
1281| cleanup_and_exit:
1282| #if (defined(REENTRANT) && !defined(NO_EXCEPT_SIGNALS))
1283|     /* restore all signal handlers back to their state at function entry */
1284|     while (oldsighandlers != NULL) {
1285|         savsigs_info *thissigsav = oldsighandlers;
1286| 
1287|         signal(thissigsav->sigtype, thissigsav->sighandler);
1288|         oldsighandlers = thissigsav->previous;
1289|         free(thissigsav);
1290|     }
1291| #endif
1292| #if (defined(MALLOC_WORK) && !defined(REENTRANT))
1293|     if (G.area.Slide != (uch *)NULL) {
1294|         free(G.area.Slide);
1295|         G.area.Slide = (uch *)NULL;
1296|     }
1297| #endif
1298| #if (defined(MSDOS) && !defined(SFX) && !defined(WINDLL))
1299|     if (retcode != PK_OK)
1300|         check_for_windows("UnZip");
1301| #endif
1302|     return(retcode);
1303| 
1304| } /* end main()/unzip() */
1305| 
1306| 
1307| 
1308| 
1309| 
1310| #if (defined(REENTRANT) && !defined(NO_EXCEPT_SIGNALS))
1311| /*******************************/
1312| /* Function setsignalhandler() */
1313| /*******************************/
1314| 
1315| static int setsignalhandler(__G__ p_savedhandler_chain, signal_type,
1316|                             newhandler)
1317|     __GDEF
1318|     savsigs_info **p_savedhandler_chain;
1319|     int signal_type;
1320|     void (*newhandler)(int);
1321| {
1322|     savsigs_info *savsig;
1323| 
1324|     savsig = malloc(sizeof(savsigs_info));
1325|     if (savsig == NULL) {
1326|         /* error message and break */
1327|         Info(slide, 0x401, ((char *)slide, LoadFarString(CantSaveSigHandler)));
1328|         return PK_MEM;
1329|     }
1330|     savsig->sigtype = signal_type;
1331|     savsig->sighandler = signal(SIGINT, newhandler);
1332|     if (savsig->sighandler == SIG_ERR) {
1333|         free(savsig);
1334|     } else {
1335|         savsig->previous = *p_savedhandler_chain;
1336|         *p_savedhandler_chain = savsig;
1337|     }
1338|     return PK_OK;
1339| 
1340| } /* end function setsignalhandler() */
1341| 
1342| #endif /* REENTRANT && !NO_EXCEPT_SIGNALS */
1343| 
1344| 
1345| 
1346| 
1347| 
1348| /**********************/
1349| /* Function uz_opts() */
1350| /**********************/
1351| 
1352| int uz_opts(__G__ pargc, pargv)
1353|     __GDEF
1354|     int *pargc;
1355|     char ***pargv;
1356| {
1357|     char **argv, *s, *zipbomb_envar;
1358|     int argc, c, error=FALSE, negative=0, showhelp=0;
1359| 
1360|     argc = *pargc;
1361|     argv = *pargv;
1362| 
1363| #ifdef UNIX
1364|     extern char OEM_CP[MAX_CP_NAME];
1365|     extern char ISO_CP[MAX_CP_NAME];
1366| #endif
1367|     
1368|     while (++argv, (--argc > 0 && *argv != NULL && **argv == ''-'')) {
1369|         s = *argv + 1;
1370|         while ((c = *s++) != 0) {    /* "!= 0":  prevent Turbo C warning */
1371| #ifdef CMS_MVS
1372|             switch (tolower(c))
1373| #else
1374|             switch (c)
1375| #endif
1376|             {
1377|                 case (''-''):
1378|                     ++negative;
1379|                     break;
1380| #ifdef RISCOS
1381|                 case (''/''):
1382|                     if (negative) {   /* negative not allowed with -/ swap */
1383|                         Info(slide, 0x401, ((char *)slide,
1384|                           "error:  must give extensions list"));
1385|                         return(PK_PARAM);  /* don''t extract here by accident */
1386|                     }
1387|                     exts2swap = s; /* override Unzip$Exts */
1388|                     s += strlen(s);
1389|                     break;
1390| #endif
1391|                 case (''a''):
1392|                     if (negative) {
1393|                         uO.aflag = MAX(uO.aflag-negative,0);
1394|                         negative = 0;
1395|                     } else
1396|                         ++uO.aflag;
1397|                     break;
1398| #if (defined(DLL) && defined(API_DOC))
1399|                 case (''A''):    /* extended help for API */
1400|                     APIhelp(__G__ argc, argv);
1401|                     *pargc = -1;  /* signal to exit successfully */
1402|                     return 0;

code of /shared-data/source/unzip60/envargs.c file:
49| int envargs(Pargc, Pargv, envstr, envstr2)
50|     int *Pargc;
51|     char ***Pargv;
52|     ZCONST char *envstr, *envstr2;
53| {
54|     char *envptr;       /* value returned by getenv */
55|     char *bufptr;       /* copy of env info */
56|     int argc = 0;       /* internal arg count */
57|     register int ch;    /* spare temp value */
58|     char **argv;        /* internal arg vector */
59|     char **argvect;     /* copy of vector address */
60| 
61|     /* see if anything in the environment */
62|     if ((envptr = getenv(envstr)) != (char *)NULL)        /* usual var */
63|         while (ISspace(*envptr))        /* must discard leading spaces */
64|             envptr++;
65|     if (envptr == (char *)NULL || *envptr == ''\0'')
66|         if ((envptr = getenv(envstr2)) != (char *)NULL)   /* alternate var */
67|             while (ISspace(*envptr))
68|                 envptr++;
69|     if (envptr == (char *)NULL || *envptr == ''\0'')
70|         return PK_OK;
71| 
72|     bufptr = malloc(1 + strlen(envptr));
73|     if (bufptr == (char *)NULL)
74|         return PK_MEM;
75| #if ((defined(WIN32) || defined(WINDLL)) && !defined(_WIN32_WCE))
76| # ifdef WIN32
77|     if (IsWinNT()) {
78|         /* SPC: don''t know codepage of ''real'' WinNT console */
79|         strcpy(bufptr, envptr);
80|     } else {
81|         /* Win95 environment is DOS and uses OEM character coding */
82|         OEM_TO_INTERN(envptr, bufptr);
83|     }
84| # else /* !WIN32 */
85|     /* DOS (Win 3.x) environment uses OEM codepage */
86|     OEM_TO_INTERN(envptr, bufptr);
87| # endif
88| #else /* !((WIN32 || WINDLL) && !_WIN32_WCE) */
89|     strcpy(bufptr, envptr);
90| #endif /* ?((WIN32 || WINDLL) && !_WIN32_WCE) */
91| 
92|     /* count the args so we can allocate room for them */
93|     argc = count_args(bufptr);
94|     /* allocate a vector large enough for all args */
95|     argv = (char **)malloc((argc + *Pargc + 1) * sizeof(char *));
96|     if (argv == (char **)NULL) {
97|         free(bufptr);
98|         return PK_MEM;
99|     }
100|     argvect = argv;
101| 
102|     /* copy the program name first, that''s always true */
103|     *(argv++) = *((*Pargv)++);
104| 
105|     /* copy the environment args next, may be changed */
106|     do {
107| #if defined(AMIGA) || defined(UNIX)
108|         if (*bufptr == ''"'') {
109|             char *argstart = ++bufptr;
110| 
111|             *(argv++) = argstart;
112|             for (ch = *bufptr; ch != ''\0'' && ch != ''\"'';
113|                  ch = *PREINCSTR(bufptr))
114|                 if (ch == ''\\'' && bufptr[1] != ''\0'')
115|                     ++bufptr;           /* advance to char after backslash */
116|             if (ch != ''\0'')
117|                 *(bufptr++) = ''\0'';     /* overwrite trailing " */
118| 
119|             /* remove escape characters */
120|             while ((argstart = MBSCHR(argstart, ''\\'')) != (char *)NULL) {
121|                 strcpy(argstart, argstart + 1);
122|                 if (*argstart)
123|                     ++argstart;
124|             }
125|         } else {
126|             *(argv++) = bufptr;
127|             while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
128|                 INCSTR(bufptr);
129|             if (ch != ''\0'')
130|                 *(bufptr++) = ''\0'';
131|         }
132| #else
133| #ifdef DOS_FLX_NLM_OS2_W32
134|         /* we do not support backslash-quoting of quotes in quoted
135|          * strings under DOS_FLX_NLM_OS2_W32, because backslashes are
136|          * directory separators and double quotes are illegal in filenames */
137|         if (*bufptr == ''"'') {
138|             *(argv++) = ++bufptr;
139|             while ((ch = *bufptr) != ''\0'' && ch != ''\"'')
140|                 INCSTR(bufptr);
141|             if (ch != ''\0'')
142|                 *(bufptr++) = ''\0'';
143|         } else {
144|             *(argv++) = bufptr;
145|             while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
146|                 INCSTR(bufptr);
147|             if (ch != ''\0'')
148|                 *(bufptr++) = ''\0'';
149|         }
150| #else
151|         *(argv++) = bufptr;
152|         while ((ch = *bufptr) != ''\0'' && !ISspace(ch))
153|             INCSTR(bufptr);
154|         if (ch != ''\0'')
155|             *(bufptr++) = ''\0'';
156| #endif /* ?DOS_FLX_NLM_OS2_W32 */
157| #endif /* ?(AMIGA || UNIX) */
158|         while ((ch = *bufptr) != ''\0'' && ISspace(ch))
159|             INCSTR(bufptr);
160|     } while (ch);
161| 
162|     /* now save old argc and copy in the old args */
163|     argc += *Pargc;
164|     while (--(*Pargc))
165|         *(argv++) = *((*Pargv)++);
166| 
167|     /* finally, add a NULL after the last arg, like Unix */
168|     *argv = (char *)NULL;
169| 
170|     /* save the values and return, indicating succes */
171|     *Pargv = argvect;
172|     *Pargc = argc;
173| 
174|     return PK_OK;
175| }

*** Examples ***
', '2025-11-17 21:39:07.010116');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (157, 113, 'def12', 'COPY_PASTE_ERROR', 'unzip60/zipinfo.c:518: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/zipinfo.c:569: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/zipinfo.c:569: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
#  567|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
#  568|       						if(*s == ''-'') { 
#  569|->     	                        Info(slide, 0x401, ((char *)slide,
#  570|           		                  "error:  a valid character encoding should follow the -I argument"));
#  571|       	                        return(PK_PARAM);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/zipinfo.c:518: original: "error:  a valid character encoding should follow the -I argument" looks like the original copy.
unzip60/zipinfo.c:569: copy_paste_error: "error:  a valid character encoding should follow the -I argument" looks like a copy-paste error.
unzip60/zipinfo.c:569: remediation: Should it say "error:  a valid character encoding should follow the -O argument" instead?
#  567|        /* Assume that charsets can''t start with a dash to spot arguments misuse */
#  568|        if(*s == ''-'') { 
#  569|->      Info(slide, 0x401, ((char *)slide,
#  570|                     "error:  a valid character encoding should follow the -I argument");
#  571|        return(PK_PARAM);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
unzip60/zipinfo.c:518: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/zipinfo.c:569: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/zipinfo.c:569: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
#  567|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
#  568|       						if(*s == ''-'') { 
#  569|->     	                        Info(slide, 0x401, ((char *)slide,
#  570|           		                  "error:  a valid character encoding should follow the -I argument"));
#  571|       	                        return(PK_PARAM);
(Example-1) Reason Marked as False Positive:
intended

** Example-2 **
(Example-2) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
unzip60/unzip.c:1559: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/unzip.c:1665: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/unzip.c:1665: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
# 1663|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
# 1664|       						if(*s == ''-'') { 
# 1665|->     	                        Info(slide, 0x401, ((char *)slide,
# 1666|           		                  "error:  a valid character encoding should follow the -I argument"));
# 1667|       	                        return(PK_PARAM);
(Example-2) Reason Marked as False Positive:
intended

', '2025-11-17 21:39:07.010116');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (158, 113, 'def13', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010116');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (159, 113, 'def14', 'COPY_PASTE_ERROR', 'unzip60/unzip.c:1559: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/unzip.c:1665: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/unzip.c:1665: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
# 1663|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
# 1664|       						if(*s == ''-'') { 
# 1665|->     	                        Info(slide, 0x401, ((char *)slide,
# 1666|           		                  "error:  a valid character encoding should follow the -I argument"));
# 1667|       	                        return(PK_PARAM);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/unzip.c:1559: original: "error:  a valid character encoding should follow the -I argument" looks like the original copy.
unzip60/unzip.c:1665: copy_paste_error: "error:  a valid character encoding should follow the -I argument" looks like a copy-paste error.
unzip60/unzip.c:1665: remediation: Should it say "error:  a valid character encoding should follow the -O argument" instead?
# 1663|        /* Assume that charsets can''t start with a dash to spot arguments misuse */
# 1664|        if(*s == ''-'') { 
# 1665|->      Info(slide, 0x401, ((char *)slide,
# 1666|            "error:  a valid character encoding should follow the -I argument"));
# 1667|        return(PK_PARAM);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
unzip60/unzip.c:1559: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/unzip.c:1665: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/unzip.c:1665: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
# 1663|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
# 1664|       						if(*s == ''-'') { 
# 1665|->     	                        Info(slide, 0x401, ((char *)slide,
# 1666|           		                  "error:  a valid character encoding should follow the -I argument"));
# 1667|       	                        return(PK_PARAM);
(Example-1) Reason Marked as False Positive:
intended

** Example-2 **
(Example-2) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
unzip60/zipinfo.c:518: original: ""error:  a valid character encoding should follow the -I argument"" looks like the original copy.
unzip60/zipinfo.c:569: copy_paste_error: ""error:  a valid character encoding should follow the -I argument"" looks like a copy-paste error.
unzip60/zipinfo.c:569: remediation: Should it say ""error:  a valid character encoding should follow the -O argument"" instead?
#  567|       						/* Assume that charsets can''t start with a dash to spot arguments misuse */
#  568|       						if(*s == ''-'') { 
#  569|->     	                        Info(slide, 0x401, ((char *)slide,
#  570|           		                  "error:  a valid character encoding should follow the -I argument"));
#  571|       	                        return(PK_PARAM);
(Example-2) Reason Marked as False Positive:
intended

', '2025-11-17 21:39:07.010117');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (160, 113, 'def15', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010117');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (161, 113, 'def16', 'OVERRUN', 'unzip60/inflate.c:989: cond_at_most: Checking "(e = t->e) < 32U" implies that "e" and "t->e" may be up to 31 on the true branch.
unzip60/inflate.c:998: overrun-local: Overrunning array "mask_bits" of 17 4-byte elements at element index 31 (byte offset 127) using index "e" (which evaluates to 31).
#  996|           }
#  997|           NEEDBITS(e)
#  998|->         d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
#  999|           DUMPBITS(e)
# 1000|', 'TRUE POSITIVE', 'Accessing `mask_bits[e]` at line 998 with `e` potentially being 31 (as allowed by the condition at line 989) exceeds the array''s valid index range (0-16) for its 17 4-byte elements, confirming the out-of-bounds overrun-local error.', 'The CVE report indicates a potential overrun of the `mask_bits` array with an index of 31 (byte offset 127), which is out of bounds for an array of 17 4-byte elements (maximum valid index is 16).

The condition at line 989 (`if ((e = t->e) < 32U)`) indeed allows `e` to be up to 31 on the true branch, as reported.

At line 998, `e` is directly used as an index into the `mask_bits` array without any additional bounds checking beyond the condition at line 989.

Since `mask_bits` is defined with a size that corresponds to a maximum valid index of 16 (given its size of 17 elements, starting from index 0), accessing `mask_bits[31]` would indeed be an out-of-bounds access, confirming the overrun-local error.

There is no explicit proof within the provided code snippet that prevents `e` from being exactly 31 when used to index `mask_bits`, thus leading to the vulnerability described in the CVE.', NULL, 0.0000, '*** Source Code Context ***

code of inflate.c file:
989|           if ((e = t->e) < 32)

898|    the speed.  The idea is you can have a shorter table that decodes the
899|    shorter, more probable codes, and then point to subsidiary tables for
900|    the longer codes.  The time it costs to decode the longer codes is
901|    then traded against the time it takes to make longer tables.
902| 
903|    This results of this trade are in the variables lbits and dbits
904|    below.  lbits is the number of bits the first level table for literal/
905|    length codes can decode in one step, and dbits is the same thing for
906|    the distance codes.  Subsequent tables are also less than or equal to
907|    those sizes.  These values may be adjusted either when all of the
908|    codes are shorter than that, in which case the longest code length in
909|    bits is used, or when the shortest code is *longer* than the requested
910|    table size, in which case the length of the shortest code in bits is
911|    used.
912| 
913|    There are two different values for the two tables, since they code a
914|    different number of possibilities each.  The literal/length table
915|    codes 286 possible values, or in a flat code, a little over eight
916|    bits.  The distance table codes 30 possible values, or a little less
917|    than five bits, flat.  The optimum values for speed end up being
918|    about one bit more than those, so lbits is 8+1 and dbits is 5+1.
919|    The optimum values may differ though from machine to machine, and
920|    possibly even between compilers.  Your mileage may vary.
921|  */
922| 
923| 
924| /* bits in base literal/length lookup table */
925| static ZCONST unsigned lbits = 9;
926| /* bits in base distance lookup table */
927| static ZCONST unsigned dbits = 6;
928| 
929| 
930| #ifndef ASM_INFLATECODES
931| 
932| int inflate_codes(__G__ tl, td, bl, bd)
933|      __GDEF
934| struct huft *tl, *td;   /* literal/length and distance decoder tables */
935| unsigned bl, bd;        /* number of bits decoded by tl[] and td[] */
936| /* inflate (decompress) the codes in a deflated (compressed) block.
937|    Return an error code or zero if it all goes ok. */
938| {
939|   register unsigned e;  /* table entry flag/number of extra bits */
940|   unsigned d;           /* index for copy */
941|   UINT_D64 n;           /* length for copy (deflate64: might be 64k+2) */
942|   UINT_D64 w;           /* current window position (deflate64: up to 64k) */
943|   struct huft *t;       /* pointer to table entry */
944|   unsigned ml, md;      /* masks for bl and bd bits */
945|   register ulg b;       /* bit buffer */
946|   register unsigned k;  /* number of bits in bit buffer */
947|   int retval = 0;       /* error code returned: initialized to "no error" */
948| 
949| 
950|   /* make local copies of globals */
951|   b = G.bb;                       /* initialize bit buffer */
952|   k = G.bk;
953|   w = G.wp;                       /* initialize window position */
954| 
955| 
956|   /* inflate the coded data */
957|   ml = mask_bits[bl];           /* precompute masks for speed */
958|   md = mask_bits[bd];
959|   while (1)                     /* do until end of block */
960|   {
961|     NEEDBITS(bl)
962|     t = tl + ((unsigned)b & ml);
963|     while (1) {
964|       DUMPBITS(t->b)
965| 
966|       if ((e = t->e) == 32)     /* then it''s a literal */
967|       {
968|         redirSlide[w++] = (uch)t->v.n;
969|         if (w == wsize)
970|         {
971|           if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
972|           w = 0;
973|         }
974|         break;
975|       }
976| 
977|       if (e < 31)               /* then it''s a length */
978|       {
979|         /* get length of block to copy */
980|         NEEDBITS(e)
981|         n = t->v.n + ((unsigned)b & mask_bits[e]);
982|         DUMPBITS(e)
983| 
984|         /* decode distance of block to copy */
985|         NEEDBITS(bd)
986|         t = td + ((unsigned)b & md);
987|         while (1) {
988|           DUMPBITS(t->b)
989|           if ((e = t->e) < 32)
990|             break;
991|           if (IS_INVALID_CODE(e))
992|             return 1;
993|           e &= 31;
994|           NEEDBITS(e)
995|           t = t->v.t + ((unsigned)b & mask_bits[e]);
996|         }
997|         NEEDBITS(e)
998|         d = (unsigned)w - t->v.n - ((unsigned)b & mask_bits[e]);
999|         DUMPBITS(e)
1000| 
1001|         /* do the copy */
1002|         do {
1003| #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
1004|           if (G.redirect_slide) {
1005|             /* &= w/ wsize unnecessary & wrong if redirect */
1006|             if ((UINT_D64)d >= wsize)
1007|               return 1;         /* invalid compressed data */
1008|             e = (unsigned)(wsize - (d > (unsigned)w ? (UINT_D64)d : w));
1009|           }
1010|           else
1011| #endif
1012|             e = (unsigned)(wsize -
1013|                            ((d &= (unsigned)(wsize-1)) > (unsigned)w ?
1014|                             (UINT_D64)d : w));
1015|           if ((UINT_D64)e > n) e = (unsigned)n;
1016|           n -= e;
1017| #ifndef NOMEMCPY
1018|           if ((unsigned)w - d >= e)
1019|           /* (this test assumes unsigned comparison) */
1020|           {
1021|             memcpy(redirSlide + (unsigned)w, redirSlide + d, e);
1022|             w += e;
1023|             d += e;
1024|           }
1025|           else                  /* do it slowly to avoid memcpy() overlap */
1026| #endif /* !NOMEMCPY */
1027|             do {
1028|               redirSlide[w++] = redirSlide[d++];
1029|             } while (--e);
1030|           if (w == wsize)
1031|           {
1032|             if ((retval = FLUSH(w)) != 0) goto cleanup_and_exit;
1033|             w = 0;
1034|           }
1035|         } while (n);
1036|         break;
1037|       }
1038| 
1039|       if (e == 31)              /* it''s the EOB signal */
1040|       {
1041|         /* sorry for this goto, but we have to exit two loops at once */
1042|         goto cleanup_decode;
1043|       }
1044| 
1045|       if (IS_INVALID_CODE(e))
1046|         return 1;
1047| 
1048|       e &= 31;
1049|       NEEDBITS(e)
1050|       t = t->v.t + ((unsigned)b & mask_bits[e]);
1051|     }
1052|   }
1053| cleanup_decode:
1054| 
1055|   /* restore the globals from the locals */
1056|   G.wp = (unsigned)w;             /* restore global window pointer */
1057|   G.bb = b;                       /* restore global bit buffer */
1058|   G.bk = k;
1059| 
1060| 
1061| cleanup_and_exit:
1062|   /* done */
1063|   return retval;
1064| }
1065| 
1066| #endif /* ASM_INFLATECODES */
1067| 
1068| 
1069| 
1070| static int inflate_stored(__G)
1071|      __GDEF
1072| /* "decompress" an inflated type 0 (stored) block. */
1073| {
1074|   UINT_D64 w;           /* current window position (deflate64: up to 64k!) */
1075|   unsigned n;           /* number of bytes in block */
1076|   register ulg b;       /* bit buffer */
1077|   register unsigned k;  /* number of bits in bit buffer */
1078|   int retval = 0;       /* error code returned: initialized to "no error" */
1079| 
1080| 
1081|   /* make local copies of globals */
1082|   Trace((stderr, "
stored block"));
1083|   b = G.bb;                       /* initialize bit buffer */
1084|   k = G.bk;
1085|   w = G.wp;                       /* initialize window position */
1086| 
1087| 
1088|   /* go to byte boundary */
1089|   n = k & 7;
1090|   DUMPBITS(n);
1091| 
1092| 
1093|   /* get the length and its complement */
1094|   NEEDBITS(16)
1095|   n = ((unsigned)b & 0xffff);
1096|   DUMPBITS(16)
1097|   NEEDBITS(16)
1098|   if (n != (unsigned)((~b) & 0xffff))


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1624: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
# 1622|     /* Adjust last length count to fill out codes, if needed */
# 1623|     for (y = 1 << j; j < i; j++, y <<= 1)
# 1624|->     if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|     if ((y -= c[i]) < 0)
(Example-1) Reason Marked as False Positive:
i is between 1 and BMAX, line 1623 checks that j < i, array C is of the size BMAX+1

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
unzip60/inflate.c:1608: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
unzip60/inflate.c:1613: assignment: Assigning: "*m" = "j". The value of "*m" is now 17.
unzip60/inflate.c:1614: assignment: Assigning: "i" = "16U".
unzip60/inflate.c:1614: decr: Decrementing "i". The value of "i" is now 15.
unzip60/inflate.c:1614: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
unzip60/inflate.c:1618: cond_at_least: Checking "*m > i" implies that "g" and "i" are at least 17 on the false branch.
unzip60/inflate.c:1626: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
# 1624|       if ((y -= c[j]) < 0)
# 1625|         return 2;                 /* bad input: more codes than bits */
# 1626|->   if ((y -= c[i]) < 0)
# 1627|       return 2;
# 1628|     c[i] += y;
(Example-2) Reason Marked as False Positive:
C is an array of size BMAX+1, i is between 1 and BMAX (inclusive)

', '2025-11-17 21:39:07.010117');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (212, 97, 'def45', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/tools.c:402: alloc_arg: "asprintf" allocates memory that is stored into "snippets". [Note: The source code implementation of the function has been overridden by a builtin model.]
adcli-0.9.2/tools/tools.c:402: noescape: Assuming resource "snippets" is not freed or pointed-to as ellipsis argument to "asprintf".
adcli-0.9.2/tools/tools.c:409: overwrite_var: Overwriting "snippets" in "snippets = NULL" leaks the storage that "snippets" points to.
#  407|   				warnx ("unexpected: out of memory");
#  408|   				filename = NULL; /* content is undefined */
#  409|-> 				snippets = NULL; /* content is undefined */
#  410|   				contents = NULL; /* content is undefined */
#  411|   				failed = 1;', 'TRUE POSITIVE', 'Memory allocated by `asprintf` for `snippets` (line 402) is not explicitly freed before being overwritten with `NULL` (line 409) in error handling, directly supporting the reported RESOURCE_LEAK (CWE-772) vulnerability.', 'The CVE report indicates a potential memory leak due to the allocation of memory by `asprintf` stored in `snippets` (line 402) without a clear freeing mechanism in the provided code context.

The `noescape` warning (line 402) suggests that the analysis tool assumes `snippets` is not freed or pointed-to elsewhere, which, if true, would confirm a memory leak.

The explicit overwrite of `snippets` with `NULL` (line 409) after an out-of-memory error, without prior deallocation of the potentially allocated memory, directly supports the memory leak concern.

There is no explicit evidence within the provided code context (tools/tools.c, lines 352-465) that `snippets` is freed or deallocated before being overwritten with `NULL` in the error handling path (lines 407-411).

The absence of a visible `free(snippets)` call in the provided code, especially in the error handling block (lines 407-411) and before the function''s end, aligns with the reported vulnerability of a memory leak (RESOURCE_LEAK, CWE-772).

Given the direct correlation between the code''s behavior (explicitly overwriting `snippets` with `NULL` without prior deallocation) and the vulnerability described (memory leak due to allocated memory not being freed), this finding cannot be conclusively marked as a FALSE POSITIVE based on the provided information.', 'Examine the entire codebase to confirm whether `snippets` is freed or deallocated in functions called before or after the analyzed code block (tools/tools.c, lines 352-465).

Verify the implementation of error handling mechanisms to ensure no indirect deallocation of `snippets` occurs.

Review the memory management practices in the surrounding code to assess the likelihood of `snippets` being freed through an unseen mechanism.', 0.0000, '*** Source Code Context ***

code of tools/tools.c file:
352| static void
353| setup_krb5_conf_directory (adcli_conn *conn)
354| {
355| 	const char *parent;
356| 	const char *krb5_conf;
357| 	char *filename = NULL;
358| 	char *snippets = NULL;
359| 	char *contents = NULL;
360| 	char *directory = NULL;
361| 	struct stat sb;
362| 	int failed = 0;
363| 	int errn = 0;
364| 	FILE *fo;
365| 
366| 	krb5_conf = getenv ("KRB5_CONFIG");
367| 	if (!krb5_conf || !krb5_conf[0])
368| 		krb5_conf = KRB5_CONFIG;
369| 
370| 	parent = getenv ("TMPDIR");
371| 	if (!parent || !*parent)
372| 		parent = _PATH_TMP;
373| 
374| 	/* Check that the config file exists, don''t include if not */
375| 	if (stat (krb5_conf, &sb) < 0) {
376| 		if (errno != ENOENT)
377| 			warn ("couldn''t access file: %s", krb5_conf);
378| 		krb5_conf = NULL;
379| 	}
380| 
381| 	if (asprintf (&directory, "%s%sadcli-krb5-XXXXXX", parent,
382| 	              (parent[0] && parent[strlen(parent) - 1] == ''/'') ? "" : "/") < 0) {
383| 		warnx ("unexpected: out of memory");
384| 		directory = NULL; /* content is undefined */
385| 		failed = 1;
386| 	}
387| 
388| 	if (!failed) {
389| 		mode_t old_umask;
390| 		char *dtemp = NULL;
391| 
392| 		old_umask = umask (0077);
393| 		dtemp = mkdtemp (directory);
394| 		umask (old_umask);
395| 
396| 		if (dtemp == NULL) {
397| 			errn = errno;
398| 			failed = 1;
399| 			warnx ("couldn''t create temporary directory in: %s: %s",
400| 			       parent, strerror (errn));
401| 		} else {
402| 			if (asprintf (&filename, "%s/krb5.conf", directory) < 0 ||
403| 			    asprintf (&snippets, "%s/krb5.d", directory) < 0 ||
404| 			    asprintf (&contents, "includedir %s
%s%s
", snippets,
405| 			              krb5_conf ? "include " : "",
406| 			              krb5_conf ? krb5_conf : "") < 0) {
407| 				warnx ("unexpected: out of memory");
408| 				filename = NULL; /* content is undefined */
409| 				snippets = NULL; /* content is undefined */
410| 				contents = NULL; /* content is undefined */
411| 				failed = 1;
412| 			}
413| 		}
414| 	}
415| 
416| 	if (!failed) {
417| 		fo = fopen (filename, "wb");
418| 		if (fo == NULL) {
419| 			errn = errno;
420| 			failed = 1;
421| 		} else {
422| 			fwrite (contents, 1, strlen (contents), fo);
423| 			if (ferror (fo)) {
424| 				errn = errno;
425| 				failed = 1;
426| 				fclose (fo);
427| 			} else {
428| 				if (fclose (fo) != 0) {
429| 					failed = 1;
430| 					errn = errno;
431| 				}
432| 			}
433| 		}
434| 
435| 		if (failed) {
436| 			warnx ("couldn''t write new krb5.conf file: %s: %s",
437| 			       filename, strerror (errn));
438| 		}
439| 	}
440| 
441| 
442| 	if (!failed && mkdir (snippets, 0700) < 0) {
443| 		errn = errno;
444| 		failed = 1;
445| 		warnx ("couldn''t write new krb5.d directory: %s: %s",
446| 		       snippets, strerror (errn));
447| 	}
448| 
449| 	if (!failed) {
450| 		adcli_conn_set_krb5_conf_dir (conn, snippets);
451| 		adcli_temp_directory = directory;
452| 		adcli_krb5_conf_filename = filename;
453| 		adcli_krb5_d_directory = snippets;
454| 		setenv ("KRB5_CONFIG", adcli_krb5_conf_filename, 1);
455| 		setenv ("SSSD_KRB5_LOCATOR_DISABLE", "true", 1);
456| 
457| 	} else {
458| 		free (filename);
459| 		free (snippets);
460| 		free (directory);
461| 	}
462| 
463| 	free (contents);
464| 	atexit (cleanup_krb5_conf_directory);
465| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (162, 113, 'def17', 'NEGATIVE_RETURNS', 'unzip60/inflate.c:1652: var_tested_neg: Assigning: "h" = a negative value.
unzip60/inflate.c:1741: negative_returns: Using variable "h" as an index to array "x".
# 1739|   
# 1740|         /* backup over finished tables */
# 1741|->       while ((i & ((1 << w) - 1)) != x[h])
# 1742|           w -= l[--h];            /* don''t need to update q */
# 1743|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:1652: var_tested_neg: Assigning: "h" = a negative value.
unzip60/inflate.c:1741: negative_returns: Using variable "h" as an index to array "x".
# 1739|   
# 1740|         /* backup over finished tables */
# 1741|->       while ((i & ((1 << w) - 1)) != x[h])
# 1742|           w -= l[--h];            /* don''t need to update q */
# 1743|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error NEGATIVE_RETURNS (CWE-394):
unzip60/inflate.c:1652: var_tested_neg: Assigning: "h" = a negative value.
unzip60/inflate.c:1741: negative_returns: Using variable "h" as an index to array "x".
# 1739|   
# 1740|         /* backup over finished tables */
# 1741|->       while ((i & ((1 << w) - 1)) != x[h])
# 1742|           w -= l[--h];            /* don''t need to update q */
# 1743|       }
(Example-1) Reason Marked as False Positive:
If the code reaches this point, line 1668 (containing h++) must have been reached at least once:
both w and l(h) at line 1666 are equal to zero, k is at least 1 (line 1611) thus the condition (k > w +l[h]) must be true at least once

', '2025-11-17 21:39:07.010118');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (163, 113, 'def18', 'IDENTICAL_BRANCHES', 'unzip60/extract.c:2554: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
unzip60/extract.c:2552: identical_branches: The same code is executed when the condition "G.outcnt == 0UL" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
# 2550|                   error = (r == 3)? PK_MEM3 : PK_ERR;
# 2551|               }
# 2552|->             if (G.outcnt == 0L)   /* inflate''s final FLUSH sets outcnt */
# 2553|                   break;
# 2554|               break;', 'TRUE POSITIVE', 'Code redundancy identified at lines 2552-2554, where `G.outcnt == 0L` and `G.outcnt != 0L` both execute `break;`, aligning with the CVE report''s `implicit_else` and `identical_branches` issue, posing a code quality concern.', 'The reported issue is not about a security vulnerability in the classical sense (e.g., buffer overflow, SQL injection), but rather about potentially redundant code.

The CVE report snippet highlights an `implicit_else` and `identical_branches` issue, indicating the code within the if-then branch (line 2553) is identical to the code following the if statement (line 2554).

Explicitly, when `G.outcnt == 0L`, the code executes `break;` (line 2553), and when `G.outcnt != 0L`, it also executes `break;` (line 2554), making the condition seemingly redundant.

The presence of this redundancy can be considered a **TRUE POSITIVE** for the reported issue because it aligns with the description provided in the CVE report snippet.

The justification for considering this a **TRUE POSITIVE** is based on the direct correlation between the reported issue and the observed code behavior at lines 2552-2554.

No assumption about the function''s name, variable names, or implied functionality beyond the provided code snippet is made; the analysis is strictly based on the explicit behavior observed.

While this issue may not pose a traditional security risk, it represents a code quality or maintainability concern, as flagged by the CVE report snippet.', NULL, 0.0000, '*** Source Code Context ***

code of extract.c file:
2508| int memextract(__G__ tgt, tgtsize, src, srcsize)  /* extract compressed */
2509|     __GDEF                                        /*  extra field block; */
2510|     uch *tgt;                                     /*  return PK-type error */
2511|     ulg tgtsize;                                  /*  level */
2512|     ZCONST uch *src;
2513|     ulg srcsize;
2514| {
2515|     zoff_t old_csize=G.csize;
2516|     uch   *old_inptr=G.inptr;
2517|     int    old_incnt=G.incnt;
2518|     int    r, error=PK_OK;
2519|     ush    method;
2520|     ulg    extra_field_crc;
2521| 
2522| 
2523|     method = makeword(src);
2524|     extra_field_crc = makelong(src+2);
2525| 
2526|     /* compressed extra field exists completely in memory at this location: */
2527|     G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */
2528|     G.incnt = (int)(G.csize = (long)(srcsize - (2 + 4)));
2529|     G.mem_mode = TRUE;
2530|     G.outbufptr = tgt;
2531|     G.outsize = tgtsize;
2532| 
2533|     switch (method) {
2534|         case STORED:
2535|             memcpy((char *)tgt, (char *)G.inptr, (extent)G.incnt);
2536|             G.outcnt = (ulg)G.csize;    /* for CRC calculation */
2537|             break;
2538|         case DEFLATED:
2539| #ifdef USE_DEFLATE64
2540|         case ENHDEFLATED:
2541| #endif
2542|             G.outcnt = 0L;
2543|             if ((r = UZinflate(__G__ (method == ENHDEFLATED))) != 0) {
2544|                 if (!uO.tflag)
2545|                     Info(slide, 0x401, ((char *)slide,
2546|                       LoadFarStringSmall(ErrUnzipNoFile), r == 3?
2547|                       LoadFarString(NotEnoughMem) :
2548|                       LoadFarString(InvalidComprData),
2549|                       LoadFarStringSmall2(Inflate)));
2550|                 error = (r == 3)? PK_MEM3 : PK_ERR;
2551|             }
2552|             if (G.outcnt == 0L)   /* inflate''s final FLUSH sets outcnt */
2553|                 break;
2554|             break;
2555|         default:
2556|             if (uO.tflag)
2557|                 error = PK_ERR | ((int)method << 8);
2558|             else {
2559|                 Info(slide, 0x401, ((char *)slide,
2560|                   LoadFarString(UnsupportedExtraField), method));
2561|                 error = PK_ERR;  /* GRR:  should be passed on up via SetEAs() */
2562|             }
2563|             break;
2564|     }
2565| 
2566|     G.inptr = old_inptr;
2567|     G.incnt = old_incnt;
2568|     G.csize = old_csize;
2569|     G.mem_mode = FALSE;
2570| 
2571|     if (!error) {
2572|         register ulg crcval = crc32(CRCVAL_INITIAL, tgt, (extent)G.outcnt);
2573| 
2574|         if (crcval != extra_field_crc) {
2575|             if (uO.tflag)
2576|                 error = PK_ERR | (DEFLATED << 8);  /* kludge for now */
2577|             else {
2578|                 Info(slide, 0x401, ((char *)slide,
2579|                   LoadFarString(BadExtraFieldCRC), G.zipfn, crcval,
2580|                   extra_field_crc));
2581|                 error = PK_ERR;
2582|             }
2583|         }
2584|     }
2585|     return error;
2586| 
2587| } /* end function memextract() */


*** Examples ***
', '2025-11-17 21:39:07.010118');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (164, 113, 'def19', 'INTEGER_OVERFLOW', 'unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:449: overflow_sink: "e", which might have underflowed, is passed to "memset(G.area.Slide + w, 0, e)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  447|           if (u && w <= d)
#  448|           {
#  449|->           memzero(redirSlide + w, e);
#  450|             w += e;
#  451|             d += e;', 'TRUE POSITIVE', 'Tainted data from `readbyte()` is used without explicit validation, and subsequent operations (e.g., lines 406, 414, 420, 444) may lead to unexpected behavior due to signed-to-unsigned conversions, potential underflows, and overflows, which could result in security vulnerabilities, given the lack of clear input sanitization.', '1. **Tainted Data Usage**: The value returned by `readbyte()` is considered tainted (unzip60/explode.c:406). This indicates potential user-controlled input, which, if not properly validated, can lead to security vulnerabilities.

2. **Signed to Unsigned Conversion**: The expression `(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k` might treat a negative value as unsigned (unzip60/explode.c:406). This could potentially lead to unexpected behavior if the input is crafted to exploit this conversion.

3. **Potential Underflow**: Multiple expressions are deemed underflowed because at least one of their arguments has underflowed (e.g., unzip60/explode.c:414, 418, 420, 444). While the code uses unsigned types, which wraps around on underflow, this could still lead to unexpected behavior if the program''s logic does not account for these wrap-arounds.

4. **Assignment and Usage of Potentially Underflowed Value**: The value `d` is assigned a potentially underflowed result `(unsigned int)b & mdl` (unzip60/explode.c:420) and later used in arithmetic operations (`d += e`, unzip60/explode.c:451) and as an argument to `memzero()` (indirectly through `e`, unzip60/explode.c:449). This could lead to incorrect memory operations or further propagate the unexpected behavior.

5. **Overflow in Bitwise Operations and Arithmetic**: Expressions like `d &= 0xffffL` and `65536L - (((d &= 0xffffL) > w) ? d : w)` (unzip60/explode.c:444) might overflow, considering the context of potentially underflowed or tainted inputs. This could result in incorrect calculations or memory access.

6. **Lack of Explicit Input Validation or Sanitization**: Based on the provided code, there''s no clear evidence of input validation or sanitization for the tainted data from `readbyte()` or the handling of potential underflows/overflows in a security context. This lack of explicit handling increases the likelihood of a vulnerability.', 'Provide detailed documentation or comments on the expected behavior of `readbyte()` and how its returned value is validated or sanitized.

Clarify the implementation specifics of `memzero` (especially since its source code implementation has been overridden by a builtin model) to ensure it safely handles potentially underflowed values.

Verify the decompression logic''s resilience to crafted inputs that might exploit the identified potential underflows and signed to unsigned conversions.', 0.0000, '*** Source Code Context ***

code of explode.c file:
371| static int explode_nolit(__G__ tl, td, bl, bd, bdl)
372|      __GDEF
373| struct huft *tl, *td;   /* length and distance decoder tables */
374| unsigned bl, bd;        /* number of bits decoded by tl[] and td[] */
375| unsigned bdl;           /* number of distance low bits */
376| /* Decompress the imploded data using uncoded literals and a sliding
377|    window (of size 2^(6+bdl) bytes). */
378| {
379|   zusz_t s;             /* bytes to decompress */
380|   register unsigned e;  /* table entry flag/number of extra bits */
381|   unsigned n, d;        /* length and index for copy */
382|   unsigned w;           /* current window position */
383|   struct huft *t;       /* pointer to table entry */
384|   unsigned ml, md;      /* masks for bl and bd bits */
385|   unsigned mdl;         /* mask for bdl (distance lower) bits */
386|   register ulg b;       /* bit buffer */
387|   register unsigned k;  /* number of bits in bit buffer */
388|   unsigned u;           /* true if unflushed */
389|   int retval = 0;       /* error code returned: initialized to "no error" */
390| 
391| 
392|   /* explode the coded data */
393|   b = k = w = 0;                /* initialize bit buffer, window */
394|   u = 1;                        /* buffer unflushed */
395|   ml = mask_bits[bl];           /* precompute masks for speed */
396|   md = mask_bits[bd];
397|   mdl = mask_bits[bdl];
398|   s = G.lrec.ucsize;
399|   while (s > 0)                 /* do until ucsize bytes uncompressed */
400|   {
401|     NEEDBITS(1)
402|     if (b & 1)                  /* then literal--get eight bits */
403|     {
404|       DUMPBITS(1)
405|       s--;
406|       NEEDBITS(8)
407|       redirSlide[w++] = (uch)b;
408|       if (w == wszimpl)
409|       {
410|         if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
411|           return retval;
412|         w = u = 0;
413|       }
414|       DUMPBITS(8)
415|     }
416|     else                        /* else distance/length */
417|     {
418|       DUMPBITS(1)
419|       NEEDBITS(bdl)             /* get distance low bits */
420|       d = (unsigned)b & mdl;
421|       DUMPBITS(bdl)
422|       DECODEHUFT(td, bd, md)    /* get coded distance high bits */
423|       d = w - d - t->v.n;       /* construct offset */
424|       DECODEHUFT(tl, bl, ml)    /* get coded length */
425|       n = t->v.n;
426|       if (e)                    /* get length extra bits */
427|       {
428|         NEEDBITS(8)
429|         n += (unsigned)b & 0xff;
430|         DUMPBITS(8)
431|       }
432| 
433|       /* do the copy */
434|       s = (s > (zusz_t)n ? s - (zusz_t)n : 0);
435|       do {
436| #if (defined(DLL) && !defined(NO_SLIDE_REDIR))
437|         if (G.redirect_slide) {
438|           /* &= w/ wszimpl not needed and wrong if redirect */
439|           if (d >= wszimpl)
440|             return 1;
441|           e = wszimpl - (d > w ? d : w);
442|         } else
443| #endif
444|           e = wszimpl - ((d &= wszimpl-1) > w ? d : w);
445|         if (e > n) e = n;
446|         n -= e;
447|         if (u && w <= d)
448|         {
449|           memzero(redirSlide + w, e);
450|           w += e;
451|           d += e;
452|         }
453|         else
454| #ifndef NOMEMCPY
455|           if (w - d >= e)       /* (this test assumes unsigned comparison) */
456|           {
457|             memcpy(redirSlide + w, redirSlide + d, e);
458|             w += e;
459|             d += e;
460|           }
461|           else                  /* do it slow to avoid memcpy() overlap */
462| #endif /* !NOMEMCPY */
463|             do {
464|               redirSlide[w++] = redirSlide[d++];
465|             } while (--e);
466|         if (w == wszimpl)
467|         {
468|           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
469|             return retval;
470|           w = u = 0;
471|         }
472|       } while (n);
473|     }
474|   }
475| 
476|   /* flush out redirSlide */
477|   if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
478|     return retval;
479|   if (G.csize + G.incnt + (k >> 3))   /* should have read csize bytes, but */
480|   {                        /* sometimes read one too many:  k>>3 compensates */
481|     G.used_csize = G.lrec.csize - G.csize - G.incnt - (k >> 3);
482|     return 5;
483|   }
484|   return 0;
485| }

code of /shared-data/source/unzip60/unzpriv.h file:
1292| #  define memzero(dest,len)      memset(dest,0,len)


2326| int      fillinbuf            OF((__GPRO));

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:451: overflow: The expression "d += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:464: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
#  462|   #endif /* !NOMEMCPY */
#  463|               do {
#  464|->               redirSlide[w++] = redirSlide[d++];
#  465|               } while (--e);
#  466|           if (w == wszimpl)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/explode.c:406: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/explode.c:406: overflow: The expression "(ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/explode.c:406: overflow: The expression "b |= (ulg)((G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()) << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:414: overflow: The expression "b >>= 8" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:418: overflow: The expression "b >>= 1" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: overflow: The expression "(unsigned int)b & mdl" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:420: assign: Assigning: "d" = "(unsigned int)b & mdl".
unzip60/explode.c:444: overflow: The expression "d &= 0xffffL" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: overflow: The expression "65536L - (((d &= 0xffffL) > w) ? d : w)" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:444: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/explode.c:450: overflow: The expression "w += e" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/explode.c:468: overflow_sink: "(ulg)w", which might have underflowed, is passed to "flush(G.area.Slide, (ulg)w, 0)".
#  466|           if (w == wszimpl)
#  467|           {
#  468|->           if ((retval = flush(__G__ redirSlide, (ulg)w, 0)) != 0)
#  469|               return retval;
#  470|             w = u = 0;
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010118');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (165, 113, 'def20', 'UNINIT', 'unzip60/inflate.c:1582: var_decl: Declaring variable "r" without initializer.
unzip60/inflate.c:1733: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
# 1731|         f = 1 << (k - w);
# 1732|         for (j = i >> w; j < z; j += f)
# 1733|->         q[j] = r;
# 1734|   
# 1735|         /* backwards increment the k-bit code i */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:1582: var_decl: Declaring variable "r" without initializer.
unzip60/inflate.c:1733: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
# 1731|         f = 1 << (k - w);
# 1732|         for (j = i >> w; j < z; j += f)
# 1733|->         q[j] = r;
# 1734|   
# 1735|         /* backwards increment the k-bit code i */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
unzip60/inflate.c:1582: var_decl: Declaring variable "r" without initializer.
unzip60/inflate.c:1733: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
# 1731|         f = 1 << (k - w);
# 1732|         for (j = i >> w; j < z; j += f)
# 1733|->         q[j] = r;
# 1734|   
# 1735|         /* backwards increment the k-bit code i */
(Example-1) Reason Marked as False Positive:
The struct values are initialized starting at line1716

', '2025-11-17 21:39:07.010119');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (166, 113, 'def21', 'INTEGER_OVERFLOW', 'unzip60/process.c:1258: tainted_data_argument: The value "*byterecL" is considered tainted.
unzip60/process.c:1274: tainted_data_transitive: Call to function "makeint64" with tainted argument "byterecL" returns tainted data.
unzip60/process.c:1274: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/process.c:1322: underflow: The cast of "ecrec64_start_offset" to a signed type could result in a negative number.
# 1320|       G.cur_zipfile_bufstart = zftello(G.zipfd);
# 1321|   #else /* !USE_STRM_INPUT */
# 1322|->     G.cur_zipfile_bufstart = zlseek(G.zipfd, ecrec64_start_offset, SEEK_SET);
# 1323|   #endif /* ?USE_STRM_INPUT */
# 1324|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/process.c:1258: tainted_data_argument: The value "*byterecL" is considered tainted.
unzip60/process.c:1274: tainted_data_transitive: Call to function "makeint64" with tainted argument "byterecL" returns tainted data.
unzip60/process.c:1274: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/process.c:1322: underflow: The cast of "ecrec64_start_offset" to a signed type could result in a negative number.
# 1320|       G.cur_zipfile_bufstart = zftello(G.zipfd);
# 1321|   #else /* !USE_STRM_INPUT */
# 1322|->     G.cur_zipfile_bufstart = zlseek(G.zipfd, ecrec64_start_offset, SEEK_SET);
# 1323|   #endif /* ?USE_STRM_INPUT */
# 1324|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
unzip60/process.c:1258: tainted_data_argument: The value "*byterecL" is considered tainted.
unzip60/process.c:1274: tainted_data_transitive: Call to function "makeint64" with tainted argument "byterecL" returns tainted data.
unzip60/process.c:1274: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
unzip60/process.c:1322: underflow: The cast of "ecrec64_start_offset" to a signed type could result in a negative number.
# 1320|       G.cur_zipfile_bufstart = zftello(G.zipfd);
# 1321|   #else /* !USE_STRM_INPUT */
# 1322|->     G.cur_zipfile_bufstart = zlseek(G.zipfd, ecrec64_start_offset, SEEK_SET);
# 1323|   #endif /* ?USE_STRM_INPUT */
# 1324|
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010119');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (167, 113, 'def22', 'INTEGER_OVERFLOW', 'unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d++", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)
(Example-1) Reason Marked as False Positive:
low level bit operations

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
unzip60/inflate.c:997: tainted_data_return: The value returned by "readbyte()" is considered tainted.
unzip60/inflate.c:997: assign: Assigning: "c" = "(G.incnt-- > 0) ? (int)*G.inptr++ : readbyte()".
unzip60/inflate.c:997: overflow: The expression "(ulg)c << k" might be negative, but is used in a context that treats it as unsigned.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:997: overflow: The expression "b |= (ulg)c << k" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)b & mask_bits[e]" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: overflow: The expression "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:998: assign: Assigning: "d" = "(unsigned int)w - t->v.n - ((unsigned int)b & mask_bits[e])".
unzip60/inflate.c:1012: overflow: The expression "d &= 0xffffU" is deemed underflowed because at least one of its arguments has underflowed.
unzip60/inflate.c:1028: deref_overflow: "d", which might have underflowed, is passed to "G.area.Slide[d++]".
# 1026|   #endif /* !NOMEMCPY */
# 1027|               do {
# 1028|->               redirSlide[w++] = redirSlide[d++];
# 1029|               } while (--e);
# 1030|             if (w == wsize)
(Example-2) Reason Marked as False Positive:
low level bit operations

', '2025-11-17 21:39:07.010119');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (168, 97, 'def1', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:409: alloc_arg: "asprintf" allocates memory that is stored into "filename". [Note: The source code implementation of the function has been overridden by a builtin model.]
adcli-0.9.2/library/adconn.c:436: noescape: Resource "filename" is not freed or pointed-to in "mkstemp".
adcli-0.9.2/library/adconn.c:468: leaked_storage: Variable "filename" going out of scope leaks the storage it points to.
#  466|   
#  467|   	/* This shouldn''t stop joining */
#  468|-> 	return ADCLI_SUCCESS;
#  469|   }
#  470|', 'TRUE POSITIVE', 'Memory allocated for `filename` by `asprintf` (line 409) is not explicitly freed in all execution paths, including error handling (e.g., `if (fd < 0)`) and upon successful execution, before going out of scope (line 468), indicating a potential resource leak (CWE-772).', 'The `asprintf` function allocates memory for `filename` at line 409, which is a legitimate allocation of resources.

In the event of a successful `mkstemp` call (line 436), `filename` is indeed stored in `conn->krb5_conf_snippet` (line 443), but this does not necessarily imply deallocation or proper handling of the original `filename` pointer.

Upon examining the provided code, there is no explicit `free` call for the `filename` variable allocated by `asprintf` in all execution paths.

Specifically, in the error handling path (e.g., `if (fd < 0)`), there is no deallocation of `filename` before the function returns (line 468).

Additionally, even in the successful path, while `conn->krb5_conf_snippet` holds the value, the original `filename` pointer''s allocated memory is not explicitly freed, leading to a potential leak when it goes out of scope (line 468).

Uncertainty about the behavior of the overridden `asprintf` builtin model does not negate the observable lack of deallocation in the provided code; hence, we focus on the explicit code behavior.

Given the direct correlation between the allocated resource (`filename`) and the lack of its deallocation in all execution paths before it goes out of scope, a potential resource leak (CWE-772) is identified.', 'Examine the implementation of `mkstemp` to ensure it does not implicitly free the `filename` pointer.

Investigate the `adconn.c` function''s callers to determine if the allocated memory for `filename` is expected to be freed by the caller.

Analyze the program''s memory management strategy to identify potential indirect deallocation mechanisms for the `filename` pointer, similar to the `adcli_enroll_unref` and `adcli_unret_enroll` patterns observed in the provided false positive examples.', 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
389| static adcli_result
390| setup_krb5_conf_snippet (adcli_conn *conn)
391| {
392| 	char *filename;
393| 	char *snippet;
394| 	char *controller;
395| 	int errn;
396| 	int ret;
397| 	int fd;
398| 	mode_t old_mask;
399| 
400| 	if (!conn->krb5_conf_dir)
401| 		return ADCLI_SUCCESS;
402| 
403| 	/* Already written out the conf snippet */
404| 	if (conn->krb5_conf_snippet)
405| 		return ADCLI_SUCCESS;
406| 
407| 	clear_krb5_conf_snippet (conn);
408| 
409| 	if (asprintf (&filename, "%s/adcli-krb5-conf-XXXXXX", conn->krb5_conf_dir) < 0)
410| 		return_unexpected_if_reached ();
411| 
412| 	if (strchr (conn->domain_controller, '':'')) {
413| 		if (asprintf (&controller, "[%s]", conn->domain_controller) < 0)
414| 			controller = NULL;
415| 	} else {
416| 		controller = strdup (conn->domain_controller);
417| 	}
418| 
419| 	return_unexpected_if_fail (controller != NULL);
420| 
421| 	if (asprintf (&snippet, "[realms]
"
422| 	                        "  %s = {
"
423| 	                        "    kdc = %s:88
"
424| 	                        "    master_kdc = %s:88
"
425| 	                        "    kpasswd_server = %s
"
426| 	                        "  }
"
427| 	                        "[domain_realm]
"
428| 	                        "  %s = %s
"
429| 	                        "  %s = %s
",
430| 	              conn->domain_realm, controller, controller, controller,
431| 	              conn->canonical_host, conn->domain_realm,
432| 	              conn->domain_controller, conn->domain_realm) < 0)
433| 		return_unexpected_if_reached ();
434| 
435| 	old_mask = umask (0177);
436| 	fd = mkstemp (filename);
437| 	umask (old_mask);
438| 	if (fd < 0) {
439| 		_adcli_warn ("Couldn''t create krb5.conf snippet file in: %s: %s",
440| 		             conn->krb5_conf_dir, strerror (errno));
441| 
442| 	} else {
443| 		conn->krb5_conf_snippet = filename;
444| 		ret = _adcli_write_all (fd, snippet, -1);
445| 		errn = errno;
446| 
447| 		if (ret >= 0) {
448| 			ret = close (fd);
449| 			errn = errno;
450| 
451| 		} else {
452| 			close (fd);
453| 		}
454| 
455| 		if (ret < 0) {
456| 			_adcli_warn ("Couldn''t write krb5.conf snippet file in: %s: %s",
457| 			             filename, strerror (errn));
458| 			clear_krb5_conf_snippet (conn);
459| 		} else {
460| 			_adcli_info ("Wrote out krb5.conf snippet to %s", filename);
461| 		}
462| 	}
463| 
464| 	free (controller);
465| 	free (snippet);
466| 
467| 	/* This shouldn''t stop joining */
468| 	return ADCLI_SUCCESS;
469| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025536');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (169, 97, 'def2', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:491: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:492: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  490|   		warnx ("extra arguments specified");
#  491|   		adcli_enroll_unref (enroll);
#  492|-> 		return 2;
#  493|   	}
#  494|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:491: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:492: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  490|    warnx ("extra arguments specified");
#  491|    adcli_enroll_unref (enroll);
#  492|->  return 2;
#  493|   }
#  494|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:491: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:492: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  490|   		warnx ("extra arguments specified");
#  491|   		adcli_enroll_unref (enroll);
#  492|-> 		return 2;
#  493|   	}
#  494|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1212: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1213: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1211|   		warnx ("extra arguments specified");
# 1212|   		adcli_enroll_unref (enroll);
# 1213|-> 		return 2;
# 1214|   	}
# 1215|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025539');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (170, 97, 'def3', 'BAD_FREE', 'adcli-0.9.2/library/adenroll.c:2343: array_address: Taking address of array """".
adcli-0.9.2/library/adenroll.c:2343: assign: Assigning: "name" = """".
adcli-0.9.2/library/adenroll.c:2346: incorrect_free: "krb5_free_unparsed_name" frees incorrect pointer "name".
# 2344|   		res = add_principal_to_keytab (enroll, k5, enroll->keytab_principals[i],
# 2345|   		                               name, &which_salt, flags);
# 2346|-> 		krb5_free_unparsed_name (k5, name);
# 2347|   
# 2348|   		if (res != ADCLI_SUCCESS)', 'TRUE POSITIVE', 'Assignment of a string literal to pointer `name` at line 2343, followed by an incorrect attempt to free it using `krb5_free_unparsed_name` at line 2346, constitutes undefined behavior and directly correlates with the CVE''s description of freeing an incorrect pointer.', '1. **Assignment of Literal to Pointer**: At line 2343, `name` is assigned a string literal `"""` when `krb5_unparse_name` fails. This is problematic because string literals in C are arrays, and taking the address of such an array (as implied by assigning it to a pointer `name`) can lead to issues when later trying to free this memory as if it were dynamically allocated.

2. **Incorrect Free Operation**: The code attempts to free the `name` pointer using `krb5_free_unparsed_name` at line 2346, regardless of whether `name` was successfully parsed (and thus, potentially dynamically allocated by `krb5_unparse_name`) or set to a string literal. Since string literals are not dynamically allocated, attempting to free one results in undefined behavior.

3. **Execution Path Vulnerability**: There is a clear execution path where the vulnerability is triggered: when `krb5_unparse_name` fails (line 2342), `name` is set to a string literal (line 2343), and then an attempt is made to free this literal using `krb5_free_unparsed_name` (line 2346). This path directly correlates with the CVE''s description of freeing an incorrect pointer.

4. **Direct Correlation with CVE Description**: The observed behavior directly matches the CVE report''s description of taking the address of an array (the string literal) and then incorrectly freeing this pointer, satisfying the condition for a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2326| static adcli_result
2327| update_keytab_for_principals (adcli_enroll *enroll,
2328|                               adcli_enroll_flags flags)
2329| {
2330| 	krb5_context k5;
2331| 	adcli_result res;
2332| 	int which_salt = -1;
2333| 	char *name;
2334| 	int i;
2335| 
2336| 	assert (enroll->keytab_principals != NULL);
2337| 
2338| 	k5 = adcli_conn_get_krb5_context (enroll->conn);
2339| 	return_unexpected_if_fail (k5 != NULL);
2340| 
2341| 	for (i = 0; enroll->keytab_principals[i] != 0; i++) {
2342| 		if (krb5_unparse_name (k5, enroll->keytab_principals[i], &name) != 0)
2343| 			name = "";
2344| 		res = add_principal_to_keytab (enroll, k5, enroll->keytab_principals[i],
2345| 		                               name, &which_salt, flags);
2346| 		krb5_free_unparsed_name (k5, name);
2347| 
2348| 		if (res != ADCLI_SUCCESS)
2349| 			return res;
2350| 	}
2351| 
2352| 	if (enroll->service_principals_to_remove != NULL) {
2353| 		for (i = 0; enroll->service_principals_to_remove[i] != NULL; i++) {
2354| 			res = remove_principal_from_keytab (enroll, k5,
2355| 			                                    enroll->service_principals_to_remove[i]);
2356| 			if (res != ADCLI_SUCCESS) {
2357| 				_adcli_warn ("Failed to remove %s from keytab.",
2358| 				             enroll->service_principals_to_remove[i]);
2359| 			}
2360| 		}
2361| 	}
2362| 
2363| 	return ADCLI_SUCCESS;
2364| }


*** Examples ***
', '2025-11-17 21:39:07.025539');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (171, 97, 'def4', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:1524: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:1524: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:1524: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 1522|   
# 1523|   	if (code != 0) {
# 1524|-> 		_adcli_err ("Couldn''t set password for %s account: %s: %s",
# 1525|   		            s_or_c (enroll),
# 1526|   		            enroll->computer_sam, krb5_get_error_message (k5, code));', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 1524 is not explicitly freed within the provided code scope, directly correlating with CWE-772 (Resource Leak) as reported, with no visible deallocation in the `_adcli_err` function or surrounding code.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 1524 is not freed or pointed-to within the `_adcli_err` function.

Upon examining the provided source code, there is no evidence of `krb5_free_error_message` (or any equivalent deallocation function) being called on the return value of `krb5_get_error_message(k5, code)` within the scope of the `if (code != 0)` block (lines 1523-1526).

The lack of explicit deallocation for the allocated storage within the provided code snippet directly correlates with the CWE (Common Weakness Enumeration) description of a Resource Leak (CWE-772), as reported.

There is no indication within the provided code that the memory allocated by `krb5_get_error_message` is freed in a subsequent, non-visible part of the `_adcli_err` function or in any other part of the provided source code context.

Given the explicit behavior of the provided source code and the description in the CVE report, there is a direct and demonstrable link between the code''s behavior and the vulnerability described, satisfying the condition for a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
1493| static adcli_result
1494| set_password_with_user_creds (adcli_enroll *enroll)
1495| {
1496| 	krb5_error_code code;
1497| 	krb5_ccache ccache;
1498| 	krb5_context k5;
1499| 	krb5_data result_string = { 0, };
1500| 	krb5_data result_code_string = { 0, };
1501| 	adcli_result res;
1502| 	int result_code;
1503| 	char *message;
1504| 
1505| 	assert (enroll->computer_password != NULL);
1506| 	assert (enroll->computer_principal != NULL);
1507| 
1508| 	k5 = adcli_conn_get_krb5_context (enroll->conn);
1509| 	return_unexpected_if_fail (k5 != NULL);
1510| 
1511| 	ccache = adcli_conn_get_login_ccache (enroll->conn);
1512| 	return_unexpected_if_fail (ccache != NULL);
1513| 
1514| 	memset (&result_string, 0, sizeof (result_string));
1515| 	memset (&result_code_string, 0, sizeof (result_code_string));
1516| 
1517| 	_adcli_info ("Trying to set %s password with Kerberos", s_or_c (enroll));
1518| 
1519| 	code = krb5_set_password_using_ccache (k5, ccache, enroll->computer_password,
1520| 	                                       enroll->computer_principal, &result_code,
1521| 	                                       &result_code_string, &result_string);
1522| 
1523| 	if (code != 0) {
1524| 		_adcli_err ("Couldn''t set password for %s account: %s: %s",
1525| 		            s_or_c (enroll),
1526| 		            enroll->computer_sam, krb5_get_error_message (k5, code));
1527| 		/* TODO: Parse out these values */
1528| 		res = ADCLI_ERR_DIRECTORY;
1529| 
1530| 	} else if (result_code != 0) {
1531| #ifdef HAVE_KRB5_CHPW_MESSAGE
1532| 		if (krb5_chpw_message (k5, &result_string, &message) != 0)
1533| 			message = NULL;
1534| #else
1535| 		message = NULL;
1536| 		if (result_string.length)
1537| 			message = _adcli_str_dupn (result_string.data, result_string.length);
1538| #endif
1539| 		_adcli_err ("Cannot set %s password: %.*s%s%s",
1540| 		            s_or_c (enroll),
1541| 		            (int)result_code_string.length, result_code_string.data,
1542| 		            message ? ": " : "", message ? message : "");
1543| 		res = ADCLI_ERR_CREDENTIALS;
1544| #ifdef HAVE_KRB5_CHPW_MESSAGE
1545| 		krb5_free_string (k5, message);
1546| #else
1547| 		free (message);
1548| #endif
1549| 	} else {
1550| 		_adcli_info ("Set %s password", s_or_c (enroll));
1551| 		if (enroll->kvno > 0) {
1552| 			enroll->kvno++;
1553| 			_adcli_info ("kvno incremented to %d", enroll->kvno);
1554| 		}
1555| 		res = ADCLI_SUCCESS;
1556| 	}
1557| 
1558| 	krb5_free_data_contents (k5, &result_string);
1559| 	krb5_free_data_contents (k5, &result_code_string);
1560| 
1561| 	return res;
1562| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|   		       adcli_get_last_error ());
#  827|   		adcli_enroll_unref (enroll);
#  828|-> 		return -res;
#  829|   	}
#  830|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025539');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (172, 97, 'def5', 'USE_AFTER_FREE', 'adcli-0.9.2/library/adutil.c:887: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:896: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  894|   	                                    &stdout_data, &stdout_data_len);
#  895|   	assert (res == ADCLI_SUCCESS);
#  896|-> 	assert (strncmp ("Hello\n", (char *) stdout_data, stdout_data_len) == 0);
#  897|   	free (stdout_data);
#  898|   #endif', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/library/adutil.c:887: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:896: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  894|                                    &stdout_data, &stdout_data_len);
#  895|   assert (res == ADCLI_SUCCESS);
#  896|-> assert (strncmp ("Hello\n", (char *) stdout_data, stdout_data_len) == 0);
#  897|   free (stdout_data);
#  898|  #endif', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:887: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:896: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  894|   	                                    &stdout_data, &stdout_data_len);
#  895|   	assert (res == ADCLI_SUCCESS);
#  896|-> 	assert (strncmp ("Hello
", (char *) stdout_data, stdout_data_len) == 0);
#  897|   	free (stdout_data);
#  898|   #endif
(Example-1) Reason Marked as False Positive:
After the `free()` in line 887 there is a function call which allocates new memory for `stdout_data`.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:865: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:877: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  875|   	                                    &stdout_data, &stdout_data_len);
#  876|   	assert (res == ADCLI_SUCCESS);
#  877|-> 	assert (strncmp ("olleH
", (char *) stdout_data, stdout_data_len) == 0);
#  878|   	free (stdout_data);
#  879|   #endif
(Example-2) Reason Marked as False Positive:
After the `free()` in line 865 there is a function call which allocates new memory for `stdout_data`.

', '2025-11-17 21:39:07.02554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (173, 97, 'def6', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:900: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:902: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:903: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  901|   			if (res != ADCLI_SUCCESS) {
#  902|   				adcli_enroll_unref (enroll);
#  903|-> 				return res;
#  904|   			}
#  905|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:900: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:902: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:903: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  901|   ifndef (res != ADCLI_SUCCESS) {
#  902|    adcli_enroll_unref (enroll);
#  903|-> return res;
#  904|    
#  905|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:900: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:902: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:903: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  901|   			if (res != ADCLI_SUCCESS) {
#  902|   				adcli_enroll_unref (enroll);
#  903|-> 				return res;
#  904|   			}
#  905|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:699: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:701: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:702: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  700|   			if (res != ADCLI_SUCCESS) {
#  701|   				adcli_enroll_unref (enroll);
#  702|-> 				return res;
#  703|   			}
#  704|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.02554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (174, 97, 'def7', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:366: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adconn.c:366: noescape: Resource "krb5_get_error_message(conn->k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adconn.c:366: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(conn->k5, code)" leaks it.
#  364|   	} else {
#  365|   		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
#  366|-> 			_adcli_err ("Couldn''t get kerberos ticket for machine account: %s: %s",
#  367|   			            name, krb5_get_error_message (conn->k5, code));
#  368|   		} else {', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at `adconn.c:366` is not explicitly freed within the provided code, and the unclear implementation of `_adcli_err` (declared in `adprivate.h`) prevents assumption of automatic memory deallocation, directly correlating with a Resource Leak (CWE-772).', '1. **Explicit Allocation**: The CVE report correctly identifies `krb5_get_error_message(conn->k5, code)` at `adconn.c:366` as an allocation function, which returns dynamically allocated storage.

2. **Lack of Freeing Mechanism**: Within the provided code snippet, there is no explicit call to free the storage allocated by `krb5_get_error_message` after it is used in the `_adcli_err` function. The code provided does not show the implementation of `_adcli_err`, but based on the `noescape` warning, it is inferred that the resource is not freed or pointed-to within this function.

3. **Unclear `_adcli_err` Implementation**: Since the implementation of `_adcli_err` (declared in `adprivate.h` at line 107) is not provided, we cannot assume it automatically frees the allocated memory. Without explicit proof of memory deallocation within the provided code context, we must err on the side of caution.

4. **Direct Correlation to CWE Description**: The described behavior directly correlates with a Resource Leak (CWE-772), as the allocated storage is not explicitly freed, leading to a potential memory leak.

5. **Single Vulnerable Path Identified**: The execution path leading to the allocation and potential leak is clearly identified (when `type == ADCLI_LOGIN_COMPUTER_ACCOUNT` and the error condition is met), satisfying the condition for a TRUE POSITIVE finding.', 'Obtain and analyze the implementation or documentation of the `_adcli_err` function to determine its handling of the allocated storage from `krb5_get_error_message`.

Investigate the call stack and execution paths leading from and to `_adcli_err` to identify any potential memory deallocation or reuse.', 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
336| static adcli_result
337| handle_kinit_krb5_code (adcli_conn *conn,
338|                         adcli_login_type type,
339|                         const char *name,
340|                         krb5_error_code code)
341| {
342| 	if (code == 0) {
343| 		return ADCLI_SUCCESS;
344| 
345| 	} else if (code == ENOMEM) {
346| 		return_unexpected_if_reached ();
347| 
348| 	} else if (code == KRB5KDC_ERR_PREAUTH_FAILED ||
349| 	           code == KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ||
350| 	           code == KRB5KDC_ERR_KEY_EXP ||
351| 	           code == KRB5KDC_ERR_CLIENT_REVOKED ||
352| 	           code == KRB5KDC_ERR_POLICY ||
353| 	           code == KRB5KDC_ERR_ETYPE_NOSUPP ||
354| 	           code == KRB5_PREAUTH_FAILED) {
355| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
356| 			_adcli_err ("Couldn''t authenticate as machine account: %s: %s",
357| 			            name, krb5_get_error_message (conn->k5, code));
358| 		} else {
359| 			_adcli_err ("Couldn''t authenticate as: %s: %s",
360| 			            name, krb5_get_error_message (conn->k5, code));
361| 		}
362| 		return ADCLI_ERR_CREDENTIALS;
363| 
364| 	} else {
365| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
366| 			_adcli_err ("Couldn''t get kerberos ticket for machine account: %s: %s",
367| 			            name, krb5_get_error_message (conn->k5, code));
368| 		} else {
369| 			_adcli_err ("Couldn''t get kerberos ticket for: %s: %s",
370| 			            name, krb5_get_error_message (conn->k5, code));
371| 		}
372| 		return ADCLI_ERR_DIRECTORY;
373| 	}
374| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025541');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (175, 97, 'def8', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:1597: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:1597: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:1597: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 1595|   
# 1596|   	if (code != 0) {
# 1597|-> 		_adcli_err ("Couldn''t change password for %s account: %s: %s",
# 1598|   		            s_or_c (enroll),
# 1599|   		            enroll->computer_sam, krb5_get_error_message (k5, code));', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 1597 is not explicitly freed or handled within the provided code scope, including within the `_adcli_err` function call, supporting the leaked storage claim.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 1597 is not freed or pointed-to within the `_adcli_err` function call.

The provided source code snippet does not show any explicit memory management (freeing) for the storage allocated by `krb5_get_error_message(k5, code)` after its use in `_adcli_err` at line 1597.

There is no evidence within the provided code that the memory allocated by `krb5_get_error_message(k5, code)` is handled (e.g., freed, stored for later freeing) outside of the shown scope, particularly after the `_adcli_err` function call.

The function `_adcli_err` is not defined within the provided source code context, but based on its usage, there is no indication that it assumes ownership of the error message string and frees it. The lack of explicit memory handling for this allocation within the provided code scope supports the leak claim.

Given the direct correlation between the code''s behavior at line 1597 and the vulnerability described in the CVE (leaked storage from `krb5_get_error_message`), and without explicit proof of memory handling for this allocation, the finding cannot be conclusively marked as a FALSE POSITIVE.', 'Obtain and examine the implementation of the `_adcli_err` function to determine if it handles the allocated memory from `krb5_get_error_message`.

Verify if there are any other execution paths or functions called within the context that might free the allocated storage.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
1564| static adcli_result
1565| set_password_with_computer_creds (adcli_enroll *enroll)
1566| {
1567| 	krb5_error_code code;
1568| 	krb5_creds creds;
1569| 	krb5_data result_string = { 0, };
1570| 	krb5_data result_code_string = { 0, };
1571| 	krb5_context k5;
1572| 	int result_code;
1573| 	adcli_result res;
1574| 	char *message;
1575| 
1576| 	memset (&creds, 0, sizeof (creds));
1577| 
1578| 	k5 = adcli_conn_get_krb5_context (enroll->conn);
1579| 	return_unexpected_if_fail (k5 != NULL);
1580| 
1581| 	_adcli_info ("Trying to change %s password with Kerberos", s_or_c (enroll));
1582| 
1583| 	code = _adcli_kinit_computer_creds (enroll->conn, "kadmin/changepw", NULL, &creds);
1584| 	if (code != 0) {
1585| 		_adcli_err ("Couldn''t get change password ticket for %s account: %s: %s",
1586| 		            s_or_c (enroll),
1587| 		            enroll->computer_sam, krb5_get_error_message (k5, code));
1588| 		return ADCLI_ERR_DIRECTORY;
1589| 	}
1590| 
1591| 	code = krb5_change_password (k5, &creds, enroll->computer_password,
1592| 	                             &result_code, &result_code_string, &result_string);
1593| 
1594| 	krb5_free_cred_contents (k5, &creds);
1595| 
1596| 	if (code != 0) {
1597| 		_adcli_err ("Couldn''t change password for %s account: %s: %s",
1598| 		            s_or_c (enroll),
1599| 		            enroll->computer_sam, krb5_get_error_message (k5, code));
1600| 		/* TODO: Parse out these values */
1601| 		res = ADCLI_ERR_DIRECTORY;
1602| 
1603| 	} else if (result_code != 0) {
1604| #ifdef HAVE_KRB5_CHPW_MESSAGE
1605| 		if (krb5_chpw_message (k5, &result_string, &message) != 0)
1606| 			message = NULL;
1607| #else
1608| 		message = NULL;
1609| 		if (result_string.length)
1610| 			message = _adcli_str_dupn (result_string.data, result_string.length);
1611| #endif
1612| 		_adcli_err ("Cannot change computer password: %.*s%s%s",
1613| 		            (int)result_code_string.length, result_code_string.data,
1614| 		            message ? ": " : "", message ? message : "");
1615| 		res = ADCLI_ERR_CREDENTIALS;
1616| #ifdef HAVE_KRB5_CHPW_MESSAGE
1617| 		krb5_free_string (k5, message);
1618| #else
1619| 		free (message);
1620| #endif
1621| 	} else {
1622| 		_adcli_info ("Changed computer password");
1623| 		if (enroll->kvno > 0) {
1624| 			enroll->kvno++;
1625| 		        _adcli_info ("kvno incremented to %d", enroll->kvno);
1626| 		}
1627| 		res = ADCLI_SUCCESS;
1628| 	}
1629| 
1630| 	krb5_free_data_contents (k5, &result_string);
1631| 	krb5_free_data_contents (k5, &result_code_string);
1632| 
1633| 	return res;
1634| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|   		       adcli_get_last_error ());
#  827|   		adcli_enroll_unref (enroll);
#  828|-> 		return -res;
#  829|   	}
#  830|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025541');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (229, 94, 'def2', 'nan', 'nan', 'FALSE POSITIVE', 'Investigation yields FALSE POSITIVE due to insufficient information: no CVE report snippet, source code context, or comparative examples were provided to facilitate a conclusive vulnerability assessment.', 'No CVE Report Snippet is provided to analyze against the source code.

No Source Code Context is provided to examine for potential vulnerabilities.

No Examples of verified CVEs with the same CWE are provided for comparative analysis.

Without explicit information about the CVE, source code, and comparative examples, a conclusive determination of TRUE POSITIVE or FALSE POSITIVE based on the provided instructions is impossible.', 'Provide the complete CVE report snippet for the reported vulnerability.

Share the relevant source code context (including specific file paths) to facilitate a thorough examination for potential vulnerabilities.

Supply examples of validated CVEs with the same CWE as the reported vulnerability for comparative analysis purposes.

Ensure all instructed evaluation steps can be followed with the provided information to guarantee a conclusive assessment.', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:07.041399');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (176, 97, 'def9', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adkrb5.c:202: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adkrb5.c:202: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adkrb5.c:202: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
#  200|   		code = krb5_kt_default (k5, keytab);
#  201|   		if (code != 0) {
#  202|-> 			_adcli_err ("Failed to open default keytab: %s",
#  203|   			            krb5_get_error_message (k5, code));
#  204|   			return ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 202 is passed to `_adcli_err` without being freed, and no freeing function is called within the provided error handling block (lines 201-204), with no explicit evidence of internal memory management within `_adcli_err`.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 202 is not freed or pointed-to within the `_adcli_err` function.

The provided source code confirms this: the return value of `krb5_get_error_message(k5, code)` is passed directly to `_adcli_err` without being stored or freed (lines 202-203).

There is no visible call to a freeing function (e.g., `free`, `krb5_free_error_message`, etc.) for the allocated storage within the provided code snippet, specifically within the execution path of the error handling block (lines 201-204).

The function `_adcli_err` is not defined within the provided source code context, but based on the explicit behavior of the provided code, there is no evidence that `_adcli_err` internally frees the memory allocated by `krb5_get_error_message`.

Given the lack of explicit memory management for the allocated storage within the provided code, and adhering to the guideline that ''No Clear False Positive Evidence Implies True Positive'', this finding cannot be conclusively marked as a FALSE POSITIVE based solely on the provided information.', 'Obtain and analyze the implementation of the `_adcli_err` function to determine if it internally handles the memory allocated by `krb5_get_error_message`.

Verify if there are any other execution paths in `adkrb5.c` that could potentially free the allocated storage, not visible in the provided snippet.', 0.0000, '*** Source Code Context ***

code of library/adkrb5.c file:
184| adcli_result
185| _adcli_krb5_open_keytab (krb5_context k5,
186|                          const char *keytab_name,
187| 		         krb5_keytab *keytab)
188| {
189| 	krb5_error_code code;
190| 
191| 	if (keytab_name && strcmp (keytab_name, "") != 0) {
192| 		code = krb5_kt_resolve (k5, keytab_name, keytab);
193| 		if (code != 0) {
194| 			_adcli_err ("Failed to open keytab: %s: %s",
195| 			            keytab_name, krb5_get_error_message (k5, code));
196| 			return ADCLI_ERR_FAIL;
197| 		}
198| 
199| 	} else {
200| 		code = krb5_kt_default (k5, keytab);
201| 		if (code != 0) {
202| 			_adcli_err ("Failed to open default keytab: %s",
203| 			            krb5_get_error_message (k5, code));
204| 			return ADCLI_ERR_FAIL;
205| 		}
206| 	}
207| 
208| 	return ADCLI_SUCCESS;
209| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025541');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (177, 97, 'def10', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:798: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:799: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  797|   			adcli_tool_usage (options, common_usages);
#  798|   			adcli_enroll_unref (enroll);
#  799|-> 			return 2;
#  800|   		default:
#  801|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:798: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:799: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  797|    		adcli_tool_usage (options, common_usages);
#  798|    		adcli_enroll_unref (enroll);
#  799|-> 		return 2;
#  800|    	default:
#  801|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:798: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:799: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  797|   			adcli_tool_usage (options, common_usages);
#  798|   			adcli_enroll_unref (enroll);
#  799|-> 			return 2;
#  800|   		default:
#  801|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:897: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:898: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  896|   			adcli_tool_usage (options, common_usages);
#  897|   			adcli_enroll_unref (enroll);
#  898|-> 			return opt == ''h'' ? 0 : 2;
#  899|   		default:
#  900|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025542');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (178, 97, 'def11', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1082: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1083: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1081|   			adcli_tool_usage (options, common_usages);
# 1082|   			adcli_enroll_unref (enroll);
# 1083|-> 			return opt == ''h'' ? 0 : 2;
# 1084|   		default:
# 1085|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1082: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1083: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1081|    adcli_tool_usage (options, common_usages);
# 1082|    adcli_enroll_unref (enroll);
# 1083|-> return opt == ''h'' ? 0 : 2;
# 1084|    default:
# 1085|    res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1082: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1083: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1081|   			adcli_tool_usage (options, common_usages);
# 1082|   			adcli_enroll_unref (enroll);
# 1083|-> 			return opt == ''h'' ? 0 : 2;
# 1084|   		default:
# 1085|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|   			adcli_tool_usage (options, common_usages);
#  985|   			adcli_enroll_unref (enroll);
#  986|-> 			return opt == ''h'' ? 0 : 2;
#  987|   		default:
#  988|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025542');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (179, 97, 'def12', 'UNINIT', 'adcli-0.9.2/library/test.c:182: var_decl: Declaring variable "item" without initializer.
adcli-0.9.2/library/test.c:188: uninit_use_in_call: Using uninitialized value "item". Field "item.next" is uninitialized when calling "test_push".
#  186|   	item.x.fix.teardown = teardown;
#  187|   
#  188|-> 	test_push (&item);
#  189|   }
#  190|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/library/test.c:182: var_decl: Declaring variable "item" without initializer.
adcli-0.9.2/library/test.c:188: uninit_use_in_call: Using uninitialized value "item". Field "item.next" is uninitialized when calling "test_push".
#  186|    item.x.fix.teardown = teardown;
#  187|   
#  188|->  test_push (&item);
#  189|   }
#  190|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
adcli-0.9.2/library/test.c:182: var_decl: Declaring variable "item" without initializer.
adcli-0.9.2/library/test.c:188: uninit_use_in_call: Using uninitialized value "item". Field "item.next" is uninitialized when calling "test_push".
#  186|   	item.x.fix.teardown = teardown;
#  187|   
#  188|-> 	test_push (&item);
#  189|   }
#  190|
(Example-1) Reason Marked as False Positive:
It is expected that `item.next` is not set, it will be set explicitly in `test_push()`.

', '2025-11-17 21:39:07.025542');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (180, 97, 'def13', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|   		       adcli_get_last_error ());
#  827|   		adcli_enroll_unref (enroll);
#  828|-> 		return -res;
#  829|   	}
#  830|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|      adcli_get_last_error ());
#  827|     adcli_enroll_unref (enroll);
#  828|->  return -res;
#  829|   }
#  830|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|   		       adcli_get_last_error ());
#  827|   		adcli_enroll_unref (enroll);
#  828|-> 		return -res;
#  829|   	}
#  830|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025543');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (181, 97, 'def14', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:2315: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:2315: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:2315: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 2313|   
# 2314|   	if (code != 0) {
# 2315|-> 		_adcli_err ("Couldn''t add keytab entries: %s: %s",
# 2316|   		            enroll->keytab_name, krb5_get_error_message (k5, code));
# 2317|   		return ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 2315 is passed to `_adcli_err` without visible deallocation, leading to a potential leak, as no corresponding free function is called within the provided code scope.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 2315 is not freed or pointed-to within the `_adcli_err` function.

The code at line 2315 directly allocates storage via `krb5_get_error_message` and passes the result to `_adcli_err` without any apparent mechanism for freeing this storage.

There is no visible call to a corresponding deallocation function (e.g., `krb5_free_error_message` or similar) for the allocated storage in the provided code snippet, specifically within the scope of the `_adcli_err` call or after it.

The execution path leading to this allocation is conditional (`if (code != 0)` at line 2314), but this condition does not affect the fact that, when met, the allocation occurs without subsequent deallocation in the provided code.

No evidence within the provided source code context suggests that `_adcli_err` internally frees the storage allocated by `krb5_get_error_message`, which would be necessary to prevent a leak.

Given the direct allocation without apparent deallocation in the provided code, and adhering to the guideline that a single vulnerable path is sufficient for a TRUE POSITIVE finding, this issue cannot be considered a FALSE POSITIVE based on the provided information.', NULL, 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2235| static adcli_result
2236| add_principal_to_keytab (adcli_enroll *enroll,
2237|                          krb5_context k5,
2238|                          krb5_principal principal,
2239|                          const char *principal_name,
2240|                          int *which_salt,
2241|                          adcli_enroll_flags flags)
2242| {
2243| 	match_principal_kvno closure;
2244| 	krb5_data password;
2245| 	krb5_error_code code;
2246| 	krb5_data *salts;
2247| 	krb5_enctype *enctypes;
2248| 
2249| 	/* Remove old stuff from the keytab for this principal */
2250| 
2251| 	closure.kvno = enroll->kvno;
2252| 	closure.principal = principal;
2253| 	closure.matched = 0;
2254| 
2255| 	code = _adcli_krb5_keytab_clear (k5, enroll->keytab,
2256| 	                                 match_principal_and_kvno, &closure);
2257| 
2258| 	if (code != 0) {
2259| 		_adcli_err ("Couldn''t update keytab: %s: %s",
2260| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2261| 		return ADCLI_ERR_FAIL;
2262| 	}
2263| 
2264| 	if (closure.matched) {
2265| 		_adcli_info ("Cleared old entries from keytab: %s",
2266| 		             enroll->keytab_name);
2267| 	}
2268| 
2269| 	enctypes = adcli_enroll_get_permitted_keytab_enctypes (enroll);
2270| 	if (enctypes == NULL) {
2271| 		_adcli_warn ("No permitted encryption type found.");
2272| 		return ADCLI_ERR_UNEXPECTED;
2273| 	}
2274| 
2275| 	if (flags & ADCLI_ENROLL_PASSWORD_VALID) {
2276| 		code = _adcli_krb5_keytab_copy_entries (k5, enroll->keytab, principal,
2277| 		                                        enroll->kvno, enctypes);
2278| 	} else {
2279| 
2280| 		password.data = enroll->computer_password;
2281| 		password.length = strlen (enroll->computer_password);
2282| 
2283| 		/*
2284| 		 * So we need to discover which salt to use. As a side effect we are
2285| 		 * also testing that our account works.
2286| 		 */
2287| 
2288| 		salts = build_principal_salts (enroll, k5, principal);
2289| 		if (salts == NULL) {
2290| 			krb5_free_enctypes (k5, enctypes);
2291| 			return ADCLI_ERR_UNEXPECTED;
2292| 		}
2293| 
2294| 		if (*which_salt < 0) {
2295| 			code = _adcli_krb5_keytab_discover_salt (k5, principal, enroll->kvno, &password,
2296| 			                                         enctypes, salts, which_salt);
2297| 			if (code != 0) {
2298| 				_adcli_warn ("Couldn''t authenticate with keytab while discovering which salt to use: %s: %s",
2299| 				             principal_name, krb5_get_error_message (k5, code));
2300| 				*which_salt = DEFAULT_SALT;
2301| 			} else {
2302| 				assert (*which_salt >= 0);
2303| 				_adcli_info ("Discovered which keytab salt to use");
2304| 			}
2305| 		}
2306| 
2307| 		code = _adcli_krb5_keytab_add_entries (k5, enroll->keytab, principal,
2308| 		                                       enroll->kvno, &password, enctypes, &salts[*which_salt]);
2309| 
2310| 		free_principal_salts (k5, salts);
2311| 	}
2312| 	krb5_free_enctypes (k5, enctypes);
2313| 
2314| 	if (code != 0) {
2315| 		_adcli_err ("Couldn''t add keytab entries: %s: %s",
2316| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2317| 		return ADCLI_ERR_FAIL;
2318| 	}
2319| 
2320| 
2321| 	_adcli_info ("Added the entries to the keytab: %s: %s",
2322| 	             principal_name, enroll->keytab_name);
2323| 	return ADCLI_SUCCESS;
2324| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025543');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (182, 97, 'def15', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:2298: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:2298: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_warn".
adcli-0.9.2/library/adenroll.c:2298: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 2296|   			                                         enctypes, salts, which_salt);
# 2297|   			if (code != 0) {
# 2298|-> 				_adcli_warn ("Couldn''t authenticate with keytab while discovering which salt to use: %s: %s",
# 2299|   				             principal_name, krb5_get_error_message (k5, code));
# 2300|   				*which_salt = DEFAULT_SALT;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 2298 is not freed or stored for later freeing within the `_adcli_warn` call, leading to a resource leak when `code != 0`.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 2298 is not freed or pointed-to within the `_adcli_warn` function.

Upon examining the provided source code, there is no evidence of the allocated storage being freed or stored for later freeing within the scope of the `_adcli_warn` call at line 2298.

The code at line 2298 directly calls `_adcli_warn` with the result of `krb5_get_error_message(k5, code)`, without assigning the result to a variable that could be used for freeing the storage later.

There is no indication within the provided code snippet that `_adcli_warn` itself frees the storage allocated by `krb5_get_error_message`.

Given the direct allocation and use without explicit freeing or storage for later freeing, at least one execution path (when `code != 0`) leads to a resource leak, aligning with the CWE-772 (Resource Leak) described in the CVE.', NULL, 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2235| static adcli_result
2236| add_principal_to_keytab (adcli_enroll *enroll,
2237|                          krb5_context k5,
2238|                          krb5_principal principal,
2239|                          const char *principal_name,
2240|                          int *which_salt,
2241|                          adcli_enroll_flags flags)
2242| {
2243| 	match_principal_kvno closure;
2244| 	krb5_data password;
2245| 	krb5_error_code code;
2246| 	krb5_data *salts;
2247| 	krb5_enctype *enctypes;
2248| 
2249| 	/* Remove old stuff from the keytab for this principal */
2250| 
2251| 	closure.kvno = enroll->kvno;
2252| 	closure.principal = principal;
2253| 	closure.matched = 0;
2254| 
2255| 	code = _adcli_krb5_keytab_clear (k5, enroll->keytab,
2256| 	                                 match_principal_and_kvno, &closure);
2257| 
2258| 	if (code != 0) {
2259| 		_adcli_err ("Couldn''t update keytab: %s: %s",
2260| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2261| 		return ADCLI_ERR_FAIL;
2262| 	}
2263| 
2264| 	if (closure.matched) {
2265| 		_adcli_info ("Cleared old entries from keytab: %s",
2266| 		             enroll->keytab_name);
2267| 	}
2268| 
2269| 	enctypes = adcli_enroll_get_permitted_keytab_enctypes (enroll);
2270| 	if (enctypes == NULL) {
2271| 		_adcli_warn ("No permitted encryption type found.");
2272| 		return ADCLI_ERR_UNEXPECTED;
2273| 	}
2274| 
2275| 	if (flags & ADCLI_ENROLL_PASSWORD_VALID) {
2276| 		code = _adcli_krb5_keytab_copy_entries (k5, enroll->keytab, principal,
2277| 		                                        enroll->kvno, enctypes);
2278| 	} else {
2279| 
2280| 		password.data = enroll->computer_password;
2281| 		password.length = strlen (enroll->computer_password);
2282| 
2283| 		/*
2284| 		 * So we need to discover which salt to use. As a side effect we are
2285| 		 * also testing that our account works.
2286| 		 */
2287| 
2288| 		salts = build_principal_salts (enroll, k5, principal);
2289| 		if (salts == NULL) {
2290| 			krb5_free_enctypes (k5, enctypes);
2291| 			return ADCLI_ERR_UNEXPECTED;
2292| 		}
2293| 
2294| 		if (*which_salt < 0) {
2295| 			code = _adcli_krb5_keytab_discover_salt (k5, principal, enroll->kvno, &password,
2296| 			                                         enctypes, salts, which_salt);
2297| 			if (code != 0) {
2298| 				_adcli_warn ("Couldn''t authenticate with keytab while discovering which salt to use: %s: %s",
2299| 				             principal_name, krb5_get_error_message (k5, code));
2300| 				*which_salt = DEFAULT_SALT;
2301| 			} else {
2302| 				assert (*which_salt >= 0);
2303| 				_adcli_info ("Discovered which keytab salt to use");
2304| 			}
2305| 		}
2306| 
2307| 		code = _adcli_krb5_keytab_add_entries (k5, enroll->keytab, principal,
2308| 		                                       enroll->kvno, &password, enctypes, &salts[*which_salt]);
2309| 
2310| 		free_principal_salts (k5, salts);
2311| 	}
2312| 	krb5_free_enctypes (k5, enctypes);
2313| 
2314| 	if (code != 0) {
2315| 		_adcli_err ("Couldn''t add keytab entries: %s: %s",
2316| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2317| 		return ADCLI_ERR_FAIL;
2318| 	}
2319| 
2320| 
2321| 	_adcli_info ("Added the entries to the keytab: %s: %s",
2322| 	             principal_name, enroll->keytab_name);
2323| 	return ADCLI_SUCCESS;
2324| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025543');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (183, 97, 'def16', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:472: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:473: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  471|   			adcli_tool_usage (options, common_usages);
#  472|   			adcli_enroll_unref (enroll);
#  473|-> 			return opt == ''h'' ? 0 : 2;
#  474|   		default:
#  475|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:472: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:473: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  471|    		adcli_tool_usage (options, common_usages);
#  472|    		adcli_enroll_unref (enroll);
#  473|-> 		return opt == ''h'' ? 0 : 2;
#  474|    	default:
#  475|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:472: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:473: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  471|   			adcli_tool_usage (options, common_usages);
#  472|   			adcli_enroll_unref (enroll);
#  473|-> 			return opt == ''h'' ? 0 : 2;
#  474|   		default:
#  475|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|   			adcli_tool_usage (options, common_usages);
#  696|   			adcli_enroll_unref (enroll);
#  697|-> 			return opt == ''h'' ? 0 : 2;
#  698|   		default:
#  699|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025544');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (184, 97, 'def17', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|   			adcli_tool_usage (options, common_usages);
#  985|   			adcli_enroll_unref (enroll);
#  986|-> 			return opt == ''h'' ? 0 : 2;
#  987|   		default:
#  988|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|    		adcli_tool_usage (options, common_usages);
#  985|    		adcli_enroll_unref (enroll);
#  986|-> 		return opt == ''h'' ? 0 : 2;
#  987|    	default:
#  988|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|   			adcli_tool_usage (options, common_usages);
#  985|   			adcli_enroll_unref (enroll);
#  986|-> 			return opt == ''h'' ? 0 : 2;
#  987|   		default:
#  988|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|   			adcli_tool_usage (options, common_usages);
#  696|   			adcli_enroll_unref (enroll);
#  697|-> 			return opt == ''h'' ? 0 : 2;
#  698|   		default:
#  699|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025544');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (185, 97, 'def18', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1193: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1194: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1192|   			adcli_tool_usage (options, common_usages);
# 1193|   			adcli_enroll_unref (enroll);
# 1194|-> 			return opt == ''h'' ? 0 : 2;
# 1195|   		default:
# 1196|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1193: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1194: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1192|    adcli_tool_usage (options, common_usages);
# 1193|    adcli_enroll_unref (enroll);
# 1194|-> return opt == ''h'' ? 0 : 2;
# 1195|    default:
# 1196|    res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1193: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1194: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1192|   			adcli_tool_usage (options, common_usages);
# 1193|   			adcli_enroll_unref (enroll);
# 1194|-> 			return opt == ''h'' ? 0 : 2;
# 1195|   		default:
# 1196|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|   			adcli_tool_usage (options, common_usages);
#  985|   			adcli_enroll_unref (enroll);
#  986|-> 			return opt == ''h'' ? 0 : 2;
#  987|   		default:
#  988|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025544');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (186, 97, 'def19', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:550: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:550: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:550: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
#  548|   		if (code != 0) {
#  549|   			if (code != 0) {
#  550|-> 				_adcli_err ("Couldn''t parse kerberos user principal: %s: %s",
#  551|   				            enroll->user_principal,
#  552|   				            krb5_get_error_message (k5, code));', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 552 is not freed or stored for later freeing within `_adcli_err` (lines 548-552), with no implicit memory management suggested by its `printf`-like declaration (adprivate.h, line 107).', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 552 is not freed or pointed-to within the `_adcli_err` function at line 550.

Upon examining the provided source code, there is no evidence of the allocated storage being freed or stored for later freeing within the `_adcli_err` function or its surrounding scope (lines 548-552).

The `_adcli_err` function is declared in `adcli-0.9.2/library/adprivate.h` (line 107) with a `GNUC_PRINTF(1, 2)` attribute, indicating it behaves similarly to `printf`, which does not imply memory management of its arguments.

There is no provided implementation for `_adcli_err` in the given source code context, and based on its declaration, it does not suggest automatic memory management for the error message returned by `krb5_get_error_message`.

Given the lack of explicit memory freeing or storage for later freeing within the analyzed code path, and adhering to the guideline that ''No Clear False Positive Evidence Implies True Positive'', this finding is classified as a TRUE POSITIVE.

A single vulnerable path, in this case, the execution of `_adcli_err` with the allocated error message without subsequent freeing, is sufficient to classify this as a TRUE POSITIVE.', 'Obtain and examine the implementation of `_adcli_err` to determine if it indirectly handles the memory allocation of the error message string.

Investigate if any functions called by `_adcli_err` (not shown in the provided snippet) free the allocated resource.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
515| static adcli_result
516| ensure_keytab_principals (adcli_result res,
517|                           adcli_enroll *enroll)
518| {
519| 	krb5_context k5;
520| 	krb5_error_code code;
521| 	int count = 0;
522| 	int at, i;
523| 
524| 	/* Prepare the principals we''re going to add to the keytab */
525| 
526| 	if (!enroll->is_service) {
527| 		return_unexpected_if_fail (enroll->service_principals);
528| 		count = _adcli_strv_len (enroll->service_principals);
529| 	}
530| 
531| 	k5 = adcli_conn_get_krb5_context (enroll->conn);
532| 	return_unexpected_if_fail (k5 != NULL);
533| 
534| 	enroll_clear_keytab_principals (enroll);
535| 	enroll->keytab_principals = calloc (count + 3, sizeof (krb5_principal));
536| 	return_unexpected_if_fail (enroll->keytab_principals != NULL);
537| 	at = 0;
538| 
539| 	/* First add the principal for the computer account name */
540| 	code = krb5_copy_principal (k5, enroll->computer_principal,
541| 	                            &enroll->keytab_principals[at++]);
542| 	return_unexpected_if_fail (code == 0);
543| 
544| 	/* Next, optionally add the user principal */
545| 	if (enroll->user_principal) {
546| 		code = krb5_parse_name (k5, enroll->user_principal,
547| 		                        &enroll->keytab_principals[at++]);
548| 		if (code != 0) {
549| 			if (code != 0) {
550| 				_adcli_err ("Couldn''t parse kerberos user principal: %s: %s",
551| 				            enroll->user_principal,
552| 				            krb5_get_error_message (k5, code));
553| 				return ADCLI_ERR_CONFIG;
554| 			}
555| 		}
556| 	}
557| 
558| 	/* Now add the principals for all the various services */
559| 
560| 	for (i = 0; i < count; i++) {
561| 		code = _adcli_krb5_build_principal (k5, enroll->service_principals[i],
562| 		                                    adcli_conn_get_domain_realm (enroll->conn),
563| 		                                    &enroll->keytab_principals[at++]);
564| 		if (code != 0) {
565| 			_adcli_err ("Couldn''t parse kerberos service principal: %s: %s",
566| 			            enroll->service_principals[i],
567| 			            krb5_get_error_message (k5, code));
568| 			return ADCLI_ERR_CONFIG;
569| 		}
570| 	}
571| 
572| 	return ADCLI_SUCCESS;
573| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025545');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (187, 97, 'def20', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:356: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adconn.c:356: noescape: Resource "krb5_get_error_message(conn->k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adconn.c:356: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(conn->k5, code)" leaks it.
#  354|   	           code == KRB5_PREAUTH_FAILED) {
#  355|   		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
#  356|-> 			_adcli_err ("Couldn''t authenticate as machine account: %s: %s",
#  357|   			            name, krb5_get_error_message (conn->k5, code));
#  358|   		} else {', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 356 is not explicitly freed or stored for later freeing within the `_adcli_err` function, leading to a potential resource leak (CWE-772) when the conditional execution path is taken.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(conn->k5, code)` at line 356 is not freed or pointed-to within the `_adcli_err` function.

The provided source code snippet does not show any explicit memory management (freeing or storing for later freeing) for the return value of `krb5_get_error_message` within the `_adcli_err` function call at line 356.

The execution path leading to line 356 is conditional (dependent on `code == KRB5_PREAUTH_FAILED` and `type == ADCLI_LOGIN_COMPUTER_ACCOUNT`), but if this path is taken, there is no visible mechanism in the provided code to release the allocated storage.

Unlike the provided FALSE POSITIVE examples (Example-1 and Example-2), where the resource was freed indirectly through another function (`adcli_unref_enroll()`), there is no such indication in the provided code snippet for the resource allocated by `krb5_get_error_message`.

Given the explicit nature of the reported issue and the lack of visible memory management for the allocated resource within the provided code, there is sufficient evidence to conclude that this execution path potentially leads to a resource leak (CWE-772).

No implicit behavior or assumptions about the broader system or environment are required to reach this conclusion, as the issue is directly observable within the provided code snippet.', NULL, 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
336| static adcli_result
337| handle_kinit_krb5_code (adcli_conn *conn,
338|                         adcli_login_type type,
339|                         const char *name,
340|                         krb5_error_code code)
341| {
342| 	if (code == 0) {
343| 		return ADCLI_SUCCESS;
344| 
345| 	} else if (code == ENOMEM) {
346| 		return_unexpected_if_reached ();
347| 
348| 	} else if (code == KRB5KDC_ERR_PREAUTH_FAILED ||
349| 	           code == KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ||
350| 	           code == KRB5KDC_ERR_KEY_EXP ||
351| 	           code == KRB5KDC_ERR_CLIENT_REVOKED ||
352| 	           code == KRB5KDC_ERR_POLICY ||
353| 	           code == KRB5KDC_ERR_ETYPE_NOSUPP ||
354| 	           code == KRB5_PREAUTH_FAILED) {
355| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
356| 			_adcli_err ("Couldn''t authenticate as machine account: %s: %s",
357| 			            name, krb5_get_error_message (conn->k5, code));
358| 		} else {
359| 			_adcli_err ("Couldn''t authenticate as: %s: %s",
360| 			            name, krb5_get_error_message (conn->k5, code));
361| 		}
362| 		return ADCLI_ERR_CREDENTIALS;
363| 
364| 	} else {
365| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
366| 			_adcli_err ("Couldn''t get kerberos ticket for machine account: %s: %s",
367| 			            name, krb5_get_error_message (conn->k5, code));
368| 		} else {
369| 			_adcli_err ("Couldn''t get kerberos ticket for: %s: %s",
370| 			            name, krb5_get_error_message (conn->k5, code));
371| 		}
372| 		return ADCLI_ERR_DIRECTORY;
373| 	}
374| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025545');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (188, 97, 'def21', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1085: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1087: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1088: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1086|   			if (res != ADCLI_SUCCESS) {
# 1087|   				adcli_enroll_unref (enroll);
# 1088|-> 				return res;
# 1089|   			}
# 1090|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1085: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1087: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1088: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1086|   ifndef (res != ADCLI_SUCCESS) {
# 1087|    adcli_enroll_unref (enroll);
# 1088|-> return res;
# 1089|    }
# 1090|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1085: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1087: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1088: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1086|   			if (res != ADCLI_SUCCESS) {
# 1087|   				adcli_enroll_unref (enroll);
# 1088|-> 				return res;
# 1089|   			}
# 1090|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   			if (res != ADCLI_SUCCESS) {
# 1198|   				adcli_enroll_unref (enroll);
# 1199|-> 				return res;
# 1200|   			}
# 1201|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025545');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (189, 97, 'def22', 'USE_AFTER_FREE', 'adcli-0.9.2/library/adutil.c:878: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:886: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  884|   	                                    &stdout_data, &stdout_data_len);
#  885|   	assert (res == ADCLI_SUCCESS);
#  886|-> 	assert (strncmp ("World\nHello\n", (char *) stdout_data, stdout_data_len) == 0);
#  887|   	free (stdout_data);
#  888|   #endif', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/library/adutil.c:878: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:886: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  884|                                    &stdout_data, &stdout_data_len);
#  885|   assert (res == ADCLI_SUCCESS);
#  886|-> assert (strncmp ("World\nHello\n", (char *) stdout_data, stdout_data_len) == 0);
#  887|    free (stdout_data);
#  888|   #endif', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:878: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:886: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  884|   	                                    &stdout_data, &stdout_data_len);
#  885|   	assert (res == ADCLI_SUCCESS);
#  886|-> 	assert (strncmp ("World
Hello
", (char *) stdout_data, stdout_data_len) == 0);
#  887|   	free (stdout_data);
#  888|   #endif
(Example-1) Reason Marked as False Positive:
After the `free()` in line 878 there is a function call which allocates new memory for `stdout_data`.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:887: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:896: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  894|   	                                    &stdout_data, &stdout_data_len);
#  895|   	assert (res == ADCLI_SUCCESS);
#  896|-> 	assert (strncmp ("Hello
", (char *) stdout_data, stdout_data_len) == 0);
#  897|   	free (stdout_data);
#  898|   #endif
(Example-2) Reason Marked as False Positive:
After the `free()` in line 887 there is a function call which allocates new memory for `stdout_data`.

', '2025-11-17 21:39:07.025546');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (190, 97, 'def23', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|   			adcli_tool_usage (options, common_usages);
#  696|   			adcli_enroll_unref (enroll);
#  697|-> 			return opt == ''h'' ? 0 : 2;
#  698|   		default:
#  699|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|    		adcli_tool_usage (options, common_usages);
#  696|    		adcli_enroll_unref (enroll);
#  697|-> 		return opt == ''h'' ? 0 : 2;
#  698|    	default:
#  699|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|   			adcli_tool_usage (options, common_usages);
#  696|   			adcli_enroll_unref (enroll);
#  697|-> 			return opt == ''h'' ? 0 : 2;
#  698|   		default:
#  699|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:985: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:986: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  984|   			adcli_tool_usage (options, common_usages);
#  985|   			adcli_enroll_unref (enroll);
#  986|-> 			return opt == ''h'' ? 0 : 2;
#  987|   		default:
#  988|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025546');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (191, 97, 'def24', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:914: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:915: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  913|   		warnx ("specify one host name of computer account to reset");
#  914|   		adcli_enroll_unref (enroll);
#  915|-> 		return EUSAGE;
#  916|   	}
#  917|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:914: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:915: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  913|    warnx ("specify one host name of computer account to reset");
#  914|    adcli_enroll_unref (enroll);
#  915|->    return EUSAGE;
#  916|   }
#  917|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:914: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:915: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  913|   		warnx ("specify one host name of computer account to reset");
#  914|   		adcli_enroll_unref (enroll);
#  915|-> 		return EUSAGE;
#  916|   	}
#  917|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1002: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1003: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1001|   		warnx ("specify one host name of computer account to delete");
# 1002|   		adcli_enroll_unref (enroll);
# 1003|-> 		return EUSAGE;
# 1004|   	}
# 1005|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025546');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (192, 97, 'def25', 'INTEGER_OVERFLOW', 'adcli-0.9.2/library/adutil.c:498: tainted_data_return: Called function "write(fd, buf, len)", and a possible return value may be less than zero.
adcli-0.9.2/library/adutil.c:498: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
adcli-0.9.2/library/adutil.c:504: overflow: The expression "len" is considered to have possibly overflowed.
adcli-0.9.2/library/adutil.c:498: overflow_sink: "len", which might have overflowed, is passed to "write(fd, buf, len)".
#  496|   
#  497|   	while (len > 0) {
#  498|-> 		res = write (fd, buf, len);
#  499|   		if (res <= 0) {
#  500|   			if (errno == EAGAIN || errno == EINTR)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/library/adutil.c:498: tainted_data_return: Called function "write(fd, buf, len)", and a possible return value may be less than zero.
adcli-0.9.2/library/adutil.c:498: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
adcli-0.9.2/library/adutil.c:504: overflow: The expression "len" is considered to have possibly overflowed.
adcli-0.9.2/library/adutil.c:498: overflow_sink: "len", which might have overflowed, is passed to "write(fd, buf, len)".
#  496|   
#  497|    while (len > 0) {
#  498|->  res = write (fd, buf, len);
#  499|    if (res <= 0) {
#  500|    if (errno == EAGAIN || errno == EINTR)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
adcli-0.9.2/library/adutil.c:498: tainted_data_return: Called function "write(fd, buf, len)", and a possible return value may be less than zero.
adcli-0.9.2/library/adutil.c:498: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
adcli-0.9.2/library/adutil.c:504: overflow: The expression "len" is considered to have possibly overflowed.
adcli-0.9.2/library/adutil.c:498: overflow_sink: "len", which might have overflowed, is passed to "write(fd, buf, len)".
#  496|   
#  497|   	while (len > 0) {
#  498|-> 		res = write (fd, buf, len);
#  499|   		if (res <= 0) {
#  500|   			if (errno == EAGAIN || errno == EINTR)
(Example-1) Reason Marked as False Positive:
Negative return values of `write()` are properly checked and `len` is only modified for positiv return values.

', '2025-11-17 21:39:07.025547');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (193, 97, 'def26', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:600: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:601: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  599|   			adcli_tool_usage (options, common_usages);
#  600|   			adcli_enroll_unref (enroll);
#  601|-> 			return opt == ''h'' ? 0 : 2;
#  602|   		default:
#  603|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:600: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:601: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  599|    		adcli_tool_usage (options, common_usages);
#  600|    		adcli_enroll_unref (enroll);
#  601|-> 		return opt == ''h'' ? 0 : 2;
#  602|    	default:
#  603|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:600: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:601: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  599|   			adcli_tool_usage (options, common_usages);
#  600|   			adcli_enroll_unref (enroll);
#  601|-> 			return opt == ''h'' ? 0 : 2;
#  602|   		default:
#  603|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1193: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1194: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1192|   			adcli_tool_usage (options, common_usages);
# 1193|   			adcli_enroll_unref (enroll);
# 1194|-> 			return opt == ''h'' ? 0 : 2;
# 1195|   		default:
# 1196|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025547');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (194, 97, 'def27', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:2227: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:2227: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:2227: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 2225|   
# 2226|   	if (code != 0) {
# 2227|-> 		_adcli_err ("Couldn''t update keytab: %s: %s",
# 2228|   		            enroll->keytab_name, krb5_get_error_message (k5, code));
# 2229|   		return ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 2227 is passed to `_adcli_err` without being stored for potential freeing, and no corresponding deallocation is visible within the provided code snippet (lines 2226-2229), directly correlating with the described RESOURCE_LEAK (CWE-772) vulnerability.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 2227 is not freed or pointed-to within the `_adcli_err` function.

The provided source code confirms this: the return value of `krb5_get_error_message(k5, code)` is passed directly to `_adcli_err` without being stored in a variable that could be used for later freeing (line 2227).

There is no visible call to a freeing function (e.g., `free`, `krb5_free_error_message`, etc.) for the storage allocated by `krb5_get_error_message` within the provided code snippet, specifically within the scope of the `if (code != 0)` block (lines 2226-2229).

The function `_adcli_err` does not appear to take ownership of the error message string in a way that would imply it is responsible for freeing it, based on the provided code. Its behavior with the string is not defined within the given context.

Given the explicit allocation of storage by `krb5_get_error_message` and the lack of any visible deallocation within the provided code, there is a direct correlation between the code''s behavior and the described vulnerability (RESOURCE_LEAK, CWE-772).

Uncertainty about the broader system or environment (e.g., whether `_adcli_err` might indirectly free the memory) does not negate the clear evidence of a potential leak within the analyzed code path.', 'Obtain and analyze the implementation of `_adcli_err` to determine if it indirectly frees the memory allocated by `krb5_get_error_message`.

Verify the documentation or behavior of `krb5_get_error_message` to confirm if the caller is responsible for freeing the returned error message string.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2200| static adcli_result
2201| remove_principal_from_keytab (adcli_enroll *enroll,
2202|                               krb5_context k5,
2203|                               const char *principal_name)
2204| {
2205| 	krb5_error_code code;
2206| 	krb5_principal principal;
2207| 	match_principal_kvno closure;
2208| 
2209| 	code = _adcli_krb5_build_principal (k5, principal_name,
2210| 	                                    adcli_conn_get_domain_realm (enroll->conn),
2211| 	                                    &principal);
2212| 	if (code != 0) {
2213| 		_adcli_err ("Couldn''t parse principal: %s: %s",
2214| 		            principal_name, krb5_get_error_message (k5, code));
2215| 		return ADCLI_ERR_FAIL;
2216| 	}
2217| 
2218| 	closure.kvno = enroll->kvno;
2219| 	closure.principal = principal;
2220| 	closure.matched = 0;
2221| 
2222| 	code = _adcli_krb5_keytab_clear (k5, enroll->keytab,
2223| 	                                 match_principal_and_kvno, &closure);
2224| 	krb5_free_principal (k5, principal);
2225| 
2226| 	if (code != 0) {
2227| 		_adcli_err ("Couldn''t update keytab: %s: %s",
2228| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2229| 		return ADCLI_ERR_FAIL;
2230| 	}
2231| 
2232| 	return ADCLI_SUCCESS;
2233| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025547');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (195, 97, 'def28', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:699: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:701: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:702: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  700|   			if (res != ADCLI_SUCCESS) {
#  701|   				adcli_enroll_unref (enroll);
#  702|-> 				return res;
#  703|   			}
#  704|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:699: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:701: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:702: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  700|   ifndef (res != ADCLI_SUCCESS) {
#  701|    adcli_enroll_unref (enroll);
#  702|->  return res;
#  703|    }
#  704|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:699: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:701: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:702: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  700|   			if (res != ADCLI_SUCCESS) {
#  701|   				adcli_enroll_unref (enroll);
#  702|-> 				return res;
#  703|   			}
#  704|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:900: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:902: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:903: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  901|   			if (res != ADCLI_SUCCESS) {
#  902|   				adcli_enroll_unref (enroll);
#  903|-> 				return res;
#  904|   			}
#  905|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025548');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (235, 94, 'def8', 'USE_AFTER_FREE', 'gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:860: freed_arg: "huft_free" frees "tl".
gzip-1.13/inflate.c:887: double_free: Calling "huft_free" frees pointer "td" which has already been freed.
#  885|       }
#  886|   #else
#  887|->       huft_free(td);
#  888|       }
#  889|       huft_free(tl);', 'TRUE POSITIVE', 'Assignment at line 813 derives `td` from `tl`, and without explicit proof preventing a double-free scenario, the subsequent `huft_free(tl)` at line 860 and `huft_free(td)` at line 887 potentially trigger a CWE-416 vulnerability, as `td` may point within the memory block of already-freed `tl`.', 'The reported issue is not solely about the assignment at line 813, but rather the potential **double_free** vulnerability, as indicated by the error messages.

At line 813, `td` is assigned a value based on `tl` and other variables, but this assignment itself does not inherently indicate a vulnerability without considering the subsequent use of `td`.

The critical issue arises from the sequence of events where `huft_free(tl)` is called at line 860, and later, `huft_free(td)` is called at line 887, with the error message indicating that `td` has already been freed.

Given that `td` is assigned a value derived from `tl` (line 813), and both `tl` and `td` are freed, the concern is whether `td` points to a memory location within the block freed by `huft_free(tl)`.

Analyzing the provided `huft_free` function (starting at line 497), it iteratively frees memory blocks linked through the `huft` structure, starting from the provided pointer.

Since `td` is derived from `tl` (line 813), if `td` points within the memory block of `tl`, freeing `tl` first (line 860) would indeed make the subsequent free of `td` (line 887) a **double_free**, which is a vulnerability (CWE-416: Use After Free).

There is no explicit proof within the provided code that `td` cannot point to a location within the memory block of `tl`, or that the `huft_free` function''s behavior would prevent the double-free scenario in this specific case.

Given the direct correlation between the assignment at line 813, the freeing of `tl` at line 860, and the attempted free of `td` at line 887, without definitive proof to the contrary, this scenario aligns with the described vulnerability.', 'Verify all execution paths in `inflate.c` to ensure the sequence of events (freeing `tl` and then attempting to free `td`) is unavoidable under all circumstances.

Inspect the implementation of `huft_free` to confirm its behavior when freeing partially overlapping memory blocks (e.g., `td` pointing within the already freed `tl` block).

Analyze the memory management of `tl` and `td` across the entire `inflate.c` file to rule out any unseen reinitializations or safe guards.', 0.0000, '*** Source Code Context ***

code of inflate.c file:
734| static int
735| inflate_dynamic(void)
736| {
737|   int i;                /* temporary variables */
738|   unsigned j;
739|   unsigned l;           /* last length */
740|   unsigned m;           /* mask for bit lengths table */
741|   unsigned n;           /* number of lengths to get */
742|   unsigned w;           /* current window position */
743|   struct huft *tl;      /* literal/length code table */
744|   struct huft *td;      /* distance code table */
745|   int bl;               /* lookup bits for tl */
746|   int bd;               /* lookup bits for td */
747|   unsigned nb;          /* number of bit length codes */
748|   unsigned nl;          /* number of literal/length codes */
749|   unsigned nd;          /* number of distance codes */
750| #ifdef PKZIP_BUG_WORKAROUND
751|   unsigned ll[288+32];  /* literal/length and distance code lengths */
752| #else
753|   unsigned ll[286+30];  /* literal/length and distance code lengths */
754| #endif
755|   register ulg b;       /* bit buffer */
756|   register unsigned k;  /* number of bits in bit buffer */
757| 
758| 
759|   /* make local bit buffer */
760|   b = bb;
761|   k = bk;
762|   w = wp;
763| 
764| 
765|   /* read in table lengths */
766|   NEEDBITS(5)
767|   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
768|   DUMPBITS(5)
769|   NEEDBITS(5)
770|   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
771|   DUMPBITS(5)
772|   NEEDBITS(4)
773|   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
774|   DUMPBITS(4)
775| #ifdef PKZIP_BUG_WORKAROUND
776|   if (nl > 288 || nd > 32)
777| #else
778|   if (nl > 286 || nd > 30)
779| #endif
780|     return 1;                   /* bad lengths */
781| 
782| 
783|   /* read in bit-length-code lengths */
784|   for (j = 0; j < nb; j++)
785|   {
786|     NEEDBITS(3)
787|     ll[border[j]] = (unsigned)b & 7;
788|     DUMPBITS(3)
789|   }
790|   for (; j < 19; j++)
791|     ll[border[j]] = 0;
792| 
793| 
794|   /* build decoding table for trees--single level, 7 bit lookup */
795|   bl = 7;
796|   if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
797|   {
798|     if (i == 1)
799|       huft_free(tl);
800|     return i;                   /* incomplete code set */
801|   }
802| 
803|   if (tl == NULL)		/* Grrrhhh */
804|         return 2;
805| 
806|   /* read in literal and distance code lengths */
807|   n = nl + nd;
808|   m = mask_bits[bl];
809|   i = l = 0;
810|   while ((unsigned)i < n)
811|   {
812|     NEEDBITS((unsigned)bl)
813|     j = (td = tl + ((unsigned)b & m))->b;
814|     DUMPBITS(j)
815|     if (td->e == 99)
816|       {
817|         /* Invalid code.  */
818|         huft_free (tl);
819|         return 2;
820|       }
821|     j = td->v.n;
822|     if (j < 16)                 /* length of code in bits (0..15) */
823|       ll[i++] = l = j;          /* save last length in l */
824|     else if (j == 16)           /* repeat last length 3 to 6 times */
825|     {
826|       NEEDBITS(2)
827|       j = 3 + ((unsigned)b & 3);
828|       DUMPBITS(2)
829|       if ((unsigned)i + j > n)
830|         return 1;
831|       while (j--)
832|         ll[i++] = l;
833|     }
834|     else if (j == 17)           /* 3 to 10 zero length codes */
835|     {
836|       NEEDBITS(3)
837|       j = 3 + ((unsigned)b & 7);
838|       DUMPBITS(3)
839|       if ((unsigned)i + j > n)
840|         return 1;
841|       while (j--)
842|         ll[i++] = 0;
843|       l = 0;
844|     }
845|     else                        /* j == 18: 11 to 138 zero length codes */
846|     {
847|       NEEDBITS(7)
848|       j = 11 + ((unsigned)b & 0x7f);
849|       DUMPBITS(7)
850|       if ((unsigned)i + j > n)
851|         return 1;
852|       while (j--)
853|         ll[i++] = 0;
854|       l = 0;
855|     }
856|   }
857| 
858| 
859|   /* free decoding table for trees */
860|   huft_free(tl);
861| 
862| 
863|   /* restore the global bit buffer */
864|   bb = b;
865|   bk = k;
866| 
867| 
868|   /* build the decoding tables for literal/length and distance codes */
869|   bl = lbits;
870|   if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
871|   {
872|     if (i == 1) {
873|       Trace ((stderr, " incomplete literal tree
"));
874|       huft_free(tl);
875|     }
876|     return i;                   /* incomplete code set */
877|   }
878|   bd = dbits;
879|   if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
880|   {
881|     if (i == 1) {
882|       Trace ((stderr, " incomplete distance tree
"));
883| #ifdef PKZIP_BUG_WORKAROUND
884|       i = 0;
885|     }
886| #else
887|       huft_free(td);
888|     }
889|     huft_free(tl);
890|     return i;                   /* incomplete code set */
891| #endif
892|   }
893| 
894| 
895|   {
896|     /* decompress until an end-of-block code */
897|     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
898| 
899|     /* free the decoding tables */
900|     huft_free(tl);
901|     huft_free(td);
902| 
903|     return err;
904|   }
905| }

code of /shared-data/source/gzip-1.13/inflate.c file:
497| static int
498| huft_free(struct huft *t)
499| {
500|   register struct huft *p, *q;
501| 
502| 
503|   /* Go through linked list, freeing from the malloced (t[-1]) address. */
504|   p = t;
505|   while (p != (struct huft *)NULL)
506|   {
507|     q = (--p)->v.t;
508|     free(p);
509|     p = q;
510|   }
511|   return 0;
512| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:884: deref_arg: Calling "inflate_codes" dereferences freed pointer "tl".
#  882|     {
#  883|       /* decompress until an end-of-block code */
#  884|->     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
#  885|   
#  886|       /* free the decoding tables */
(Example-1) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:861: double_free: Calling "huft_free" frees pointer "tl" which has already been freed.
#  859|       if (i == 1) {
#  860|         Trace ((stderr, " incomplete literal tree
"));
#  861|->       huft_free(tl);
#  862|       }
#  863|       return i;                   /* incomplete code set */
(Example-2) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

', '2025-11-17 21:39:07.041401');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (196, 97, 'def29', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adkrb5.c:194: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adkrb5.c:194: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adkrb5.c:194: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
#  192|   		code = krb5_kt_resolve (k5, keytab_name, keytab);
#  193|   		if (code != 0) {
#  194|-> 			_adcli_err ("Failed to open keytab: %s: %s",
#  195|   			            keytab_name, krb5_get_error_message (k5, code));
#  196|   			return ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 194 is not explicitly freed or stored for later deallocation within the provided code, including within the `_adcli_err` function, leading to a potential memory leak.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 194 is not freed or pointed-to within the `_adcli_err` function.

Upon examining the provided source code, there is no evidence of `krb5_get_error_message`''s return value being stored for later freeing at line 194 or within the `_adcli_err` function (lines 107-108 in `adprivate.h` file, which only declares the function without its implementation).

The `_adcli_err` function is declared with a variable argument list (similar to `printf`) but its implementation is not provided; however, based on its declaration, there is no indication that it would manage the memory of its arguments.

The execution path at line 194, triggered by `code != 0`, leads to the allocation of memory by `krb5_get_error_message` without any visible subsequent deallocation or storage for later deallocation within the provided code snippet.

Given the lack of explicit memory management for the allocated error message within the analyzed code, and adhering to the guideline that ''No Clear False Positive Evidence Implies True Positive'', this finding is classified as a TRUE POSITIVE.

Uncertainty regarding the implementation of `_adcli_err` does not negate this conclusion, as the provided code does not demonstrate the necessary memory management for the allocated resource.', 'Obtain and analyze the implementation of the `_adcli_err` function to determine if it internally frees the storage allocated by `krb5_get_error_message`.

Investigate the codebase for any indirect freeing mechanisms that might be triggered by `_adcli_err` or subsequent function calls.', 0.0000, '*** Source Code Context ***

code of library/adkrb5.c file:
184| adcli_result
185| _adcli_krb5_open_keytab (krb5_context k5,
186|                          const char *keytab_name,
187| 		         krb5_keytab *keytab)
188| {
189| 	krb5_error_code code;
190| 
191| 	if (keytab_name && strcmp (keytab_name, "") != 0) {
192| 		code = krb5_kt_resolve (k5, keytab_name, keytab);
193| 		if (code != 0) {
194| 			_adcli_err ("Failed to open keytab: %s: %s",
195| 			            keytab_name, krb5_get_error_message (k5, code));
196| 			return ADCLI_ERR_FAIL;
197| 		}
198| 
199| 	} else {
200| 		code = krb5_kt_default (k5, keytab);
201| 		if (code != 0) {
202| 			_adcli_err ("Failed to open default keytab: %s",
203| 			            krb5_get_error_message (k5, code));
204| 			return ADCLI_ERR_FAIL;
205| 		}
206| 	}
207| 
208| 	return ADCLI_SUCCESS;
209| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025548');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (197, 97, 'def30', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|      adcli_get_last_error ());
#  923|     adcli_enroll_unref (enroll);
#  924|->  return -res;
#  925|   }
#  926|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025548');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (198, 97, 'def31', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1110: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_read_computer_account".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1117: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1118: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1116|   		       adcli_get_last_error ());
# 1117|   		adcli_enroll_unref (enroll);
# 1118|-> 		return -res;
# 1119|   	}
# 1120|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1110: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_read_computer_account".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1117: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1118: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1116|      adcli_get_last_error ());
# 1117|      adcli_enroll_unref (enroll);
# 1118|->  return -res;
# 1119|   }
# 1120|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1110: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_read_computer_account".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1117: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1118: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1116|   		       adcli_get_last_error ());
# 1117|   		adcli_enroll_unref (enroll);
# 1118|-> 		return -res;
# 1119|   	}
# 1120|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025549');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (199, 97, 'def32', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adentry.c:516: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adentry.c:516: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adentry.c:516: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
#  514|   
#  515|   	if (code != 0) {
#  516|-> 		_adcli_err ("Couldn''t set password for %s account: %s: %s",
#  517|   		            entry->object_class,
#  518|   		            entry->sam_name, krb5_get_error_message (k5, code));', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 516 is passed to `_adcli_err` without being stored for potential freeing, and no subsequent freeing function is called within the provided code context, confirming a resource leak vulnerability.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 516 is not freed or pointed-to within the `_adcli_err` function.

The code snippet confirms this: the return value of `krb5_get_error_message(k5, code)` is passed directly to `_adcli_err` without being stored in a variable that could be used for later freeing (line 518).

There is no visible call to a freeing function (e.g., `krb5_free_error_message`, `free`, etc.) for the allocated storage within the provided code context, specifically within the `_adcli_err` function or immediately after its call.

The execution path leading to this potential leak is conditional (`if (code != 0)` at line 515), but this condition does not mitigate the leak; it merely determines when the leak occurs.

No evidence within the provided code suggests that `_adcli_err` internally frees the memory allocated by `krb5_get_error_message`, which would require an assumption beyond the provided code context.

Given the direct correlation between the code''s behavior and the described vulnerability (resource leak due to unfreed allocated storage), and adhering to the guideline that a single vulnerable path is sufficient, this finding is classified as a TRUE POSITIVE.', NULL, 0.0000, '*** Source Code Context ***

code of library/adentry.c file:
469| adcli_result
470| adcli_entry_set_passwd (adcli_entry *entry, const char *user_pwd)
471| {
472| 	adcli_result res;
473| 	LDAP *ldap;
474| 	krb5_error_code code;
475| 	krb5_context k5;
476| 	krb5_ccache ccache;
477| 	krb5_data result_string = { 0, };
478| 	krb5_data result_code_string = { 0, };
479| 	int result_code;
480| 	char *message;
481| 	krb5_principal user_principal;
482| 
483| 	ldap = adcli_conn_get_ldap_connection (entry->conn);
484| 	return_unexpected_if_fail (ldap != NULL);
485| 
486| 	/* Find the user */
487| 	res = update_entry_from_domain (entry, ldap);
488| 	if (res != ADCLI_SUCCESS)
489| 		return res;
490| 
491| 	if (!entry->entry_dn) {
492| 		_adcli_err ("Cannot find the %s entry %s in the domain",
493| 		            entry->object_class, entry->sam_name);
494| 		return ADCLI_ERR_CONFIG;
495| 	}
496| 
497| 	k5 = adcli_conn_get_krb5_context (entry->conn);
498| 	return_unexpected_if_fail (k5 != NULL);
499| 
500| 	code = _adcli_krb5_build_principal (k5, entry->sam_name,
501| 	                                    adcli_conn_get_domain_realm (entry->conn),
502| 	                                    &user_principal);
503| 	return_unexpected_if_fail (code == 0);
504| 
505| 	ccache = adcli_conn_get_login_ccache (entry->conn);
506| 	return_unexpected_if_fail (ccache != NULL);
507| 
508| 	memset (&result_string, 0, sizeof (result_string));
509| 	memset (&result_code_string, 0, sizeof (result_code_string));
510| 
511| 	code = krb5_set_password_using_ccache (k5, ccache, user_pwd,
512| 	                                       user_principal, &result_code,
513| 	                                       &result_code_string, &result_string);
514| 
515| 	if (code != 0) {
516| 		_adcli_err ("Couldn''t set password for %s account: %s: %s",
517| 		            entry->object_class,
518| 		            entry->sam_name, krb5_get_error_message (k5, code));
519| 		/* TODO: Parse out these values */
520| 		res = ADCLI_ERR_DIRECTORY;
521| 
522| 	} else if (result_code != 0) {
523| #ifdef HAVE_KRB5_CHPW_MESSAGE
524| 		if (krb5_chpw_message (k5, &result_string, &message) != 0)
525| 			message = NULL;
526| #else
527| 		message = NULL;
528| 		if (result_string.length)
529| 			message = _adcli_str_dupn (result_string.data, result_string.length);
530| #endif
531| 		_adcli_err ("Cannot set %s password: %.*s%s%s",
532| 		            entry->object_class,
533| 		            (int)result_code_string.length, result_code_string.data,
534| 		            message ? ": " : "", message ? message : "");
535| 		res = ADCLI_ERR_CREDENTIALS;
536| #ifdef HAVE_KRB5_CHPW_MESSAGE
537| 		krb5_free_string (k5, message);
538| #else
539| 		free (message);
540| #endif
541| 	} else {
542| 		_adcli_info ("Password (re)setted for %s: %s", entry->object_class, entry->entry_dn);
543| 
544| 		res = adcli_entry_ensure_enabled (entry);
545| 	}
546| 
547| 	return res;
548| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025549');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (200, 97, 'def33', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|     adcli_get_last_error ());
#  935| adcli_enroll_unref (enroll);
#  936|-> return -res;
#  937| }
#  938|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025549');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (201, 97, 'def34', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|      adcli_get_last_error ());
#  842|      adcli_enroll_unref (enroll);
#  843|->      return -res;
#  844|    }
#  845|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:832: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:837: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:842: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:843: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  841|   			       adcli_get_last_error ());
#  842|   			adcli_enroll_unref (enroll);
#  843|-> 			return -res;
#  844|   		}
#  845|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.02555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (202, 97, 'def35', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1212: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1213: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1211|   		warnx ("extra arguments specified");
# 1212|   		adcli_enroll_unref (enroll);
# 1213|-> 		return 2;
# 1214|   	}
# 1215|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1212: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1213: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1211|    warnx ("extra arguments specified");
# 1212|    adcli_enroll_unref (enroll);
# 1213|->    return 2;
# 1214|   }
# 1215|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1212: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1213: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1211|   		warnx ("extra arguments specified");
# 1212|   		adcli_enroll_unref (enroll);
# 1213|-> 		return 2;
# 1214|   	}
# 1215|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:491: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:492: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  490|   		warnx ("extra arguments specified");
#  491|   		adcli_enroll_unref (enroll);
#  492|-> 		return 2;
#  493|   	}
#  494|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.02555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (203, 97, 'def36', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|     adcli_get_last_error ());
#  500| adcli_enroll_unref (enroll);
#  501|-> return -res;
#  502| }
#  503|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.02555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (204, 97, 'def37', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1218: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1219: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1217|   		warnx ("domain name is required");
# 1218|   		adcli_enroll_unref (enroll);
# 1219|-> 		return 2;
# 1220|   	}
# 1221|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1218: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1219: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1217|    warnx ("domain name is required");
# 1218|    adcli_enroll_unref (enroll);
# 1219|->    return 2;
# 1220|   }
# 1221|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1218: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1219: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1217|   		warnx ("domain name is required");
# 1218|   		adcli_enroll_unref (enroll);
# 1219|-> 		return 2;
# 1220|   	}
# 1221|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025551');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (205, 97, 'def38', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:988: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:990: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:991: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  989|   			if (res != ADCLI_SUCCESS) {
#  990|   				adcli_enroll_unref (enroll);
#  991|-> 				return res;
#  992|   			}
#  993|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:988: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:990: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:991: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  989|   ifndef (res != ADCLI_SUCCESS) {
#  990|    adcli_enroll_unref (enroll);
#  991|->  return res;
#  992|    }
#  993|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:988: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:990: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:991: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  989|   			if (res != ADCLI_SUCCESS) {
#  990|   				adcli_enroll_unref (enroll);
#  991|-> 				return res;
#  992|   			}
#  993|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   			if (res != ADCLI_SUCCESS) {
# 1198|   				adcli_enroll_unref (enroll);
# 1199|-> 				return res;
# 1200|   			}
# 1201|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025551');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (206, 97, 'def39', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:2259: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:2259: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:2259: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 2257|   
# 2258|   	if (code != 0) {
# 2259|-> 		_adcli_err ("Couldn''t update keytab: %s: %s",
# 2260|   		            enroll->keytab_name, krb5_get_error_message (k5, code));
# 2261|   		return ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 2259 is passed to `_adcli_err` without being stored or freed, and with no visible freeing function call within the provided scope, potentially leading to a RESOURCE_LEAK (CWE-772) when `code != 0`.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 2259 is not freed or pointed-to within the `_adcli_err` function.

The provided source code at line 2259 confirms this, as the return value of `krb5_get_error_message(k5, code)` is directly passed to `_adcli_err` without being stored or freed.

There is no visible call to a freeing function (e.g., `krb5_free_error_message`) for the allocated storage within the provided code snippet, specifically within the scope of the `_adcli_err` call at line 2259.

The function `_adcli_err` is declared in `adprivate.h` (lines 107-108) with a variable argument list (`...`), but its implementation is not provided. Without explicit proof of memory management within `_adcli_err` for the error message, we cannot assume it is handled.

Given the direct allocation and lack of explicit deallocation in the provided code, at least one execution path (when `code != 0`) potentially leads to a resource leak, aligning with the CWE-772 (RESOURCE_LEAK) vulnerability described in the CVE report.', 'Obtain and examine the implementation of the `_adcli_err` function to determine if it handles the memory allocated by `krb5_get_error_message(k5, code)`.

Verify if there are any indirect memory management mechanisms (e.g., callbacks, external handlers) that might be invoked by `_adcli_err` which could potentially free the allocated storage.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2235| static adcli_result
2236| add_principal_to_keytab (adcli_enroll *enroll,
2237|                          krb5_context k5,
2238|                          krb5_principal principal,
2239|                          const char *principal_name,
2240|                          int *which_salt,
2241|                          adcli_enroll_flags flags)
2242| {
2243| 	match_principal_kvno closure;
2244| 	krb5_data password;
2245| 	krb5_error_code code;
2246| 	krb5_data *salts;
2247| 	krb5_enctype *enctypes;
2248| 
2249| 	/* Remove old stuff from the keytab for this principal */
2250| 
2251| 	closure.kvno = enroll->kvno;
2252| 	closure.principal = principal;
2253| 	closure.matched = 0;
2254| 
2255| 	code = _adcli_krb5_keytab_clear (k5, enroll->keytab,
2256| 	                                 match_principal_and_kvno, &closure);
2257| 
2258| 	if (code != 0) {
2259| 		_adcli_err ("Couldn''t update keytab: %s: %s",
2260| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2261| 		return ADCLI_ERR_FAIL;
2262| 	}
2263| 
2264| 	if (closure.matched) {
2265| 		_adcli_info ("Cleared old entries from keytab: %s",
2266| 		             enroll->keytab_name);
2267| 	}
2268| 
2269| 	enctypes = adcli_enroll_get_permitted_keytab_enctypes (enroll);
2270| 	if (enctypes == NULL) {
2271| 		_adcli_warn ("No permitted encryption type found.");
2272| 		return ADCLI_ERR_UNEXPECTED;
2273| 	}
2274| 
2275| 	if (flags & ADCLI_ENROLL_PASSWORD_VALID) {
2276| 		code = _adcli_krb5_keytab_copy_entries (k5, enroll->keytab, principal,
2277| 		                                        enroll->kvno, enctypes);
2278| 	} else {
2279| 
2280| 		password.data = enroll->computer_password;
2281| 		password.length = strlen (enroll->computer_password);
2282| 
2283| 		/*
2284| 		 * So we need to discover which salt to use. As a side effect we are
2285| 		 * also testing that our account works.
2286| 		 */
2287| 
2288| 		salts = build_principal_salts (enroll, k5, principal);
2289| 		if (salts == NULL) {
2290| 			krb5_free_enctypes (k5, enctypes);
2291| 			return ADCLI_ERR_UNEXPECTED;
2292| 		}
2293| 
2294| 		if (*which_salt < 0) {
2295| 			code = _adcli_krb5_keytab_discover_salt (k5, principal, enroll->kvno, &password,
2296| 			                                         enctypes, salts, which_salt);
2297| 			if (code != 0) {
2298| 				_adcli_warn ("Couldn''t authenticate with keytab while discovering which salt to use: %s: %s",
2299| 				             principal_name, krb5_get_error_message (k5, code));
2300| 				*which_salt = DEFAULT_SALT;
2301| 			} else {
2302| 				assert (*which_salt >= 0);
2303| 				_adcli_info ("Discovered which keytab salt to use");
2304| 			}
2305| 		}
2306| 
2307| 		code = _adcli_krb5_keytab_add_entries (k5, enroll->keytab, principal,
2308| 		                                       enroll->kvno, &password, enctypes, &salts[*which_salt]);
2309| 
2310| 		free_principal_salts (k5, salts);
2311| 	}
2312| 	krb5_free_enctypes (k5, enctypes);
2313| 
2314| 	if (code != 0) {
2315| 		_adcli_err ("Couldn''t add keytab entries: %s: %s",
2316| 		            enroll->keytab_name, krb5_get_error_message (k5, code));
2317| 		return ADCLI_ERR_FAIL;
2318| 	}
2319| 
2320| 
2321| 	_adcli_info ("Added the entries to the keytab: %s: %s",
2322| 	             principal_name, enroll->keytab_name);
2323| 	return ADCLI_SUCCESS;
2324| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025551');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (207, 97, 'def40', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:2115: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:2115: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:2115: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 2113|   		code = _adcli_krb5_keytab_enumerate (k5, keytab, load_keytab_entry, enroll);
# 2114|   		if (code != 0) {
# 2115|-> 			_adcli_err ("Couldn''t enumerate keytab: %s: %s",
# 2116|   		                    enroll->keytab_name, krb5_get_error_message (k5, code));
# 2117|   			res = ADCLI_ERR_FAIL;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 2115 is passed to `_adcli_err` without visible freeing or storage for later freeing in the provided `adenroll.c` code, directly correlating with the RESOURCE_LEAK (CWE-772) vulnerability.', 'The CVE report explicitly states that the storage returned from `krb5_get_error_message(k5, code)` at line 2115 is not freed or pointed-to within the `_adcli_err` function.

Upon examining the provided source code, there is no evidence of `krb5_get_error_message`''s returned storage being explicitly freed or stored for later freeing within the `_adcli_err` function call at line 2115.

The `_adcli_err` function''s implementation is not provided in the context, but based on the explicit behavior of the provided `adenroll.c` code, there is no visible mechanism to free the allocated storage after it is passed to `_adcli_err`.

The lack of explicit freeing or storage of the allocated memory within the provided code execution path (lines 2113-2117) directly correlates with the vulnerability described in the CVE (RESOURCE_LEAK, CWE-772).

Uncertainty about the implementation of `_adcli_err` does not provide sufficient grounds to conclude FALSE POSITIVE, as the provided code does not demonstrate explicit memory management for the allocated storage.', 'Examine the implementation of `_adcli_err` to determine if it indirectly frees the storage allocated by `krb5_get_error_message`.

Investigate the program''s broader error handling scope (e.g., the `ADCLI_ERR_FAIL` path) for potential memory management of the allocated error message.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
2099| static adcli_result
2100| load_host_keytab (adcli_enroll *enroll)
2101| {
2102| 	krb5_error_code code;
2103| 	adcli_result res;
2104| 	krb5_context k5;
2105| 	krb5_keytab keytab;
2106| 
2107| 	res = _adcli_krb5_init_context (&k5);
2108| 	if (res != ADCLI_SUCCESS)
2109| 		return res;
2110| 
2111| 	res = _adcli_krb5_open_keytab (k5, enroll->keytab_name, &keytab);
2112| 	if (res == ADCLI_SUCCESS) {
2113| 		code = _adcli_krb5_keytab_enumerate (k5, keytab, load_keytab_entry, enroll);
2114| 		if (code != 0) {
2115| 			_adcli_err ("Couldn''t enumerate keytab: %s: %s",
2116| 		                    enroll->keytab_name, krb5_get_error_message (k5, code));
2117| 			res = ADCLI_ERR_FAIL;
2118| 		}
2119| 		krb5_kt_close (k5, keytab);
2120| 	}
2121| 
2122| 	krb5_free_context (k5);
2123| 	return res;
2124| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025552');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (208, 97, 'def41', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   			if (res != ADCLI_SUCCESS) {
# 1198|   				adcli_enroll_unref (enroll);
# 1199|-> 				return res;
# 1200|   			}
# 1201|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   ifndef (res != ADCLI_SUCCESS) {
# 1198|    adcli_enroll_unref (enroll);
# 1199|-> return res;
# 1200|    
# 1201|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   			if (res != ADCLI_SUCCESS) {
# 1198|   				adcli_enroll_unref (enroll);
# 1199|-> 				return res;
# 1200|   			}
# 1201|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:603: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:605: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:606: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  604|   			if (res != ADCLI_SUCCESS) {
#  605|   				adcli_enroll_unref (enroll);
#  606|-> 				return res;
#  607|   			}
#  608|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025552');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (209, 97, 'def42', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:505: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_account_disable".
adcli-0.9.2/tools/computer.c:506: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:511: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:512: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  510|   		       adcli_get_last_error ());
#  511|   		adcli_enroll_unref (enroll);
#  512|-> 		return -res;
#  513|   	}
#  514|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:505: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_account_disable".
adcli-0.9.2/tools/computer.c:506: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:511: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:512: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  510|   adcli_get_last_error ());
#  511|    adcli_enroll_unref (enroll);
#  512|->  return -res;
#  513|   }
#  514|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:505: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_account_disable".
adcli-0.9.2/tools/computer.c:506: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_join".
adcli-0.9.2/tools/computer.c:511: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:512: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  510|   		       adcli_get_last_error ());
#  511|   		adcli_enroll_unref (enroll);
#  512|-> 		return -res;
#  513|   	}
#  514|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025552');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (210, 97, 'def43', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:359: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adconn.c:359: noescape: Resource "krb5_get_error_message(conn->k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adconn.c:359: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(conn->k5, code)" leaks it.
#  357|   			            name, krb5_get_error_message (conn->k5, code));
#  358|   		} else {
#  359|-> 			_adcli_err ("Couldn''t authenticate as: %s: %s",
#  360|   			            name, krb5_get_error_message (conn->k5, code));
#  361|   		}', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` at line 359 is not explicitly freed within the provided code context, including after its use in `_adcli_err` (defined in `adprivate.h` line 107), directly correlating with CWE-772 (Resource Leak).', '1. **Explicit Allocation**: The CVE report correctly identifies `krb5_get_error_message(conn->k5, code)` at line 359 (and also implicitly at line 357, though not directly reported) as an allocation function, which returns storage that needs to be managed.

2. **Lack of Deallocation**: Within the provided source code context, there is no explicit call to free the storage allocated by `krb5_get_error_message` after its use in `_adcli_err`. The `_adcli_err` function, as defined in `adprivate.h`, does not indicate any responsibility for freeing its input parameters (line 107).

3. **No Indirect Deallocation Evidence**: Unlike the provided false positive examples (Example-1 and Example-2), where the resource was freed indirectly through another function (`adcli_unref_enroll()` leading to `adcli_unret_enroll()`), the current code snippet does not show a similar indirect deallocation mechanism for the storage allocated by `krb5_get_error_message`.

4. **Direct Correlation to CWE**: The described behavior directly correlates with CWE-772 (Resource Leak), as the allocated resource is not freed, leading to a memory leak.

5. **Single Vulnerable Path Suffices**: The execution path leading to line 359, where the allocation occurs without subsequent deallocation, is sufficient to classify this as a TRUE POSITIVE, as per the guidelines.', 'Obtain and analyze the implementation of `_adcli_err` to determine if it manages the memory allocated by `krb5_get_error_message`.

Investigate if there are any memory management functions called within `_adcli_err` or subsequent functions that could free the allocated storage.', 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
336| static adcli_result
337| handle_kinit_krb5_code (adcli_conn *conn,
338|                         adcli_login_type type,
339|                         const char *name,
340|                         krb5_error_code code)
341| {
342| 	if (code == 0) {
343| 		return ADCLI_SUCCESS;
344| 
345| 	} else if (code == ENOMEM) {
346| 		return_unexpected_if_reached ();
347| 
348| 	} else if (code == KRB5KDC_ERR_PREAUTH_FAILED ||
349| 	           code == KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ||
350| 	           code == KRB5KDC_ERR_KEY_EXP ||
351| 	           code == KRB5KDC_ERR_CLIENT_REVOKED ||
352| 	           code == KRB5KDC_ERR_POLICY ||
353| 	           code == KRB5KDC_ERR_ETYPE_NOSUPP ||
354| 	           code == KRB5_PREAUTH_FAILED) {
355| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
356| 			_adcli_err ("Couldn''t authenticate as machine account: %s: %s",
357| 			            name, krb5_get_error_message (conn->k5, code));
358| 		} else {
359| 			_adcli_err ("Couldn''t authenticate as: %s: %s",
360| 			            name, krb5_get_error_message (conn->k5, code));
361| 		}
362| 		return ADCLI_ERR_CREDENTIALS;
363| 
364| 	} else {
365| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
366| 			_adcli_err ("Couldn''t get kerberos ticket for machine account: %s: %s",
367| 			            name, krb5_get_error_message (conn->k5, code));
368| 		} else {
369| 			_adcli_err ("Couldn''t get kerberos ticket for: %s: %s",
370| 			            name, krb5_get_error_message (conn->k5, code));
371| 		}
372| 		return ADCLI_ERR_DIRECTORY;
373| 	}
374| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (211, 97, 'def44', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adenroll.c:1585: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adenroll.c:1585: noescape: Resource "krb5_get_error_message(k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adenroll.c:1585: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(k5, code)" leaks it.
# 1583|   	code = _adcli_kinit_computer_creds (enroll->conn, "kadmin/changepw", NULL, &creds);
# 1584|   	if (code != 0) {
# 1585|-> 		_adcli_err ("Couldn''t get change password ticket for %s account: %s: %s",
# 1586|   		            s_or_c (enroll),
# 1587|   		            enroll->computer_sam, krb5_get_error_message (k5, code));', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(k5, code)` at line 1585 is not explicitly freed within the provided code, including within the `_adcli_err` function, indicating a potential resource leak, as no deallocation function (e.g., `krb5_free_error_message`) is visibly called on its return value.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(k5, code)` at line 1585 is not freed or pointed-to within the `_adcli_err` function.

Upon examining the provided source code, there is no evidence of `krb5_free_error_message` (or any equivalent deallocation function) being called on the return value of `krb5_get_error_message(k5, code)` within the `_adcli_err` function or immediately after it (lines 1585-1587).

The `_adcli_err` function''s implementation is not provided in the context, but based on the explicit behavior of the provided code, there is no visible mechanism to free the allocated storage, leading to a potential resource leak.

The uncertainty regarding the implementation of `_adcli_err` does not provide sufficient grounds to conclude FALSE POSITIVE, as the provided code does not explicitly demonstrate the deallocation of the allocated storage.

A single vulnerable path, in this case, the error handling branch (line 1584), potentially triggers the resource leak vulnerability described in the CVE, satisfying the condition for a TRUE POSITIVE finding.', 'Verify the implementation of `_adcli_err` to check for any deallocation or proper handling of the resource allocated by `krb5_get_error_message(k5, code)`.

Investigate the call stack of `_adcli_err` to ensure no indirect deallocation or resource handling occurs.', 0.0000, '*** Source Code Context ***

code of library/adenroll.c file:
1564| static adcli_result
1565| set_password_with_computer_creds (adcli_enroll *enroll)
1566| {
1567| 	krb5_error_code code;
1568| 	krb5_creds creds;
1569| 	krb5_data result_string = { 0, };
1570| 	krb5_data result_code_string = { 0, };
1571| 	krb5_context k5;
1572| 	int result_code;
1573| 	adcli_result res;
1574| 	char *message;
1575| 
1576| 	memset (&creds, 0, sizeof (creds));
1577| 
1578| 	k5 = adcli_conn_get_krb5_context (enroll->conn);
1579| 	return_unexpected_if_fail (k5 != NULL);
1580| 
1581| 	_adcli_info ("Trying to change %s password with Kerberos", s_or_c (enroll));
1582| 
1583| 	code = _adcli_kinit_computer_creds (enroll->conn, "kadmin/changepw", NULL, &creds);
1584| 	if (code != 0) {
1585| 		_adcli_err ("Couldn''t get change password ticket for %s account: %s: %s",
1586| 		            s_or_c (enroll),
1587| 		            enroll->computer_sam, krb5_get_error_message (k5, code));
1588| 		return ADCLI_ERR_DIRECTORY;
1589| 	}
1590| 
1591| 	code = krb5_change_password (k5, &creds, enroll->computer_password,
1592| 	                             &result_code, &result_code_string, &result_string);
1593| 
1594| 	krb5_free_cred_contents (k5, &creds);
1595| 
1596| 	if (code != 0) {
1597| 		_adcli_err ("Couldn''t change password for %s account: %s: %s",
1598| 		            s_or_c (enroll),
1599| 		            enroll->computer_sam, krb5_get_error_message (k5, code));
1600| 		/* TODO: Parse out these values */
1601| 		res = ADCLI_ERR_DIRECTORY;
1602| 
1603| 	} else if (result_code != 0) {
1604| #ifdef HAVE_KRB5_CHPW_MESSAGE
1605| 		if (krb5_chpw_message (k5, &result_string, &message) != 0)
1606| 			message = NULL;
1607| #else
1608| 		message = NULL;
1609| 		if (result_string.length)
1610| 			message = _adcli_str_dupn (result_string.data, result_string.length);
1611| #endif
1612| 		_adcli_err ("Cannot change computer password: %.*s%s%s",
1613| 		            (int)result_code_string.length, result_code_string.data,
1614| 		            message ? ": " : "", message ? message : "");
1615| 		res = ADCLI_ERR_CREDENTIALS;
1616| #ifdef HAVE_KRB5_CHPW_MESSAGE
1617| 		krb5_free_string (k5, message);
1618| #else
1619| 		free (message);
1620| #endif
1621| 	} else {
1622| 		_adcli_info ("Changed computer password");
1623| 		if (enroll->kvno > 0) {
1624| 			enroll->kvno++;
1625| 		        _adcli_info ("kvno incremented to %d", enroll->kvno);
1626| 		}
1627| 		res = ADCLI_SUCCESS;
1628| 	}
1629| 
1630| 	krb5_free_data_contents (k5, &result_string);
1631| 	krb5_free_data_contents (k5, &result_code_string);
1632| 
1633| 	return res;
1634| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:820: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_computer_password".
adcli-0.9.2/tools/computer.c:827: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:828: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  826|   		       adcli_get_last_error ());
#  827|   		adcli_enroll_unref (enroll);
#  828|-> 		return -res;
#  829|   	}
#  830|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (213, 97, 'def46', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:603: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:605: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:606: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  604|   			if (res != ADCLI_SUCCESS) {
#  605|   				adcli_enroll_unref (enroll);
#  606|-> 				return res;
#  607|   			}
#  608|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:603: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:605: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:606: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  604|   ifndef (res != ADCLI_SUCCESS) {
#  605|    adcli_enroll_unref (enroll);
#  606|-> return res;
#  607|    
#  608|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:603: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:605: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:606: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  604|   			if (res != ADCLI_SUCCESS) {
#  605|   				adcli_enroll_unref (enroll);
#  606|-> 				return res;
#  607|   			}
#  608|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1196: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:1198: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1199: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1197|   			if (res != ADCLI_SUCCESS) {
# 1198|   				adcli_enroll_unref (enroll);
# 1199|-> 				return res;
# 1200|   			}
# 1201|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (214, 97, 'def47', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:801: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:803: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:804: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  802|   			if (res != ADCLI_SUCCESS) {
#  803|   				adcli_enroll_unref (enroll);
#  804|-> 				return res;
#  805|   			}
#  806|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:801: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:803: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:804: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  802|   ifndef (res != ADCLI_SUCCESS) {
#  803|    adcli_enroll_unref (enroll);
#  804|->  return res;
#  805|    }
#  806|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:801: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:803: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:804: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  802|   			if (res != ADCLI_SUCCESS) {
#  803|   				adcli_enroll_unref (enroll);
#  804|-> 				return res;
#  805|   			}
#  806|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:699: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:701: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:702: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  700|   			if (res != ADCLI_SUCCESS) {
#  701|   				adcli_enroll_unref (enroll);
#  702|-> 				return res;
#  703|   			}
#  704|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (215, 97, 'def48', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adkrb5.c:176: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adkrb5.c:176: noescape: Resource "krb5_get_error_message(NULL, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adkrb5.c:176: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(NULL, code)" leaks it.
#  174|   
#  175|   	} else if (code != 0) {
#  176|-> 		_adcli_err ("Failed to create kerberos context: %s",
#  177|   		            krb5_get_error_message (NULL, code));
#  178|   		return ADCLI_ERR_UNEXPECTED;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(NULL, code)` at `adkrb5.c:176` is not explicitly freed within the provided code snippet, particularly in the error path (lines 175-178), directly correlating with CWE-772 (Resource Leak).', '1. **Explicit Allocation**: The CVE report correctly identifies `krb5_get_error_message(NULL, code)` at `adkrb5.c:176` as an allocation function, which returns storage that needs to be managed.

2. **Lack of Deallocation**: Within the provided code snippet, there is no explicit call to free the storage allocated by `krb5_get_error_message(NULL, code)` before the function `_adcli_krb5_init_context` returns, especially in the error path (lines 175-178).

3. **No Indirect Deallocation Evidence**: Unlike the provided FALSE POSITIVE examples, where the resource was freed indirectly through another function called within the same scope, the given code for `adkrb5.c` does not show such a mechanism for `krb5_get_error_message`''s allocated storage within the provided context.

4. **Direct Correlation to CWE**: The described behavior directly correlates with CWE-772 (Resource Leak), as the allocated resource is not freed, leading to a leak.

5. **Single Vulnerable Path Identified**: The execution path where `code != 0` (line 175) and the subsequent call to `_adcli_err` with the allocated message (line 176) without any freeing of the resource, is a specific sequence that potentially triggers the vulnerability.', 'Obtain and analyze the implementation of the `_adcli_err` function to determine if it handles the freeing of the storage allocated by `krb5_get_error_message(NULL, code)`.

Investigate the call stack and execution flow of `_adcli_err` to identify any potential deallocation of the allocated storage in indirectly called functions.', 0.0000, '*** Source Code Context ***

code of library/adkrb5.c file:
166| adcli_result
167| _adcli_krb5_init_context (krb5_context *k5)
168| {
169| 	krb5_error_code code;
170| 
171| 	code = krb5_init_context (k5);
172| 	if (code == ENOMEM) {
173| 		return_unexpected_if_reached ();
174| 
175| 	} else if (code != 0) {
176| 		_adcli_err ("Failed to create kerberos context: %s",
177| 		            krb5_get_error_message (NULL, code));
178| 		return ADCLI_ERR_UNEXPECTED;
179| 	}
180| 
181| 	return ADCLI_SUCCESS;
182| }

code of /shared-data/source/adcli-0.9.2/library/adprivate.h file:
8|  * published by the Free Software Foundation; either version 2.1 of
9|  * the License, or (at your option) any later version.
10|  *
11|  * This program is distributed in the hope that it will be useful, but
12|  * WITHOUT ANY WARRANTY; without even the implied warranty of
13|  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14|  * Lesser General Public License for more details.
15|  *
16|  * You should have received a copy of the GNU Lesser General Public
17|  * License along with this program; if not, write to the Free Software
18|  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
19|  * MA 02110-1301 USA
20|  *
21|  * Author: Stef Walter <stefw@gnome.org>
22|  */
23| 
24| #ifndef ADPRIVATE_H_
25| #define ADPRIVATE_H_
26| 
27| #include "adattrs.h"
28| #include "adconn.h"
29| 
30| #include <stdarg.h>
31| #include <limits.h>
32| #include <stdlib.h>
33| #include <stdio.h>
34| #include <stdint.h>
35| 
36| #include <ldap.h>
37| 
38| #ifndef HOST_NAME_MAX
39| #define HOST_NAME_MAX 255
40| #endif
41| 
42| /* Some constants for the userAccountControl AD LDAP attribute, see e.g.
43|  * https://support.microsoft.com/en-us/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
44|  * for details. */
45| #define UAC_ACCOUNTDISABLE             0x0002
46| #define UAC_WORKSTATION_TRUST_ACCOUNT  0x1000
47| #define UAC_DONT_EXPIRE_PASSWORD      0x10000
48| #define UAC_TRUSTED_FOR_DELEGATION    0x80000
49| 
50| /* Utilities */
51| 
52| #if !defined(__cplusplus) && (__GNUC__ > 2)
53| #define GNUC_PRINTF(x, y) __attribute__((__format__(__printf__, x, y)))
54| #define GNUC_WARN_UNUSED __attribute__((warn_unused_result))
55| #else
56| #define GNUC_PRINTF(x, y)
57| #define GNUC_WARN_UNUSED
58| #endif
59| 
60| /* For detecting clang features */
61| #ifndef __has_feature
62| #define __has_feature(x) 0
63| #endif
64| 
65| #ifndef CLANG_ANALYZER_NORETURN
66| #if __has_feature(attribute_analyzer_noreturn)
67| #define CLANG_ANALYZER_NORETURN __attribute__((analyzer_noreturn))
68| #else
69| #define CLANG_ANALYZER_NORETURN
70| #endif
71| #endif
72| 
73| #define return_val_if_fail(x, v) \
74| 	do { if (!(x)) { \
75| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
76| 	     return v; \
77| 	} } while (0)
78| 
79| #define return_unexpected_if_fail(x) \
80| 	return_val_if_fail ((x), ADCLI_ERR_UNEXPECTED)
81| 
82| #define return_if_fail(x) \
83| 	do { if (!(x)) { \
84| 	     _adcli_precond_failed ("adcli: ''%s'' not true at %s
", #x, __func__); \
85| 	     return; \
86| 	} } while (0)
87| 
88| #define return_if_reached() \
89| 	do { \
90| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
91| 	     return; \
92| 	} while (0)
93| 
94| #define return_val_if_reached(v) \
95| 	do { \
96| 	     _adcli_precond_failed ("adcli: shouldn''t be reached at %s
", __func__); \
97| 	     return v; \
98| 	} while (0)
99| 
100| #define return_unexpected_if_reached() \
101| 	return_val_if_reached (ADCLI_ERR_UNEXPECTED)
102| 
103| void           _adcli_precond_failed         (const char *message,
104|                                               ...) GNUC_PRINTF (1, 2)
105|                                               CLANG_ANALYZER_NORETURN;
106| 
107| void           _adcli_err                    (const char *format,
108|                                              ...) GNUC_PRINTF(1, 2);
109| 
110| void           _adcli_warn                   (const char *format,
111|                                              ...) GNUC_PRINTF(1, 2);
112| 
113| void           _adcli_info                   (const char *format,
114|                                              ...) GNUC_PRINTF(1, 2);
115| 
116| int            _adcli_strv_len               (char **strv);
117| 
118| char **        _adcli_strv_add               (char **strv,
119|                                               char *string,
120|                                               int *length) GNUC_WARN_UNUSED;
121| 
122| char **        _adcli_strv_add_unique        (char **strv,
123|                                               char *string,
124|                                               int *length,
125|                                               bool case_sensitive) GNUC_WARN_UNUSED;
126| 
127| void           _adcli_strv_remove_unsorted   (char **strv,
128|                                               const char *string,
129|                                               int *length);
130| 
131| void           _adcli_strv_free              (char **strv);
132| 
133| int            _adcli_strv_has               (char **strv,
134|                                               const char *str);
135| 
136| int            _adcli_strv_has_ex            (char **strv,
137|                                               const char *str,
138|                                               int (* compare) (const char *match, const char*value));
139| 
140| char **        _adcli_strv_dup               (char **strv) GNUC_WARN_UNUSED;
141| 
142| char *         _adcli_strv_join              (char **strv,
143|                                               const char *delim);
144| 
145| void           _adcli_str_up                 (char *str);
146| 
147| void           _adcli_str_down               (char *str);
148| 
149| int            _adcli_str_is_up              (const char *str);
150| 
151| int            _adcli_str_has_prefix         (const char *str,
152| 		                              const char *prefix);
153| 
154| int            _adcli_str_has_suffix         (const char *str,
155| 		                              const char *suffix);
156| 
157| char *          _adcli_bin_sid_to_str        (const uint8_t *data,
158|                                               size_t len);
159| 
160| char *         _adcli_str_dupn               (void *data,
161|                                               size_t len);
162| 
163| void           _adcli_str_set                (char **field,
164|                                               const char *value);
165| 
166| void           _adcli_strv_set               (char ***field,
167|                                               const char **value);
168| 
169| int            _adcli_password_free          (char *password);
170| 
171| int            _adcli_write_all              (int fd,
172|                                               const char *buf,
173|                                               int len);
174| 
175| /* Connection helpers */
176| 
177| char *        _adcli_calc_reset_password     (const char *computer_name);
178| 
179| char *        _adcli_calc_netbios_name       (const char *host_fqdn);
180| 
181| krb5_error_code  _adcli_kinit_computer_creds      (adcli_conn *conn,
182|                                                    const char *in_tkt_service,
183|                                                    krb5_ccache ccache,
184|                                                    krb5_creds *creds);
185| 
186| krb5_error_code  _adcli_kinit_user_creds          (adcli_conn *conn,
187|                                                    const char *in_tkt_service,
188|                                                    krb5_ccache ccache,
189|                                                    krb5_creds *creds);
190| 
191| /* LDAP helpers */
192| 
193| adcli_result  _adcli_ldap_handle_failure     (LDAP *ldap,
194|                                               adcli_result defres,
195|                                               const char *desc,
196|                                               ...) GNUC_PRINTF(3, 4);
197| 
198| char *         _adcli_ldap_parse_sid         (LDAP *ldap,
199|                                               LDAPMessage *results,
200|                                               const char *attr_name);
201| 
202| char *        _adcli_ldap_parse_value        (LDAP *ldap,
203|                                               LDAPMessage *results,
204|                                               const char *attr_name);
205| 
206| char **       _adcli_ldap_parse_values       (LDAP *ldap,
207|                                               LDAPMessage *results,
208|                                               const char *attr_name);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (216, 97, 'def49', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:815: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:816: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  814|   		warnx ("specify one or more host names of computer accounts to preset");
#  815|   		adcli_enroll_unref (enroll);
#  816|-> 		return EUSAGE;
#  817|   	}
#  818|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:815: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:816: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  814|    warnx ("specify one or more host names of computer accounts to preset");
#  815|    adcli_enroll_unref (enroll);
#  816|-> return EUSAGE;
#  817|   }
#  818|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:815: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:816: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  814|   		warnx ("specify one or more host names of computer accounts to preset");
#  815|   		adcli_enroll_unref (enroll);
#  816|-> 		return EUSAGE;
#  817|   	}
#  818|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1110: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_read_computer_account".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1112: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_get_host_fqdn".
adcli-0.9.2/tools/computer.c:1117: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1118: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1116|   		       adcli_get_last_error ());
# 1117|   		adcli_enroll_unref (enroll);
# 1118|-> 		return -res;
# 1119|   	}
# 1120|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (217, 97, 'def50', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1002: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1003: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1001|   		warnx ("specify one host name of computer account to delete");
# 1002|   		adcli_enroll_unref (enroll);
# 1003|-> 		return EUSAGE;
# 1004|   	}
# 1005|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1002: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1003: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1001|    warnx ("specify one host name of computer account to delete");
# 1002|    adcli_enroll_unref (enroll);
# 1003|->    return EUSAGE;
# 1004|   }
# 1005|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:972: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:972: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1002: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1003: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1001|   		warnx ("specify one host name of computer account to delete");
# 1002|   		adcli_enroll_unref (enroll);
# 1003|-> 		return EUSAGE;
# 1004|   	}
# 1005|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:914: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:915: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  913|   		warnx ("specify one host name of computer account to reset");
#  914|   		adcli_enroll_unref (enroll);
#  915|-> 		return EUSAGE;
#  916|   	}
#  917|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (218, 97, 'def51', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/tools.c:402: alloc_arg: "asprintf" allocates memory that is stored into "filename". [Note: The source code implementation of the function has been overridden by a builtin model.]
adcli-0.9.2/tools/tools.c:408: overwrite_var: Overwriting "filename" in "filename = NULL" leaks the storage that "filename" points to.
#  406|   			              krb5_conf ? krb5_conf : "") < 0) {
#  407|   				warnx ("unexpected: out of memory");
#  408|-> 				filename = NULL; /* content is undefined */
#  409|   				snippets = NULL; /* content is undefined */
#  410|   				contents = NULL; /* content is undefined */', 'TRUE POSITIVE', 'Memory allocated for `filename` at line 402 is overwritten with `NULL` at line 408 without guaranteed deallocation, as the subsequent `free (filename)` at line 458 is conditional and may not execute if `failed` is set to 1, directly linking to a potential memory leak vulnerability.', 'The CVE report indicates a potential memory leak due to overwriting the `filename` pointer with `NULL` at line 408, before freeing the allocated memory.

At line 402, `asprintf` allocates memory for `filename`, which is a clear allocation of resources that requires subsequent deallocation to prevent memory leaks.

Upon examining the provided source code, there is no explicit `free` operation for the `filename` pointer between its allocation (line 402) and its overwrite with `NULL` (line 408).

Although `free (filename);` is present at line 458, it is conditional (within the `else` block of the `if (!failed)` statement at line 457). If the `failed` variable is set to 1 (which occurs if any of the preceding allocations or operations fail, including the `asprintf` at line 402), this `free` operation will not execute, leading to a memory leak.

Given the direct correlation between the allocated memory for `filename` and its potential overwrite without deallocation under specific error conditions, there is a demonstrable link to the vulnerability described in the CVE (memory leak due to overwriting a pointer without freeing the allocated memory).

Since at least one execution path (when `failed` is set to 1) potentially leads to the described vulnerability, the finding cannot be conclusively marked as a FALSE POSITIVE based on the provided code and CVE description.', 'Examine the entire function containing the reported CVE to identify all possible execution paths and error handling mechanisms.

Verify the definition and usage of the `failed` variable to understand its impact on the `free` operation at line 458.

Investigate if there are any indirect deallocations or memory management functions called elsewhere in the program that could mitigate the potential memory leak.', 0.0000, '*** Source Code Context ***

code of tools/tools.c file:
352| static void
353| setup_krb5_conf_directory (adcli_conn *conn)
354| {
355| 	const char *parent;
356| 	const char *krb5_conf;
357| 	char *filename = NULL;
358| 	char *snippets = NULL;
359| 	char *contents = NULL;
360| 	char *directory = NULL;
361| 	struct stat sb;
362| 	int failed = 0;
363| 	int errn = 0;
364| 	FILE *fo;
365| 
366| 	krb5_conf = getenv ("KRB5_CONFIG");
367| 	if (!krb5_conf || !krb5_conf[0])
368| 		krb5_conf = KRB5_CONFIG;
369| 
370| 	parent = getenv ("TMPDIR");
371| 	if (!parent || !*parent)
372| 		parent = _PATH_TMP;
373| 
374| 	/* Check that the config file exists, don''t include if not */
375| 	if (stat (krb5_conf, &sb) < 0) {
376| 		if (errno != ENOENT)
377| 			warn ("couldn''t access file: %s", krb5_conf);
378| 		krb5_conf = NULL;
379| 	}
380| 
381| 	if (asprintf (&directory, "%s%sadcli-krb5-XXXXXX", parent,
382| 	              (parent[0] && parent[strlen(parent) - 1] == ''/'') ? "" : "/") < 0) {
383| 		warnx ("unexpected: out of memory");
384| 		directory = NULL; /* content is undefined */
385| 		failed = 1;
386| 	}
387| 
388| 	if (!failed) {
389| 		mode_t old_umask;
390| 		char *dtemp = NULL;
391| 
392| 		old_umask = umask (0077);
393| 		dtemp = mkdtemp (directory);
394| 		umask (old_umask);
395| 
396| 		if (dtemp == NULL) {
397| 			errn = errno;
398| 			failed = 1;
399| 			warnx ("couldn''t create temporary directory in: %s: %s",
400| 			       parent, strerror (errn));
401| 		} else {
402| 			if (asprintf (&filename, "%s/krb5.conf", directory) < 0 ||
403| 			    asprintf (&snippets, "%s/krb5.d", directory) < 0 ||
404| 			    asprintf (&contents, "includedir %s
%s%s
", snippets,
405| 			              krb5_conf ? "include " : "",
406| 			              krb5_conf ? krb5_conf : "") < 0) {
407| 				warnx ("unexpected: out of memory");
408| 				filename = NULL; /* content is undefined */
409| 				snippets = NULL; /* content is undefined */
410| 				contents = NULL; /* content is undefined */
411| 				failed = 1;
412| 			}
413| 		}
414| 	}
415| 
416| 	if (!failed) {
417| 		fo = fopen (filename, "wb");
418| 		if (fo == NULL) {
419| 			errn = errno;
420| 			failed = 1;
421| 		} else {
422| 			fwrite (contents, 1, strlen (contents), fo);
423| 			if (ferror (fo)) {
424| 				errn = errno;
425| 				failed = 1;
426| 				fclose (fo);
427| 			} else {
428| 				if (fclose (fo) != 0) {
429| 					failed = 1;
430| 					errn = errno;
431| 				}
432| 			}
433| 		}
434| 
435| 		if (failed) {
436| 			warnx ("couldn''t write new krb5.conf file: %s: %s",
437| 			       filename, strerror (errn));
438| 		}
439| 	}
440| 
441| 
442| 	if (!failed && mkdir (snippets, 0700) < 0) {
443| 		errn = errno;
444| 		failed = 1;
445| 		warnx ("couldn''t write new krb5.d directory: %s: %s",
446| 		       snippets, strerror (errn));
447| 	}
448| 
449| 	if (!failed) {
450| 		adcli_conn_set_krb5_conf_dir (conn, snippets);
451| 		adcli_temp_directory = directory;
452| 		adcli_krb5_conf_filename = filename;
453| 		adcli_krb5_d_directory = snippets;
454| 		setenv ("KRB5_CONFIG", adcli_krb5_conf_filename, 1);
455| 		setenv ("SSSD_KRB5_LOCATOR_DISABLE", "true", 1);
456| 
457| 	} else {
458| 		free (filename);
459| 		free (snippets);
460| 		free (directory);
461| 	}
462| 
463| 	free (contents);
464| 	atexit (cleanup_krb5_conf_directory);
465| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:500: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:501: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  499|   		       adcli_get_last_error ());
#  500|   		adcli_enroll_unref (enroll);
#  501|-> 		return -res;
#  502|   	}
#  503|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (219, 97, 'def52', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:708: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adconn.c:708: noescape: Resource "krb5_get_error_message(NULL, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adconn.c:708: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(NULL, code)" leaks it.
#  706|   
#  707|   			if (code != 0) {
#  708|-> 				_adcli_err ("Couldn''t open kerberos credential cache: %s: %s",
#  709|   				            conn->login_ccache_name, krb5_get_error_message (NULL, code));
#  710|   				return ADCLI_ERR_CONFIG;', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message(NULL, code)` at line 708 is not freed or pointed-to within the `_adcli_err` function, and the immediate return at line 710 confirms a resource leak, as there''s no visible mechanism for deallocation within the provided code.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(NULL, code)` at line 708 is not freed or pointed-to within the `_adcli_err` function.

Upon examining the provided source code, there is no evidence of the allocated storage being freed or stored for later freeing within the execution path of lines 706-710.

Specifically, after the error message is passed to `_adcli_err` at line 708, the function immediately returns `ADCLI_ERR_CONFIG` at line 710, without any visible mechanism for freeing the allocated storage.

The lack of explicit deallocation (e.g., a corresponding `free` or `krb5_free_error_message` call) for the storage allocated by `krb5_get_error_message` within the provided code snippet confirms the resource leak vulnerability as described in the CVE.

No assumptions about the behavior of `_adcli_err` or other external functions are made, as the analysis is strictly based on the provided code''s explicit operations (or lack thereof) regarding memory management.', NULL, 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
673| static adcli_result
674| prep_kerberos_and_kinit (adcli_conn *conn)
675| {
676| 	krb5_error_code code;
677| 	int logged_in = 0;
678| 	krb5_ccache ccache;
679| 	adcli_result res;
680| 
681| 	if (conn->login_ccache_name != NULL) {
682| 		if (!conn->ccache) {
683| 
684| 			/*
685| 			 * If we already have a kerberos ccache file, just open it. This
686| 			 * serves two purposes:
687| 			 * a) We want to make sure it''s present, so we can provide more
688| 			 *    intelligible messages than ldap_sasl_interactive_bind_s()
689| 			 * b) We want to have the ccache member populated so we can use
690| 			 *    it in other operations such as changing the computer password.
691| 			 */
692| 
693| 			if (strcmp (conn->login_ccache_name, "") == 0) {
694| 				code = krb5_cc_default (conn->k5, &conn->ccache);
695| 				if (code == 0) {
696| 					free (conn->login_ccache_name);
697| 					conn->login_ccache_name = NULL;
698| 					code = krb5_cc_get_full_name (conn->k5, conn->ccache,
699| 					                              &conn->login_ccache_name);
700| 					conn->login_ccache_name_is_krb5 = 1;
701| 					return_unexpected_if_fail (code == 0);
702| 				}
703| 			} else {
704| 				code = krb5_cc_resolve (conn->k5, conn->login_ccache_name, &conn->ccache);
705| 			}
706| 
707| 			if (code != 0) {
708| 				_adcli_err ("Couldn''t open kerberos credential cache: %s: %s",
709| 				            conn->login_ccache_name, krb5_get_error_message (NULL, code));
710| 				return ADCLI_ERR_CONFIG;
711| 			}
712| 		}
713| 		return ADCLI_SUCCESS;
714| 	}
715| 
716| 	if (conn->login_keytab_name != NULL) {
717| 		if (!conn->keytab) {
718| 			res = _adcli_krb5_open_keytab (conn->k5, conn->login_keytab_name, &conn->keytab);
719| 			if (res != ADCLI_SUCCESS) {
720| 				if (res == ADCLI_ERR_FAIL)
721| 					res = ADCLI_ERR_CONFIG;
722| 				return res;
723| 			}
724| 
725| 			if (strcmp (conn->login_keytab_name, "") == 0) {
726| 				free (conn->login_keytab_name);
727| 				conn->login_keytab_name = malloc (MAX_KEYTAB_NAME_LEN);
728| 				code = krb5_kt_get_name (conn->k5, conn->keytab,
729| 				                         conn->login_keytab_name, MAX_KEYTAB_NAME_LEN);
730| 				conn->login_keytab_name_is_krb5 = 1;
731| 				return_unexpected_if_fail (code == 0);
732| 			}
733| 		}
734| 	}
735| 
736| 	/* Initialize the credential cache */
737| 	code = krb5_cc_new_unique (conn->k5, "MEMORY", NULL, &ccache);
738| 	return_unexpected_if_fail (code == 0);
739| 
740| 	/*
741| 	 * Should we try to connect with computer account default password?
742| 	 * This is the password set by ''Reset Accuont'' on a computer object.
743| 	 * If the caller explicitly specified a login name or password, then
744| 	 * go straight to that.
745| 	 */
746| 
747| 	if (conn->logins_allowed & ADCLI_LOGIN_COMPUTER_ACCOUNT) {
748| 		res = kinit_with_computer_credentials (conn, ccache);
749| 		logged_in = (res == ADCLI_SUCCESS);
750| 	}
751| 
752| 	/* Use login credentials */
753| 	if (!logged_in && (conn->logins_allowed & ADCLI_LOGIN_USER_ACCOUNT)) {
754| 		res = kinit_with_user_credentials (conn, ccache);
755| 		logged_in = (res == ADCLI_SUCCESS);
756| 	}
757| 
758| 	if (logged_in) {
759| 		code = krb5_cc_get_full_name (conn->k5, ccache,
760| 		                              &conn->login_ccache_name);
761| 		return_unexpected_if_fail (code == 0);
762| 
763| 		conn->ccache = ccache;
764| 		conn->login_ccache_name_is_krb5 = 1;
765| 		ccache = NULL;
766| 		res = ADCLI_SUCCESS;
767| 	} else {
768| 		res = ADCLI_ERR_FAIL;
769| 	}
770| 
771| 	if (ccache != NULL)
772| 		krb5_cc_close (conn->k5, ccache);
773| 	return res;
774| 
775| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (220, 97, 'def53', 'USE_AFTER_FREE', 'adcli-0.9.2/library/adutil.c:865: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:877: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  875|   	                                    &stdout_data, &stdout_data_len);
#  876|   	assert (res == ADCLI_SUCCESS);
#  877|-> 	assert (strncmp ("olleH\n", (char *) stdout_data, stdout_data_len) == 0);
#  878|   	free (stdout_data);
#  879|   #endif', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/library/adutil.c:865: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:877: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  875|                                    &stdout_data, &stdout_data_len);
#  876|   assert (res == ADCLI_SUCCESS);
#  877|-> assert (strncmp ("olleH\n", (char *) stdout_data, stdout_data_len) == 0);
#  878|   free (stdout_data);
#  879|  #endif', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:865: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:877: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  875|   	                                    &stdout_data, &stdout_data_len);
#  876|   	assert (res == ADCLI_SUCCESS);
#  877|-> 	assert (strncmp ("olleH
", (char *) stdout_data, stdout_data_len) == 0);
#  878|   	free (stdout_data);
#  879|   #endif
(Example-1) Reason Marked as False Positive:
After the `free()` in line 865 there is a function call which allocates new memory for `stdout_data`.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
adcli-0.9.2/library/adutil.c:887: freed_arg: "free" frees "stdout_data".
adcli-0.9.2/library/adutil.c:896: deref_arg: Calling "strncmp" dereferences freed pointer "(char *)stdout_data".
#  894|   	                                    &stdout_data, &stdout_data_len);
#  895|   	assert (res == ADCLI_SUCCESS);
#  896|-> 	assert (strncmp ("Hello
", (char *) stdout_data, stdout_data_len) == 0);
#  897|   	free (stdout_data);
#  898|   #endif
(Example-2) Reason Marked as False Positive:
After the `free()` in line 887 there is a function call which allocates new memory for `stdout_data`.

', '2025-11-17 21:39:07.025556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (268, 112, 'def29', 'nan', 'nan', 'FALSE POSITIVE', 'Investigation yields FALSE POSITIVE due to insufficient information: no CVE report snippet, source code context, or comparative examples were provided to assess potential vulnerabilities.', 'No CVE Report Snippet is provided to analyze against the source code.

No Source Code Context is provided to examine for potential vulnerabilities.

No Examples of verified CVEs with the same CWE are provided for comparative analysis.

Without explicit information about the CVE, source code, and comparative examples, it''s impossible to determine if a vulnerability exists or if it''s a false positive based on the provided guidelines.', 'Provide the complete CVE report snippet for the reported vulnerability.

Share the relevant source code snippets that are potentially affected by the reported CVE.

Offer examples of validated CVEs with the same CWE for comparative analysis and context.

Ensure all provided data is directly related to the reported CVE to facilitate a focused evaluation.', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:07.050081');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (221, 97, 'def54', 'RESOURCE_LEAK', 'adcli-0.9.2/library/adconn.c:369: alloc_fn: Storage is returned from allocation function "krb5_get_error_message".
adcli-0.9.2/library/adconn.c:369: noescape: Resource "krb5_get_error_message(conn->k5, code)" is not freed or pointed-to in "_adcli_err".
adcli-0.9.2/library/adconn.c:369: leaked_storage: Failing to save or free storage allocated by "krb5_get_error_message(conn->k5, code)" leaks it.
#  367|   			            name, krb5_get_error_message (conn->k5, code));
#  368|   		} else {
#  369|-> 			_adcli_err ("Couldn''t get kerberos ticket for: %s: %s",
#  370|   			            name, krb5_get_error_message (conn->k5, code));
#  371|   		}', 'TRUE POSITIVE', 'Storage allocated by `krb5_get_error_message` is not explicitly freed within the provided code snippet (lines 367-371), potentially leading to a resource leak (CWE-772), as it is not freed or pointed-to after allocation in both conditional branches.', 'The CVE report explicitly states that the storage allocated by `krb5_get_error_message(conn->k5, code)` is not freed or pointed-to in `_adcli_err` (lines 369, referencing both the allocation and the lack of freeing).

The provided source code context (lines 367-371) confirms that `krb5_get_error_message(conn->k5, code)` is called twice, once in each branch of the conditional statement, but there is no visible call to a function that would free the allocated storage within the provided code snippet.

The function `_adcli_err` is not defined within the provided source code context, but based on the explicit behavior of the provided code, there is no evidence that the storage allocated by `krb5_get_error_message` is freed within the execution paths shown (lines 367-371).

Given the strict guidelines, the lack of explicit proof within the provided code that all execution paths safely free the allocated storage implies a potential resource leak, aligning with the CVE description of a leaked storage vulnerability (CWE-772).

Since a single vulnerable path is sufficient to conclude a TRUE POSITIVE, and given the direct correlation between the code''s behavior and the described vulnerability, the finding cannot be definitively marked as a FALSE POSITIVE based on the provided information.', 'Obtain and analyze the implementation of the `_adcli_err` function to determine if it frees the storage allocated by `krb5_get_error_message`.

Investigate all possible execution paths that may lead to the freeing of the allocated storage, including any functions indirectly called by `_adcli_err`.', 0.0000, '*** Source Code Context ***

code of library/adconn.c file:
336| static adcli_result
337| handle_kinit_krb5_code (adcli_conn *conn,
338|                         adcli_login_type type,
339|                         const char *name,
340|                         krb5_error_code code)
341| {
342| 	if (code == 0) {
343| 		return ADCLI_SUCCESS;
344| 
345| 	} else if (code == ENOMEM) {
346| 		return_unexpected_if_reached ();
347| 
348| 	} else if (code == KRB5KDC_ERR_PREAUTH_FAILED ||
349| 	           code == KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ||
350| 	           code == KRB5KDC_ERR_KEY_EXP ||
351| 	           code == KRB5KDC_ERR_CLIENT_REVOKED ||
352| 	           code == KRB5KDC_ERR_POLICY ||
353| 	           code == KRB5KDC_ERR_ETYPE_NOSUPP ||
354| 	           code == KRB5_PREAUTH_FAILED) {
355| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
356| 			_adcli_err ("Couldn''t authenticate as machine account: %s: %s",
357| 			            name, krb5_get_error_message (conn->k5, code));
358| 		} else {
359| 			_adcli_err ("Couldn''t authenticate as: %s: %s",
360| 			            name, krb5_get_error_message (conn->k5, code));
361| 		}
362| 		return ADCLI_ERR_CREDENTIALS;
363| 
364| 	} else {
365| 		if (type == ADCLI_LOGIN_COMPUTER_ACCOUNT) {
366| 			_adcli_err ("Couldn''t get kerberos ticket for machine account: %s: %s",
367| 			            name, krb5_get_error_message (conn->k5, code));
368| 		} else {
369| 			_adcli_err ("Couldn''t get kerberos ticket for: %s: %s",
370| 			            name, krb5_get_error_message (conn->k5, code));
371| 		}
372| 		return ADCLI_ERR_DIRECTORY;
373| 	}
374| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:927: noescape: Resource "enroll" is not freed or pointed-to in "parse_fqdn_or_name".
adcli-0.9.2/tools/computer.c:928: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_reset_computer_password".
adcli-0.9.2/tools/computer.c:930: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_password".
adcli-0.9.2/tools/computer.c:935: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:936: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  934|   		       adcli_get_last_error ());
#  935|   		adcli_enroll_unref (enroll);
#  936|-> 		return -res;
#  937|   	}
#  938|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (222, 97, 'def55', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:792: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:793: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  791|   			adcli_tool_usage (options, common_usages);
#  792|   			adcli_enroll_unref (enroll);
#  793|-> 			return 0;
#  794|   		case ''?'':
#  795|   		case '':'':', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:792: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:793: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  791|    	adcli_tool_usage (options, common_usages);
#  792|    	adcli_enroll_unref (enroll);
#  793|-> 	return 0;
#  794|    	case ''?'':
#  795|    	case '':''', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:792: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:793: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  791|   			adcli_tool_usage (options, common_usages);
#  792|   			adcli_enroll_unref (enroll);
#  793|-> 			return 0;
#  794|   		case ''?'':
#  795|   		case '':'':
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:777: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:777: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:798: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:799: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  797|   			adcli_tool_usage (options, common_usages);
#  798|   			adcli_enroll_unref (enroll);
#  799|-> 			return 2;
#  800|   		default:
#  801|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (223, 97, 'def56', 'RESOURCE_LEAK', 'adcli-0.9.2/library/seq.c:316: alloc_fn: Storage is returned from allocation function "calloc".
adcli-0.9.2/library/seq.c:316: var_assign: Assigning: "copied" = storage returned from "calloc(alloc, 8UL)".
adcli-0.9.2/library/seq.c:324: leaked_storage: Variable "copied" going out of scope leaks the storage it points to.
#  322|   		} else {
#  323|   			copied[at] = copy (seq[at]);
#  324|-> 			bail_on_null (copied[at]);
#  325|   		}
#  326|   	}', 'FALSE POSITIVE', 'Memory allocated for ''copied'' is returned at line 329, transferring ownership to the caller, and there''s no evidence within the provided code that this memory is mishandled, thus no leak within this function''s scope.', 'The reported leak is based on the variable ''copied'' going out of scope at line 324, but this analysis is premature as the function''s scope extends beyond this line.

The memory allocated for ''copied'' is indeed returned from the function at line 329: ''return copied;'', which means the caller is responsible for managing this memory, thus not a leak within this function''s scope.

There is no evidence within the provided code snippet that the memory allocated for ''copied'' (and its elements, when ''copy'' is not NULL) is not properly handled by the caller, which would be necessary to confirm a leak.

The ''bail_on_null'' check at line 324 does not imply memory leak; it''s a null pointer check, which is a separate concern from memory management.

The allocation and assignment at line 316 are properly handled, as the allocated memory is used and then returned, not abandoned or leaked within the provided code context.', NULL, 0.0000, '*** Source Code Context ***

code of library/seq.c file:
299| void *
300| seq_dup (seq_voidp sequence,
301|          int *length,
302|          seq_copy copy)
303| {
304| 	void **seq = sequence;
305| 	void **copied;
306| 	int alloc;
307| 	int len;
308| 	int at;
309| 
310| 	assert (length != NULL);
311| 
312| 	len = *length;
313| 	alloc = alloc_size (len + 1);
314| 	assert (alloc != 0);
315| 
316| 	copied = calloc (alloc, sizeof (void *));
317| 	bail_on_null (copied);
318| 
319| 	for (at = 0; at < len; at++) {
320| 		if (copy == NULL) {
321| 			copied[at] = seq[at];
322| 		} else {
323| 			copied[at] = copy (seq[at]);
324| 			bail_on_null (copied[at]);
325| 		}
326| 	}
327| 
328| 	copied[len] = NULL;
329| 	return copied;
330| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (224, 97, 'def57', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|    warnx ("Failed to set domain specific keytab name");
# 1227|    adcli_enroll_unref (enroll);
# 1228|->    return 2;
# 1229|   }
# 1230|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1222: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_set_is_service".
adcli-0.9.2/tools/computer.c:1224: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_add_keytab_for_service_account".
adcli-0.9.2/tools/computer.c:1227: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1228: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1226|   		warnx ("Failed to set domain specific keytab name");
# 1227|   		adcli_enroll_unref (enroll);
# 1228|-> 		return 2;
# 1229|   	}
# 1230|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1170: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1170: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1218: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1219: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1217|   		warnx ("domain name is required");
# 1218|   		adcli_enroll_unref (enroll);
# 1219|-> 		return 2;
# 1220|   	}
# 1221|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (225, 97, 'def58', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|      adcli_get_last_error ());
# 1102|     adcli_enroll_unref (enroll);
# 1103|->  return -res;
# 1104|   }
# 1105|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:1069: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:1069: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:1102: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:1103: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
# 1101|   		       adcli_get_last_error ());
# 1102|   		adcli_enroll_unref (enroll);
# 1103|-> 		return -res;
# 1104|   	}
# 1105|
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:923: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:924: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  922|   		       adcli_get_last_error ());
#  923|   		adcli_enroll_unref (enroll);
#  924|-> 		return -res;
#  925|   	}
#  926|
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (226, 97, 'def59', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:475: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:477: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:478: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  476|   			if (res != ADCLI_SUCCESS) {
#  477|   				adcli_enroll_unref (enroll);
#  478|-> 				return res;
#  479|   			}
#  480|   			break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:475: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:477: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:478: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  476|   ifndef (res != ADCLI_SUCCESS) {
#  477|    adcli_enroll_unref (enroll);
#  478|->  return res;
#  479|    }
#  480|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:443: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:443: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:475: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:477: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:478: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  476|   			if (res != ADCLI_SUCCESS) {
#  477|   				adcli_enroll_unref (enroll);
#  478|-> 				return res;
#  479|   			}
#  480|   			break;
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:575: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:575: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:603: noescape: Resource "enroll" is not freed or pointed-to in "parse_option".
adcli-0.9.2/tools/computer.c:605: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:606: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  604|   			if (res != ADCLI_SUCCESS) {
#  605|   				adcli_enroll_unref (enroll);
#  606|-> 				return res;
#  607|   			}
#  608|   			break;
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025558');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (227, 97, 'def60', 'RESOURCE_LEAK', 'adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:897: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:898: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  896|   			adcli_tool_usage (options, common_usages);
#  897|   			adcli_enroll_unref (enroll);
#  898|-> 			return opt == ''h'' ? 0 : 2;
#  899|   		default:
#  900|   			res = parse_option ((Option)opt, optarg, conn, enroll);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:897: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:898: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  896|    		adcli_tool_usage (options, common_usages);
#  897|    		adcli_enroll_unref (enroll);
#  898|-> 		return opt == ''h'' ? 0 : 2;
#  899|    	default:
#  900|    		res = parse_option ((Option)opt, optarg, conn, enroll);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:884: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:884: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:897: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:898: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  896|   			adcli_tool_usage (options, common_usages);
#  897|   			adcli_enroll_unref (enroll);
#  898|-> 			return opt == ''h'' ? 0 : 2;
#  899|   		default:
#  900|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-1) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
adcli-0.9.2/tools/computer.c:683: alloc_fn: Storage is returned from allocation function "adcli_enroll_new".
adcli-0.9.2/tools/computer.c:683: var_assign: Assigning: "enroll" = storage returned from "adcli_enroll_new(conn)".
adcli-0.9.2/tools/computer.c:696: noescape: Resource "enroll" is not freed or pointed-to in "adcli_enroll_unref".
adcli-0.9.2/tools/computer.c:697: leaked_storage: Variable "enroll" going out of scope leaks the storage it points to.
#  695|   			adcli_tool_usage (options, common_usages);
#  696|   			adcli_enroll_unref (enroll);
#  697|-> 			return opt == ''h'' ? 0 : 2;
#  698|   		default:
#  699|   			res = parse_option ((Option)opt, optarg, conn, enroll);
(Example-2) Reason Marked as False Positive:
`enroll` is not freed directly in `adcli_unref_enroll()` but in a funtion called in `adcli_unret_enroll()`

', '2025-11-17 21:39:07.025558');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (228, 94, 'def1', 'OVERRUN', 'gzip-1.13/deflate.c:713: cond_at_least: Checking "lookahead < 262U" implies that "lookahead" is at least 262 on the false branch.
gzip-1.13/deflate.c:660: assignment: Assigning: "match_length" = "lookahead". The value of "match_length" is now at least 262.
gzip-1.13/deflate.c:665: overrun-call: Overrunning callee''s array of size 256 by passing argument "match_length - 3U" (which evaluates to 259) in call to "ct_tally".
#  663|               check_match(strstart, match_start, match_length);
#  664|   
#  665|->             flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
#  666|   
#  667|               lookahead -= match_length;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/deflate.c:713: cond_at_least: Checking "lookahead < 262U" implies that "lookahead" is at least 262 on the false branch.
gzip-1.13/deflate.c:660: assignment: Assigning: "match_length" = "lookahead". The value of "match_length" is now at least 262.
gzip-1.13/deflate.c:665: overrun-call: Overrunning callee''s array of size 256 by passing argument "match_length - 3U" (which evaluates to 259) in call to "ct_tally".
#  663|               check_match(strstart, match_start, match_length);
#  664|   
#  665|->             flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
#  666|   
#  667|               lookahead -= match_length;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/deflate.c:713: cond_at_least: Checking "lookahead < 262U" implies that "lookahead" is at least 262 on the false branch.
gzip-1.13/deflate.c:660: assignment: Assigning: "match_length" = "lookahead". The value of "match_length" is now at least 262.
gzip-1.13/deflate.c:665: overrun-call: Overrunning callee''s array of size 256 by passing argument "match_length - 3U" (which evaluates to 259) in call to "ct_tally".
#  663|               check_match(strstart, match_start, match_length);
#  664|   
#  665|->             flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
#  666|   
#  667|               lookahead -= match_length;
(Example-1) Reason Marked as False Positive:
Assuming this refers to the length_code[lc] in ct_tally function, the value of lc is checked by the asserts to be smaller than the array size

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/deflate.c:771: cond_between: Checking "prev_length >= 3U" implies that "prev_length" is between 4 and 261 (inclusive) on the true branch.
gzip-1.13/deflate.c:775: overrun-call: Overrunning callee''s array of size 256 by passing argument "prev_length - 3U" (which evaluates to 258) in call to "ct_tally".
#  773|               check_match(strstart-1, prev_match, prev_length);
#  774|   
#  775|->             flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
#  776|   
#  777|               /* Insert in hash table all strings up to the end of the match.
(Example-2) Reason Marked as False Positive:
Assuming this refers to the length_code[lc] in ct_tally function, the value of lc is checked by the asserts to be smaller than the array size

', '2025-11-17 21:39:07.041396');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (230, 94, 'def3', 'OVERRUN', 'gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:369: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  367|     if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|->   c[i] += y;
#  370|   
#  371|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:369: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  367|     if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|->   c[i] += y;
#  370|   
#  371|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:369: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  367|     if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|->   c[i] += y;
#  370|   
#  371|
(Example-1) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:367: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  365|       if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|->   if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|     c[i] += y;
(Example-2) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

', '2025-11-17 21:39:07.0414');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (231, 94, 'def4', 'USE_AFTER_FREE', 'gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:860: freed_arg: "huft_free" frees "tl".
gzip-1.13/inflate.c:897: pass_freed_arg: Passing freed pointer "td" as an argument to "inflate_codes".
#  895|     {
#  896|       /* decompress until an end-of-block code */
#  897|->     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
#  898|   
#  899|       /* free the decoding tables */', 'TRUE POSITIVE', 'td, derived from freed pointer tl (line 813), is used after tl''s memory is freed (line 860), creating a potential USE_AFTER_FREE (CWE-416) vulnerability without explicit reinitialization or mitigation in the provided code.', 'The reported issue is not solely about the assignment at line 813, but rather the sequence of events leading to a potential **USE_AFTER_FREE (CWE-416)** vulnerability.

At line 813, `td` is assigned a value based on `tl` and other variables, which in itself is not indicative of a vulnerability.

However, at line 860, `huft_free(tl)` is called, freeing the memory allocated for `tl`.

Subsequently, at line 897, `td` (which was derived from `tl`) is passed as an argument to `inflate_codes` **after** `tl` has been freed.

Given that `td` is a pointer derived from `tl` (line 813: `td = tl + ((unsigned int)b & m)`), and `tl` is freed before `td` is used, this creates a potential **USE_AFTER_FREE** scenario.

There is no explicit evidence in the provided code that `td` is reinitialized or its derivation from `tl` is mitigated between the `huft_free(tl)` call and its use in `inflate_codes`.

Unlike **Example-1** and **Example-2** (known false positives), where the second `huft_free` is called after the table has been rebuilt by `huft_build`, there is no such rebuilding of `tl` (or implicitly `td`) between its freeing and the use of `td` in the provided code snippet.

Therefore, based on the explicit behavior of the provided source code and the description in the CVE report, there is a potential vulnerability, leading to a **TRUE POSITIVE** conclusion.', NULL, 0.0000, '*** Source Code Context ***

code of inflate.c file:
734| static int
735| inflate_dynamic(void)
736| {
737|   int i;                /* temporary variables */
738|   unsigned j;
739|   unsigned l;           /* last length */
740|   unsigned m;           /* mask for bit lengths table */
741|   unsigned n;           /* number of lengths to get */
742|   unsigned w;           /* current window position */
743|   struct huft *tl;      /* literal/length code table */
744|   struct huft *td;      /* distance code table */
745|   int bl;               /* lookup bits for tl */
746|   int bd;               /* lookup bits for td */
747|   unsigned nb;          /* number of bit length codes */
748|   unsigned nl;          /* number of literal/length codes */
749|   unsigned nd;          /* number of distance codes */
750| #ifdef PKZIP_BUG_WORKAROUND
751|   unsigned ll[288+32];  /* literal/length and distance code lengths */
752| #else
753|   unsigned ll[286+30];  /* literal/length and distance code lengths */
754| #endif
755|   register ulg b;       /* bit buffer */
756|   register unsigned k;  /* number of bits in bit buffer */
757| 
758| 
759|   /* make local bit buffer */
760|   b = bb;
761|   k = bk;
762|   w = wp;
763| 
764| 
765|   /* read in table lengths */
766|   NEEDBITS(5)
767|   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
768|   DUMPBITS(5)
769|   NEEDBITS(5)
770|   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
771|   DUMPBITS(5)
772|   NEEDBITS(4)
773|   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
774|   DUMPBITS(4)
775| #ifdef PKZIP_BUG_WORKAROUND
776|   if (nl > 288 || nd > 32)
777| #else
778|   if (nl > 286 || nd > 30)
779| #endif
780|     return 1;                   /* bad lengths */
781| 
782| 
783|   /* read in bit-length-code lengths */
784|   for (j = 0; j < nb; j++)
785|   {
786|     NEEDBITS(3)
787|     ll[border[j]] = (unsigned)b & 7;
788|     DUMPBITS(3)
789|   }
790|   for (; j < 19; j++)
791|     ll[border[j]] = 0;
792| 
793| 
794|   /* build decoding table for trees--single level, 7 bit lookup */
795|   bl = 7;
796|   if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
797|   {
798|     if (i == 1)
799|       huft_free(tl);
800|     return i;                   /* incomplete code set */
801|   }
802| 
803|   if (tl == NULL)		/* Grrrhhh */
804|         return 2;
805| 
806|   /* read in literal and distance code lengths */
807|   n = nl + nd;
808|   m = mask_bits[bl];
809|   i = l = 0;
810|   while ((unsigned)i < n)
811|   {
812|     NEEDBITS((unsigned)bl)
813|     j = (td = tl + ((unsigned)b & m))->b;
814|     DUMPBITS(j)
815|     if (td->e == 99)
816|       {
817|         /* Invalid code.  */
818|         huft_free (tl);
819|         return 2;
820|       }
821|     j = td->v.n;
822|     if (j < 16)                 /* length of code in bits (0..15) */
823|       ll[i++] = l = j;          /* save last length in l */
824|     else if (j == 16)           /* repeat last length 3 to 6 times */
825|     {
826|       NEEDBITS(2)
827|       j = 3 + ((unsigned)b & 3);
828|       DUMPBITS(2)
829|       if ((unsigned)i + j > n)
830|         return 1;
831|       while (j--)
832|         ll[i++] = l;
833|     }
834|     else if (j == 17)           /* 3 to 10 zero length codes */
835|     {
836|       NEEDBITS(3)
837|       j = 3 + ((unsigned)b & 7);
838|       DUMPBITS(3)
839|       if ((unsigned)i + j > n)
840|         return 1;
841|       while (j--)
842|         ll[i++] = 0;
843|       l = 0;
844|     }
845|     else                        /* j == 18: 11 to 138 zero length codes */
846|     {
847|       NEEDBITS(7)
848|       j = 11 + ((unsigned)b & 0x7f);
849|       DUMPBITS(7)
850|       if ((unsigned)i + j > n)
851|         return 1;
852|       while (j--)
853|         ll[i++] = 0;
854|       l = 0;
855|     }
856|   }
857| 
858| 
859|   /* free decoding table for trees */
860|   huft_free(tl);
861| 
862| 
863|   /* restore the global bit buffer */
864|   bb = b;
865|   bk = k;
866| 
867| 
868|   /* build the decoding tables for literal/length and distance codes */
869|   bl = lbits;
870|   if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
871|   {
872|     if (i == 1) {
873|       Trace ((stderr, " incomplete literal tree
"));
874|       huft_free(tl);
875|     }
876|     return i;                   /* incomplete code set */
877|   }
878|   bd = dbits;
879|   if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
880|   {
881|     if (i == 1) {
882|       Trace ((stderr, " incomplete distance tree
"));
883| #ifdef PKZIP_BUG_WORKAROUND
884|       i = 0;
885|     }
886| #else
887|       huft_free(td);
888|     }
889|     huft_free(tl);
890|     return i;                   /* incomplete code set */
891| #endif
892|   }
893| 
894| 
895|   {
896|     /* decompress until an end-of-block code */
897|     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
898| 
899|     /* free the decoding tables */
900|     huft_free(tl);
901|     huft_free(td);
902| 
903|     return err;
904|   }
905| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:884: deref_arg: Calling "inflate_codes" dereferences freed pointer "tl".
#  882|     {
#  883|       /* decompress until an end-of-block code */
#  884|->     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
#  885|   
#  886|       /* free the decoding tables */
(Example-1) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:861: double_free: Calling "huft_free" frees pointer "tl" which has already been freed.
#  859|       if (i == 1) {
#  860|         Trace ((stderr, " incomplete literal tree
"));
#  861|->       huft_free(tl);
#  862|       }
#  863|       return i;                   /* incomplete code set */
(Example-2) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

', '2025-11-17 21:39:07.0414');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (232, 94, 'def5', 'OVERRUN', 'gzip-1.13/deflate.c:771: cond_between: Checking "prev_length >= 3U" implies that "prev_length" is between 4 and 261 (inclusive) on the true branch.
gzip-1.13/deflate.c:775: overrun-call: Overrunning callee''s array of size 256 by passing argument "prev_length - 3U" (which evaluates to 258) in call to "ct_tally".
#  773|               check_match(strstart-1, prev_match, prev_length);
#  774|   
#  775|->             flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
#  776|   
#  777|               /* Insert in hash table all strings up to the end of the match.', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/deflate.c:771: cond_between: Checking "prev_length >= 3U" implies that "prev_length" is between 4 and 261 (inclusive) on the true branch.
gzip-1.13/deflate.c:775: overrun-call: Overrunning callee''s array of size 256 by passing argument "prev_length - 3U" (which evaluates to 258) in call to "ct_tally".
#  773|               check_match(strstart-1, prev_match, prev_length);
#  774|   
#  775|->             flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
#  776|   
#  777|               /* Insert in hash table all strings up to the end of the match.', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/deflate.c:771: cond_between: Checking "prev_length >= 3U" implies that "prev_length" is between 4 and 261 (inclusive) on the true branch.
gzip-1.13/deflate.c:775: overrun-call: Overrunning callee''s array of size 256 by passing argument "prev_length - 3U" (which evaluates to 258) in call to "ct_tally".
#  773|               check_match(strstart-1, prev_match, prev_length);
#  774|   
#  775|->             flush = ct_tally(strstart-1-prev_match, prev_length - MIN_MATCH);
#  776|   
#  777|               /* Insert in hash table all strings up to the end of the match.
(Example-1) Reason Marked as False Positive:
Assuming this refers to the length_code[lc] in ct_tally function, the value of lc is checked by the asserts to be smaller than the array size

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/deflate.c:713: cond_at_least: Checking "lookahead < 262U" implies that "lookahead" is at least 262 on the false branch.
gzip-1.13/deflate.c:660: assignment: Assigning: "match_length" = "lookahead". The value of "match_length" is now at least 262.
gzip-1.13/deflate.c:665: overrun-call: Overrunning callee''s array of size 256 by passing argument "match_length - 3U" (which evaluates to 259) in call to "ct_tally".
#  663|               check_match(strstart, match_start, match_length);
#  664|   
#  665|->             flush = ct_tally(strstart-match_start, match_length - MIN_MATCH);
#  666|   
#  667|               lookahead -= match_length;
(Example-2) Reason Marked as False Positive:
Assuming this refers to the length_code[lc] in ct_tally function, the value of lc is checked by the asserts to be smaller than the array size

', '2025-11-17 21:39:07.0414');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (233, 94, 'def6', 'OVERRUN', 'gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:365: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
#  363|     /* Adjust last length count to fill out codes, if needed */
#  364|     for (y = 1 << j; j < i; j++, y <<= 1)
#  365|->     if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|     if ((y -= c[i]) < 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:365: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
#  363|     /* Adjust last length count to fill out codes, if needed */
#  364|     for (y = 1 << j; j < i; j++, y <<= 1)
#  365|->     if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|     if ((y -= c[i]) < 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:365: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
#  363|     /* Adjust last length count to fill out codes, if needed */
#  364|     for (y = 1 << j; j < i; j++, y <<= 1)
#  365|->     if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|     if ((y -= c[i]) < 0)
(Example-1) Reason Marked as False Positive:
the condition of the for cycle makes sure that j < i; i is bmax at most (line 354); c has bmax+1 elements

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:367: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  365|       if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|->   if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|     c[i] += y;
(Example-2) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

', '2025-11-17 21:39:07.041401');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (234, 94, 'def7', 'OVERRUN', 'gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:357: assignment: Assigning: "g" = "i". The value of "g" is now at least 1.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:386: overrun-local: Overrunning array "x" of 17 4-byte elements at element index 17 (byte offset 71) using index "g" (which evaluates to 17).
#  384|         v[x[j]++] = i;
#  385|     } while (++i < n);
#  386|->   n = x[g];                   /* set n to length of v */
#  387|   
#  388|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:357: assignment: Assigning: "g" = "i". The value of "g" is now at least 1.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:386: overrun-local: Overrunning array "x" of 17 4-byte elements at element index 17 (byte offset 71) using index "g" (which evaluates to 17).
#  384|         v[x[j]++] = i;
#  385|     } while (++i < n);
#  386|->   n = x[g];                   /* set n to length of v */
#  387|   
#  388|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:357: assignment: Assigning: "g" = "i". The value of "g" is now at least 1.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:386: overrun-local: Overrunning array "x" of 17 4-byte elements at element index 17 (byte offset 71) using index "g" (which evaluates to 17).
#  384|         v[x[j]++] = i;
#  385|     } while (++i < n);
#  386|->   n = x[g];                   /* set n to length of v */
#  387|   
#  388|
(Example-1) Reason Marked as False Positive:
The value of g is BMAX at most (line 354/357), the array x has BMAX+1 elements

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:369: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  367|     if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|->   c[i] += y;
#  370|   
#  371|
(Example-2) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

', '2025-11-17 21:39:07.041401');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (236, 94, 'def9', 'OVERRUN', 'gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:367: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  365|       if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|->   if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|     c[i] += y;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:367: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  365|       if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|->   if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|     c[i] += y;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:367: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  365|       if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|->   if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|     c[i] += y;
(Example-1) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:353: assignment: Assigning: "l" = "j". The value of "l" is now 17.
gzip-1.13/inflate.c:354: assignment: Assigning: "i" = "16U".
gzip-1.13/inflate.c:354: decr: Decrementing "i". The value of "i" is now 15.
gzip-1.13/inflate.c:354: cond_at_least: Checking "i" implies that "i" is at least 1 on the true branch.
gzip-1.13/inflate.c:358: cond_at_least: Checking "(unsigned int)l > i" implies that "g" and "i" are at least 17 on the false branch.
gzip-1.13/inflate.c:369: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "i" (which evaluates to 17).
#  367|     if ((y -= c[i]) < 0)
#  368|       return 2;
#  369|->   c[i] += y;
#  370|   
#  371|
(Example-2) Reason Marked as False Positive:
The value of i is BMAX at most (line 354), the array c has BMAX+1 elements

', '2025-11-17 21:39:07.041402');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (237, 94, 'def10', 'UNINIT', 'gzip-1.13/inflate.c:300: var_decl: Declaring variable "r" without initializer.
gzip-1.13/inflate.c:471: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
#  469|         f = 1 << (k - w);
#  470|         for (j = i >> w; j < z; j += f)
#  471|->         q[j] = r;
#  472|   
#  473|         /* backwards increment the k-bit code i */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:300: var_decl: Declaring variable "r" without initializer.
gzip-1.13/inflate.c:471: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
#  469|         f = 1 << (k - w);
#  470|         for (j = i >> w; j < z; j += f)
#  471|->         q[j] = r;
#  472|   
#  473|         /* backwards increment the k-bit code i */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
gzip-1.13/inflate.c:300: var_decl: Declaring variable "r" without initializer.
gzip-1.13/inflate.c:471: uninit_use: Using uninitialized value "r". Field "r.v" is uninitialized.
#  469|         f = 1 << (k - w);
#  470|         for (j = i >> w; j < z; j += f)
#  471|->         q[j] = r;
#  472|   
#  473|         /* backwards increment the k-bit code i */
(Example-1) Reason Marked as False Positive:
the values are initialized by the if-else starting on line 454

', '2025-11-17 21:39:07.041402');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (238, 94, 'def11', 'USE_AFTER_FREE', 'gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:813: assign: Assigning: "td" = "tl + ((unsigned int)b & m)".
gzip-1.13/inflate.c:860: freed_arg: "huft_free" frees "tl".
gzip-1.13/inflate.c:897: deref_arg: Calling "inflate_codes" dereferences freed pointer "td".
#  895|     {
#  896|       /* decompress until an end-of-block code */
#  897|->     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
#  898|   
#  899|       /* free the decoding tables */', 'TRUE POSITIVE', 'Use-after-free vulnerability exists as `td` (derived from `tl` at line 813) is dereferenced at line 897 after `tl` is freed at line 860, with no intervening reassignment or reallocation of `td`''s underlying memory within the provided code.', 'The reported issue is not solely about the assignment at line 813, but rather about the potential use-after-free vulnerability.

At line 860, `huft_free(tl)` is called, which frees the memory allocated for `tl` (and potentially its linked structures).

The `td` pointer is assigned a value based on `tl` at line 813: `td = tl + ((unsigned int)b & m)`. This implies `td` points to a location within the memory block of `tl`.

After `tl` is freed (line 860), the subsequent call to `inflate_codes(tl, td, bl, bd)` at line 897 attempts to use `td`, which now points to freed memory (since `td` is derived from `tl`).

This direct sequence of events (freeing `tl` and then using `td`, which is based on `tl`) within the provided code (lines 860 and 897) demonstrates a potential use-after-free vulnerability, aligning with CWE-416.

There is no explicit evidence within the provided code that `td` is reassigned or its underlying memory is reallocated between its last assignment (line 813) and its use (line 897), given the control flow shown.

Unlike the provided examples of FALSE POSITIVES (Example-1 and Example-2), where `huft_free` is followed by a rebuild of the table via `huft_build` before reuse, the code snippet here does not show such a rebuild for `tl` (and by extension, `td`) between the free and the dereference.', 'Investigate the existence of any mechanism that rebuilds or reassigns `td` to a valid memory location between the `huft_free(tl)` call and its dereference in `inflate_codes`.

Verify the memory management semantics of `huft_free` to ensure it does not implicitly preserve the validity of derived pointers like `td`.

Analyze the `inflate_codes` function to determine if it has any internal safeguards against use-after-free errors for the `td` parameter.', 0.0000, '*** Source Code Context ***

code of inflate.c file:
734| static int
735| inflate_dynamic(void)
736| {
737|   int i;                /* temporary variables */
738|   unsigned j;
739|   unsigned l;           /* last length */
740|   unsigned m;           /* mask for bit lengths table */
741|   unsigned n;           /* number of lengths to get */
742|   unsigned w;           /* current window position */
743|   struct huft *tl;      /* literal/length code table */
744|   struct huft *td;      /* distance code table */
745|   int bl;               /* lookup bits for tl */
746|   int bd;               /* lookup bits for td */
747|   unsigned nb;          /* number of bit length codes */
748|   unsigned nl;          /* number of literal/length codes */
749|   unsigned nd;          /* number of distance codes */
750| #ifdef PKZIP_BUG_WORKAROUND
751|   unsigned ll[288+32];  /* literal/length and distance code lengths */
752| #else
753|   unsigned ll[286+30];  /* literal/length and distance code lengths */
754| #endif
755|   register ulg b;       /* bit buffer */
756|   register unsigned k;  /* number of bits in bit buffer */
757| 
758| 
759|   /* make local bit buffer */
760|   b = bb;
761|   k = bk;
762|   w = wp;
763| 
764| 
765|   /* read in table lengths */
766|   NEEDBITS(5)
767|   nl = 257 + ((unsigned)b & 0x1f);      /* number of literal/length codes */
768|   DUMPBITS(5)
769|   NEEDBITS(5)
770|   nd = 1 + ((unsigned)b & 0x1f);        /* number of distance codes */
771|   DUMPBITS(5)
772|   NEEDBITS(4)
773|   nb = 4 + ((unsigned)b & 0xf);         /* number of bit length codes */
774|   DUMPBITS(4)
775| #ifdef PKZIP_BUG_WORKAROUND
776|   if (nl > 288 || nd > 32)
777| #else
778|   if (nl > 286 || nd > 30)
779| #endif
780|     return 1;                   /* bad lengths */
781| 
782| 
783|   /* read in bit-length-code lengths */
784|   for (j = 0; j < nb; j++)
785|   {
786|     NEEDBITS(3)
787|     ll[border[j]] = (unsigned)b & 7;
788|     DUMPBITS(3)
789|   }
790|   for (; j < 19; j++)
791|     ll[border[j]] = 0;
792| 
793| 
794|   /* build decoding table for trees--single level, 7 bit lookup */
795|   bl = 7;
796|   if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)
797|   {
798|     if (i == 1)
799|       huft_free(tl);
800|     return i;                   /* incomplete code set */
801|   }
802| 
803|   if (tl == NULL)		/* Grrrhhh */
804|         return 2;
805| 
806|   /* read in literal and distance code lengths */
807|   n = nl + nd;
808|   m = mask_bits[bl];
809|   i = l = 0;
810|   while ((unsigned)i < n)
811|   {
812|     NEEDBITS((unsigned)bl)
813|     j = (td = tl + ((unsigned)b & m))->b;
814|     DUMPBITS(j)
815|     if (td->e == 99)
816|       {
817|         /* Invalid code.  */
818|         huft_free (tl);
819|         return 2;
820|       }
821|     j = td->v.n;
822|     if (j < 16)                 /* length of code in bits (0..15) */
823|       ll[i++] = l = j;          /* save last length in l */
824|     else if (j == 16)           /* repeat last length 3 to 6 times */
825|     {
826|       NEEDBITS(2)
827|       j = 3 + ((unsigned)b & 3);
828|       DUMPBITS(2)
829|       if ((unsigned)i + j > n)
830|         return 1;
831|       while (j--)
832|         ll[i++] = l;
833|     }
834|     else if (j == 17)           /* 3 to 10 zero length codes */
835|     {
836|       NEEDBITS(3)
837|       j = 3 + ((unsigned)b & 7);
838|       DUMPBITS(3)
839|       if ((unsigned)i + j > n)
840|         return 1;
841|       while (j--)
842|         ll[i++] = 0;
843|       l = 0;
844|     }
845|     else                        /* j == 18: 11 to 138 zero length codes */
846|     {
847|       NEEDBITS(7)
848|       j = 11 + ((unsigned)b & 0x7f);
849|       DUMPBITS(7)
850|       if ((unsigned)i + j > n)
851|         return 1;
852|       while (j--)
853|         ll[i++] = 0;
854|       l = 0;
855|     }
856|   }
857| 
858| 
859|   /* free decoding table for trees */
860|   huft_free(tl);
861| 
862| 
863|   /* restore the global bit buffer */
864|   bb = b;
865|   bk = k;
866| 
867| 
868|   /* build the decoding tables for literal/length and distance codes */
869|   bl = lbits;
870|   if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)
871|   {
872|     if (i == 1) {
873|       Trace ((stderr, " incomplete literal tree
"));
874|       huft_free(tl);
875|     }
876|     return i;                   /* incomplete code set */
877|   }
878|   bd = dbits;
879|   if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)
880|   {
881|     if (i == 1) {
882|       Trace ((stderr, " incomplete distance tree
"));
883| #ifdef PKZIP_BUG_WORKAROUND
884|       i = 0;
885|     }
886| #else
887|       huft_free(td);
888|     }
889|     huft_free(tl);
890|     return i;                   /* incomplete code set */
891| #endif
892|   }
893| 
894| 
895|   {
896|     /* decompress until an end-of-block code */
897|     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
898| 
899|     /* free the decoding tables */
900|     huft_free(tl);
901|     huft_free(td);
902| 
903|     return err;
904|   }
905| }

code of /shared-data/source/gzip-1.13/inflate.c file:
497| static int
498| huft_free(struct huft *t)
499| {
500|   register struct huft *p, *q;
501| 
502| 
503|   /* Go through linked list, freeing from the malloced (t[-1]) address. */
504|   p = t;
505|   while (p != (struct huft *)NULL)
506|   {
507|     q = (--p)->v.t;
508|     free(p);
509|     p = q;
510|   }
511|   return 0;
512| }


519| static int
520| inflate_codes(struct huft *tl, struct huft *td, int bl, int bd)
521| {
522|   register unsigned e;  /* table entry flag/number of extra bits */
523|   unsigned n, d;        /* length and index for copy */
524|   unsigned w;           /* current window position */
525|   struct huft *t;       /* pointer to table entry */
526|   unsigned ml, md;      /* masks for bl and bd bits */
527|   register ulg b;       /* bit buffer */
528|   register unsigned k;  /* number of bits in bit buffer */
529| 
530| 
531|   /* make local copies of globals */
532|   b = bb;                       /* initialize bit buffer */
533|   k = bk;
534|   w = wp;                       /* initialize window position */
535| 
536|   /* inflate the coded data */
537|   ml = mask_bits[bl];           /* precompute masks for speed */
538|   md = mask_bits[bd];
539|   for (;;)                      /* do until end of block */
540|   {
541|     NEEDBITS((unsigned)bl)
542|     if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)
543|       do {
544|         if (e == 99)
545|           return 1;
546|         DUMPBITS(t->b)
547|         e -= 16;
548|         NEEDBITS(e)
549|       } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
550|     DUMPBITS(t->b)
551|     if (e == 16)                /* then it''s a literal */
552|     {
553|       slide[w++] = (uch)t->v.n;
554|       Tracevv((stderr, "%c", slide[w-1]));
555|       if (w == WSIZE)
556|       {
557|         flush_output(w);
558|         w = 0;
559|       }
560|     }
561|     else                        /* it''s an EOB or a length */
562|     {
563|       /* exit if end of block */
564|       if (e == 15)
565|         break;
566| 
567|       /* get length of block to copy */
568|       NEEDBITS(e)
569|       n = t->v.n + ((unsigned)b & mask_bits[e]);
570|       DUMPBITS(e);
571| 
572|       /* decode distance of block to copy */
573|       NEEDBITS((unsigned)bd)
574|       if ((e = (t = td + ((unsigned)b & md))->e) > 16)
575|         do {
576|           if (e == 99)
577|             return 1;
578|           DUMPBITS(t->b)
579|           e -= 16;
580|           NEEDBITS(e)
581|         } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);
582|       DUMPBITS(t->b)
583|       NEEDBITS(e)
584|       d = w - t->v.n - ((unsigned)b & mask_bits[e]);
585|       DUMPBITS(e)
586|       if (fresh && w <= d)
587|         return 1;
588|       Tracevv ((stderr, "\\[%u,%u]", w - d, n));
589| 
590|       /* do the copy */
591|       do {
592|         n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);
593| #ifndef DEBUG
594|         if (e <= (d < w ? w - d : d - w))
595|         {
596|           memcpy(slide + w, slide + d, e);
597|           w += e;
598|           d += e;
599|         }
600|         else                      /* do it slow to avoid memcpy() overlap */
601| #endif
602|           do {
603|             slide[w++] = slide[d++];
604|             Tracevv((stderr, "%c", slide[w-1]));
605|           } while (--e);
606|         if (w == WSIZE)
607|         {
608|           flush_output(w);
609|           w = 0;
610|         }
611|       } while (n);
612|     }
613|   }
614| 
615| 
616|   /* restore the globals from the locals */
617|   wp = w;                       /* restore global window pointer */
618|   bb = b;                       /* restore global bit buffer */
619|   bk = k;
620| 
621|   /* done */
622|   return 0;
623| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:884: deref_arg: Calling "inflate_codes" dereferences freed pointer "tl".
#  882|     {
#  883|       /* decompress until an end-of-block code */
#  884|->     int err = inflate_codes(tl, td, bl, bd) ? 1 : 0;
#  885|   
#  886|       /* free the decoding tables */
(Example-1) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
gzip-1.10/inflate.c:847: freed_arg: "huft_free" frees "tl".
gzip-1.10/inflate.c:861: double_free: Calling "huft_free" frees pointer "tl" which has already been freed.
#  859|       if (i == 1) {
#  860|         Trace ((stderr, " incomplete literal tree
"));
#  861|->       huft_free(tl);
#  862|       }
#  863|       return i;                   /* incomplete code set */
(Example-2) Reason Marked as False Positive:
The second huft_free is called after the tl has been rebuild by the huft_build function

', '2025-11-17 21:39:07.041402');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (239, 94, 'def12', 'OVERRUN', 'gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:351: assignment: Assigning: "k" = "j". The value of "k" is now 17.
gzip-1.13/inflate.c:401: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "k" (which evaluates to 17).
#  399|     for (; k <= g; k++)
#  400|     {
#  401|->     a = c[k];
#  402|       while (a--)
#  403|       {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:351: assignment: Assigning: "k" = "j". The value of "k" is now 17.
gzip-1.13/inflate.c:401: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "k" (which evaluates to 17).
#  399|     for (; k <= g; k++)
#  400|     {
#  401|->     a = c[k];
#  402|       while (a--)
#  403|       {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:351: assignment: Assigning: "k" = "j". The value of "k" is now 17.
gzip-1.13/inflate.c:401: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "k" (which evaluates to 17).
#  399|     for (; k <= g; k++)
#  400|     {
#  401|->     a = c[k];
#  402|       while (a--)
#  403|       {
(Example-1) Reason Marked as False Positive:
g is BMAX at most (lines 354+357), based on for-loop condition (399), k is also BMAX at most, the size of c is BMAX+1

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
gzip-1.13/inflate.c:348: cond_const: Checking "j <= 16U" implies that "j" is 17 on the false branch.
gzip-1.13/inflate.c:365: overrun-local: Overrunning array "c" of 17 4-byte elements at element index 17 (byte offset 71) using index "j" (which evaluates to 17).
#  363|     /* Adjust last length count to fill out codes, if needed */
#  364|     for (y = 1 << j; j < i; j++, y <<= 1)
#  365|->     if ((y -= c[j]) < 0)
#  366|         return 2;                 /* bad input: more codes than bits */
#  367|     if ((y -= c[i]) < 0)
(Example-2) Reason Marked as False Positive:
the condition of the for cycle makes sure that j < i; i is bmax at most (line 354); c has bmax+1 elements

', '2025-11-17 21:39:07.041403');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (240, 112, 'def1', 'USE_AFTER_FREE', 'texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: pass_freed_arg: Passing freed pointer "error" as an argument to "show_error_node".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: pass_freed_arg: Passing freed pointer "error" as an argument to "show_error_node".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: pass_freed_arg: Passing freed pointer "error" as an argument to "show_error_node".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|
(Example-1) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: deref_arg: Calling "show_error_node" dereferences freed pointer "error".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|
(Example-2) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

', '2025-11-17 21:39:07.05007');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (398, 102, 'def1', 'OVERRUN', 'glibc-2.39/libio/iofdopen.c:157: overrun-local: Overrunning array of 27 8-byte elements at element index 27 (byte offset 223) by dereferencing pointer "(struct _IO_jump_t const **)((char *)&new_f->fp.file + 216UL)".
#  155|                     == (_IO_IS_APPENDING | _IO_NO_READS)))
#  156|       {
#  157|->       off64_t new_pos = _IO_SYSSEEK (&new_f->fp.file, 0, _IO_seek_end);
#  158|         if (new_pos == _IO_pos_BAD && errno != ESPIPE)
#  159|           return NULL;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/libio/iofdopen.c:157: overrun-local: Overrunning array of 27 8-byte elements at element index 27 (byte offset 223) by dereferencing pointer "(struct _IO_jump_t const **)((char *)&new_f->fp.file + 216UL)".
#  155|                     == (_IO_IS_APPENDING | _IO_NO_READS)))
#  156|       {
#  157|->       off64_t new_pos = _IO_SYSSEEK (&new_f->fp.file, 0, _IO_seek_end);
#  158|         if (new_pos == _IO_pos_BAD && errno != ESPIPE)
#  159|           return NULL;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/libio/iofdopen.c:157: overrun-local: Overrunning array of 27 8-byte elements at element index 27 (byte offset 223) by dereferencing pointer "(struct _IO_jump_t const **)((char *)&new_f->fp.file + 216UL)".
#  155|                     == (_IO_IS_APPENDING | _IO_NO_READS)))
#  156|       {
#  157|->       off64_t new_pos = _IO_SYSSEEK (&new_f->fp.file, 0, _IO_seek_end);
#  158|         if (new_pos == _IO_pos_BAD && errno != ESPIPE)
#  159|           return NULL;
(Example-1) Reason Marked as False Positive:
Checker is confusing the public definition of FILE with glibc''s internal (and larger) _IO_FILE_plus, which has an extra field in it.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118798');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (241, 112, 'def2', 'INTEGER_OVERFLOW', 'texinfo-7.1/info/makedoc.c:299: tainted_data_argument: The check "offset < file_size - decl_len" contains the tainted expression "file_size - decl_len" which causes "offset" to be considered tainted.
texinfo-7.1/info/makedoc.c:309: overflow: The expression "offset += decl_len" is deemed overflowed because at least one of its arguments has overflowed.
texinfo-7.1/info/makedoc.c:310: assign: Assigning: "point" = "offset".
texinfo-7.1/info/makedoc.c:347: assign: Assigning: "offset" = "point".
texinfo-7.1/info/makedoc.c:356: overflow: The expression "offset - line_start" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:356: overflow: The expression "1L + (offset - line_start)" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:356: overflow_sink: "1L + (offset - line_start)", which might have underflowed, is passed to "xmalloc(1L + (offset - line_start))". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  354|           char *tag_name;
#  355|   
#  356|->         tag_name = xmalloc (1 + (offset - line_start));
#  357|           strncpy (tag_name, buffer + line_start, offset - line_start);
#  358|           tag_name[offset - line_start] = ''\0'';', 'TRUE POSITIVE', 'Potential overflows at lines 309 and 356, coupled with underflow risk at line 356, are directly propagated to a vulnerable memory allocation via `xmalloc` (line 356), with no explicit bounds checking to prevent such issues, supporting a TRUE POSITIVE finding.', '1. **Tainted Data Argument**: At line 299, `offset` is indeed influenced by `file_size - decl_len`, which could be considered tainted if `file_size` or `decl_len` is untrusted. However, the primary concern here is the subsequent arithmetic operations (e.g., lines 309, 356) rather than the taint itself.

2. **Overflow at Line 309**: The expression `offset += decl_len` is flagged for potential overflow. Given that `offset` is a `long` (line 264) and `decl_len` is an `int` (line 261), the sum could theoretically exceed `LONG_MAX`, causing an overflow. This is a legitimate concern if `decl_len` can be sufficiently large.

3. **Assignment and Propagation**: The value of `offset` (potentially overflowed) is assigned to `point` (line 310) and later reassigned back to `offset` (line 347). This ensures that any overflow condition is propagated through the code, maintaining the vulnerability potential.

4. **Underflow and Overflow at Line 356**: The expressions `offset - line_start` and `1L + (offset - line_start)` are flagged for underflow and overflow, respectively. Since `offset` and `line_start` are both `long`, the subtraction could indeed underflow if `line_start` is larger than `offset`. The subsequent addition of `1L` could then overflow if the result of the subtraction is `LONG_MIN`. This sequence of operations is vulnerable to both underflow and overflow, depending on the input values.

5. **Vulnerable Memory Allocation**: The potentially underflowed/overflowed result (`1L + (offset - line_start)`) is directly passed to `xmalloc` (line 356). This means if an underflow or overflow occurs, it could lead to an allocation of an unexpectedly small or large amount of memory, potentially causing a crash, data corruption, or even a security vulnerability if exploited correctly.

6. **Lack of Explicit Bounds Checking**: Within the provided code snippet, there is no explicit check to prevent `offset`, `line_start`, or their manipulations from reaching values that would cause underflow or overflow in the context of the described operations. The absence of such checks, combined with the potential for tainted data influence, supports the conclusion that this is not a false positive.', 'Provide explicit constraints or expected value ranges for `file_size`, `decl_len`, `offset`, and `line_start` to assess the feasibility of overflow and underflow conditions.

Investigate the source of `file_size` and `decl_len` to determine if they can indeed be considered untrusted or sufficiently large to cause overflows.

Evaluate the implementation of the overridden `xmalloc` builtin model to ensure it does not mitigate or introduce vulnerabilities related to the passed (potentially underflowed/overflowed) size parameter.', 0.0000, '*** Source Code Context ***

code of info/makedoc.c file:
258| static void
259| process_one_file (char *filename, FILE *doc_stream, FILE *funs_stream)
260| {
261|   int descriptor, decl_len;
262|   char *buffer, *decl_str;
263|   struct stat finfo;
264|   long offset;
265|   long file_size;
266|   EMACS_TAG_BLOCK *block;
267| 
268|   if (stat (filename, &finfo) == -1)
269|     fatal_file_error (filename);
270| 
271|   descriptor = open (filename, O_RDONLY, 0666);
272| 
273|   if (descriptor == -1)
274|     fatal_file_error (filename);
275| 
276|   file_size = (long) finfo.st_size;
277|   buffer = xmalloc (1 + file_size);
278|   /* On some systems, the buffer will actually contain
279|      less characters than the full file''s size, because
280|      the CR characters are removed from line endings.  */
281|   file_size = read (descriptor, buffer, file_size);
282|   close (descriptor);
283| 
284|   offset = 0;
285|   decl_str = DECLARATION_STRING;
286|   decl_len = strlen (decl_str);
287| 
288|   block = make_emacs_tag_block (filename);
289| 
290|   while (1)
291|     {
292|       long point = 0;
293|       long line_start = 0;
294|       int line_number = 0;
295| 
296|       char *func, *doc;
297|       char *func_name;
298| 
299|       for (; offset < (file_size - decl_len); offset++)
300|         {
301|           if (buffer[offset] == ''
'')
302|             {
303|               line_number++;
304|               line_start = offset + 1;
305|             }
306| 
307|           if (strncmp (buffer + offset, decl_str, decl_len) == 0)
308|             {
309|               offset += decl_len;
310|               point = offset;
311|               break;
312|             }
313|         }
314| 
315|       if (!point)
316|         break;
317| 
318|       /* Skip forward until we find the open paren. */
319|       while (point < file_size)
320|         {
321|           if (buffer[point] == ''
'')
322|             {
323|               line_number++;
324|               line_start = point + 1;
325|             }
326|           else if (buffer[point] == ''('')
327|             break;
328| 
329|           point++;
330|         }
331| 
332|       while (point++ < file_size)
333|         {
334|           if (!whitespace_or_newline (buffer[point]))
335|             break;
336|           else if (buffer[point] == ''
'')
337|             {
338|               line_number++;
339|               line_start = point + 1;
340|             }
341|         }
342| 
343|       if (point >= file_size)
344|         break;
345| 
346|       /* Now looking at name of function.  Get it. */
347|       for (offset = point; buffer[offset] != '',''; offset++);
348|       func = xmalloc (1 + (offset - point));
349|       strncpy (func, buffer + point, offset - point);
350|       func[offset - point] = ''\0'';
351| 
352|       /* Remember this tag in the current block. */
353|       {
354|         char *tag_name;
355| 
356|         tag_name = xmalloc (1 + (offset - line_start));
357|         strncpy (tag_name, buffer + line_start, offset - line_start);
358|         tag_name[offset - line_start] = ''\0'';
359|         add_tag_to_block (block, tag_name, line_number, point);
360|       }
361| 
362|       /* Generate the user-visible function name from the function''s name. */
363|       {
364|         register int i;
365|         char *name_start;
366| 
367|         name_start = func;
368| 
369|         if (strncmp (name_start, "info_", 5) == 0)
370|           name_start += 5;
371| 
372|         func_name = xstrdup (name_start);
373| 
374|         /* Fix up "ea" commands. */
375|         if (strncmp (func_name, "ea_", 3) == 0)
376|           {
377|             char *temp_func_name;
378| 
379|             temp_func_name = xmalloc (10 + strlen (func_name));
380|             strcpy (temp_func_name, "echo_area_");
381|             strcat (temp_func_name, func_name + 3);
382|             free (func_name);
383|             func_name = temp_func_name;
384|           }
385| 
386|         for (i = 0; func_name[i]; i++)
387|           if (func_name[i] == ''_'')
388|             func_name[i] = ''-'';
389|       }
390| 
391|       /* Find doc string. */
392|       point = offset + 1;
393| 
394|       while (point < file_size)
395|         {
396|           if (buffer[point] == ''
'')
397|             {
398|               line_number++;
399|               line_start = point + 1;
400|             }
401| 
402|           if (buffer[point] == ''"'')
403|             break;
404|           else
405|             point++;
406|         }
407| 
408|       offset = point + 1;
409| 
410|       while (offset < file_size)
411|         {
412|           if (buffer[offset] == ''
'')
413|             {
414|               line_number++;
415|               line_start = offset + 1;
416|             }
417| 
418|           if (buffer[offset] == ''\\'')
419|             offset += 2;
420|           else if (buffer[offset] == ''"'')
421|             break;
422|           else
423|             offset++;
424|         }
425| 
426|       offset++;
427|       if (offset >= file_size)
428|         {
429|           free (func_name);
430|           free (func);
431|           break;
432|         }
433| 
434|       doc = xmalloc (1 + (offset - point));
435|       strncpy (doc, buffer + point, offset - point);
436|       doc[offset - point] = ''\0'';
437| 
438|       fprintf (doc_stream,
439|           "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },
",
440|           func, func_name, doc);
441| 
442|       free (func_name);
443| 
444|       fprintf (funs_stream, "#define A_%s %u
", func, next_func_key());
445|       fprintf (funs_stream,
446|           "extern void %s (WINDOW *window, int count);
",
447|           func);
448|       free (func);
449|       free (doc);
450|     }
451|   free (buffer);
452| 
453|   /* If we created any tags, remember this file on our global list.  Otherwise,
454|      free the memory already allocated to it. */
455|   if (block->entries)
456|     add_pointer_to_array (block, emacs_tags_index, emacs_tags,
457|                           emacs_tags_slots, 10);
458|   else
459|     {
460|       free (block->filename);
461|       free (block);
462|     }
463| }


*** Examples ***
', '2025-11-17 21:39:07.050071');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (242, 112, 'def3', 'RESOURCE_LEAK', 'texinfo-7.1/info/filesys.c:155: alloc_fn: Storage is returned from allocation function "tilde_expand_word".
texinfo-7.1/info/filesys.c:155: var_assign: Assigning: "expanded_dirname" = storage returned from "tilde_expand_word(dirname)".
texinfo-7.1/info/filesys.c:156: var_assign: Assigning: "dirname" = "expanded_dirname".
texinfo-7.1/info/filesys.c:157: leaked_storage: Variable "expanded_dirname" going out of scope leaks the storage it points to.
texinfo-7.1/info/filesys.c:159: noescape: Resource "dirname" is not freed or pointed-to in "info_add_extension".
texinfo-7.1/info/filesys.c:169: leaked_storage: Variable "dirname" going out of scope leaks the storage it points to.
#  167|                 xasprintf (&s, "%s%s", "./", with_extension);
#  168|                 free (with_extension);
#  169|->               return s;
#  170|               }
#  171|             else', 'TRUE POSITIVE', 'Allocated storage for `expanded_dirname` (line 155) is reassigned to `dirname` (line 156) without explicit `free` or reuse before going out of scope (lines 157, 169), indicating a potential memory leak (CWE-772), as no deallocation is observed within the analyzed code paths.', 'The `tilde_expand_word` function allocates storage for `expanded_dirname` (line 155), which is then assigned to `dirname` (line 156).

There is no explicit `free` or reuse of the storage pointed to by `expanded_dirname` before it goes out of scope (line 157), indicating a potential memory leak.

The `dirname` variable, now pointing to the same allocated storage, is passed to `info_add_extension` (line 159) but there''s no evidence within the provided code that this function frees or retains the pointer, suggesting another potential leak.

Upon returning from the function (line 169), `dirname` (and thus the original allocated storage) goes out of scope without being freed, reinforcing the likelihood of a memory leak.

The only `free` operation observed in the provided code snippet is for `with_extension` (line 168), which is unrelated to the allocated storage for `expanded_dirname`/`dirname`.

Given the explicit allocation and lack of corresponding deallocation for `expanded_dirname`/`dirname` within the analyzed code paths, a memory leak (CWE-772) is plausible, aligning with the CVE''s description.', NULL, 0.0000, '*** Source Code Context ***

code of info/filesys.c file:
127| char *
128| info_file_find_next_in_path (char *filename, int *path_index, struct stat *finfo)
129| {
130|   struct stat dummy;
131| 
132|   /* Used for output of stat in case the caller doesn''t care about
133|      its value. */
134|   if (!finfo)
135|     finfo = &dummy;
136| 
137|   /* Reject ridiculous cases up front, to prevent infinite recursion
138|      later on.  E.g., someone might say "info ''(.)foo''"...  */
139|   if (!*filename || STREQ (filename, ".") || STREQ (filename, ".."))
140|     return NULL;
141| 
142|   while (1)
143|     {
144|       char *dirname, *with_extension = 0;
145| 
146|       dirname = infopath_next (path_index);
147|       if (!dirname)
148|         break;
149| 
150|       debug(1, (_("looking for file %s in %s"), filename, dirname));
151| 
152|       /* Expand a leading tilde if one is present. */
153|       if (*dirname == ''~'')
154|         {
155|           char *expanded_dirname = tilde_expand_word (dirname);
156|           dirname = expanded_dirname;
157|         }
158| 
159|       with_extension = info_add_extension (dirname, filename, finfo);
160| 
161|       if (with_extension)
162|         {
163|           if (!IS_ABSOLUTE (with_extension))
164|             {
165|               /* Prefix "./" to it. */
166|               char *s;
167|               xasprintf (&s, "%s%s", "./", with_extension);
168|               free (with_extension);
169|               return s;
170|             }
171|           else
172|             return with_extension;
173|         }
174|     }
175|   return NULL;
176| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050072');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (243, 112, 'def4', 'USE_AFTER_FREE', 'texinfo-7.1/info/session.c:1967: freed_arg: "window_delete_window" frees "window".
texinfo-7.1/info/session.c:1970: pass_freed_arg: Passing freed pointer "window" as an argument to "echo_area_inform_of_deleted_window".
# 1968|   
# 1969|         if (echo_area_is_active)
# 1970|->         echo_area_inform_of_deleted_window (window);
# 1971|       }
# 1972|   }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c:1967: freed_arg: "window_delete_window" frees "window".
texinfo-7.1/info/session.c:1970: pass_freed_arg: Passing freed pointer "window" as an argument to "echo_area_inform_of_deleted_window".
# 1968|   
# 1969|         if (echo_area_is_active)
# 1970|->         echo_area_inform_of_deleted_window (window);
# 1971|       }
# 1972|   }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:1967: freed_arg: "window_delete_window" frees "window".
texinfo-7.1/info/session.c:1970: pass_freed_arg: Passing freed pointer "window" as an argument to "echo_area_inform_of_deleted_window".
# 1968|   
# 1969|         if (echo_area_is_active)
# 1970|->         echo_area_inform_of_deleted_window (window);
# 1971|       }
# 1972|   }
(Example-1) Reason Marked as False Positive:
This is intentional. "window" is free''d, but not NULLed and echo_area_inform_of_deleted_window() just works with memory address, not the content.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: deref_arg: Calling "show_error_node" dereferences freed pointer "error".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|
(Example-2) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

', '2025-11-17 21:39:07.050072');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (244, 112, 'def5', 'OVERRUN', 'texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''_x0000_'';
# 1613|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|
(Example-1) Reason Marked as False Positive:
There''s more than sufficient memory as the "description" stores just a substring of entry (entry is in format "NAME. DESCRIPTION")

', '2025-11-17 21:39:07.050073');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (245, 112, 'def6', 'OVERRUN', 'texinfo-7.1/info/session.c:2348: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 2346|             if (defentry)
# 2347|               {
# 2348|->               prompt = xmalloc (strlen (defentry->label)
# 2349|                                   + strlen (_("Follow xref (%s): ")));
# 2350|                 sprintf (prompt, _("Follow xref (%s): "), defentry->label);', 'TRUE POSITIVE', 'Unchanged default value indicates a failure in value replacement, confirming the issue''s validity.', 'This is a default value, if it''s not replaced, something went wrong', 'Perform a thorough review of memory allocation for `prompt` in `session.c`, focusing on the concatenated string lengths and the terminating null character.

Analyze the usage of `prompt` after allocation to determine if its allocated size is sufficient for all intended operations (e.g., `sprintf` at line 2350).

Compare the memory allocation pattern in the reported CVE with the known false positive example (Example-1) to identify any distinguishing factors that might influence the determination.', 0.0000, '*** Source Code Context ***

code of info/session.c file:
2258| static void
2259| info_menu_or_ref_item (WINDOW *window, int menu_item, int xref, int ask_p)
2260| {
2261|   REFERENCE *defentry = NULL; /* Default link */
2262|   REFERENCE **refs = window->node->references;
2263|   REFERENCE *entry;
2264| 
2265|   /* Name of destination */
2266|   char *line;
2267| 
2268|   int line_no;
2269|   int this_line, next_line;
2270| 
2271|   int which, closest = -1;
2272| 
2273|   reference_bool_fn exclude; 
2274| 
2275|   if (!refs)
2276|     return;
2277| 
2278|   if (menu_item && !xref)
2279|     {
2280|       exclude = &exclude_cross_references;
2281|     }
2282|   else if (!menu_item && xref)
2283|     {
2284|       exclude = &exclude_menu_items;
2285|     }
2286|   else if (menu_item && xref)
2287|     {
2288|       exclude = &exclude_nothing;
2289|     }
2290|   else /* !menu_item && !xref */
2291|     return;
2292| 
2293|   line_no = window_line_of_point (window);
2294|   this_line = window->line_starts[line_no];
2295|   if (window->line_starts[line_no + 1])
2296|     next_line = window->line_starts[line_no + 1];
2297|   else
2298|     next_line = window->node->nodelen;
2299| 
2300|   /* Look for a reference in the current line, preferring one that
2301|      the point is in, otherwise preferring after the point. */
2302|   for (which = 0; refs[which]; which++)
2303|     {
2304|       /* If we got to the next line without finding an eligible reference. */
2305|       if (refs[which]->start >= next_line)
2306|         break;
2307| 
2308|       /* Check the type of reference is one we are looking for. */
2309|       if (!(  (menu_item && refs[which]->type == REFERENCE_MENU_ITEM)
2310|            || (xref      && refs[which]->type == REFERENCE_XREF)))
2311|         continue;
2312| 
2313|       /* Reference is eligible if any part of it is in the line. */
2314|       if (refs[which]->start >= this_line && refs[which]->start < next_line
2315|           || refs[which]->start < this_line && refs[which]->end > this_line)
2316|         {
2317|           closest = which;
2318| 
2319|           /* Use the first reference that either contains the point
2320|              or is after the point. */
2321|           if (refs[which]->end > window->point)
2322|             break;
2323|         }
2324|     }
2325|   if (closest != -1)
2326|     defentry = refs[closest];
2327| 
2328|   if (ask_p)
2329|     {
2330|       char *prompt;
2331| 
2332|       /* Build the prompt string. */
2333|       if (menu_item && !xref)
2334|         {
2335|           if (defentry)
2336|             {
2337|               prompt = xmalloc (strlen (defentry->label)
2338|                                 + strlen (_("Menu item (%s): ")));
2339|               sprintf (prompt, _("Menu item (%s): "), defentry->label);
2340|             }
2341|           else
2342|             prompt = xstrdup (_("Menu item: "));
2343|         }
2344|       else
2345|         {
2346|           if (defentry)
2347|             {
2348|               prompt = xmalloc (strlen (defentry->label)
2349|                                 + strlen (_("Follow xref (%s): ")));
2350|               sprintf (prompt, _("Follow xref (%s): "), defentry->label);
2351|             }
2352|           else
2353|             prompt = xstrdup (_("Follow xref: "));
2354|         }
2355| 
2356|       line = info_read_completing_in_echo_area_with_exclusions (prompt, refs,
2357|                                                                 exclude);
2358|       free (prompt);
2359| 
2360|       window = active_window;
2361| 
2362|       /* User aborts, just quit. */
2363|       if (!line)
2364|         {
2365|           info_abort_key (window, 0);
2366|           return;
2367|         }
2368| 
2369|       /* If we had a default and the user accepted it, use that. */
2370|       if (!*line)
2371|         {
2372|           free (line);
2373|           if (defentry)
2374|             line = xstrdup (defentry->label);
2375|           else
2376|             line = NULL;
2377|         }
2378|     }
2379|   else
2380|     {
2381|       /* Not going to ask any questions.  If we have a default entry, use
2382|          that, otherwise return. */
2383|       if (!defentry)
2384|         return;
2385|       else
2386|         line = xstrdup (defentry->label);
2387|     }
2388| 
2389|   if (line)
2390|     {
2391|       /* It is possible that the references have more than a single
2392|          entry with the same label, and also LINE is down-cased, which
2393|          complicates matters even more.  Try to be as accurate as we
2394|          can: if they''ve chosen the default, use defentry directly. */
2395|       if (defentry && strcmp (line, defentry->label) == 0)
2396|         entry = defentry;
2397|       else
2398|         /* Find the selected label in the references.  If there are
2399|            more than one label which matches, find the one that''s
2400|            closest to point.  */
2401|         {
2402|           register int i;
2403|           int best = -1, min_dist = window->node->nodelen;
2404|           REFERENCE *ref;
2405| 
2406|           for (i = 0; refs && (ref = refs[i]); i++)
2407|             {
2408|               /* Need to use mbscasecmp because LINE is downcased
2409|                  inside info_read_completing_in_echo_area.  */
2410|               if (mbscasecmp (line, ref->label) == 0)
2411|                 {
2412|                   /* ref->end is more accurate estimate of position
2413|                      for menus than ref->start.  Go figure.  */
2414|                   int dist = abs (window->point - ref->end);
2415| 
2416|                   if (dist < min_dist)
2417|                     {
2418|                       min_dist = dist;
2419|                       best = i;
2420|                     }
2421|                 }
2422|             }
2423|           if (best != -1)
2424|             entry = refs[best];
2425|           else
2426|             entry = NULL;
2427|         }
2428| 
2429|       if (!entry && defentry)
2430|         info_error (_("The reference disappeared! (%s)"), line);
2431|       else
2432|         {
2433|           info_select_reference (window, entry);
2434|         }
2435| 
2436|       free (line);
2437|     }
2438| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|
(Example-1) Reason Marked as False Positive:
There''s more than sufficient memory as the "description" stores just a substring of entry (entry is in format "NAME. DESCRIPTION")

', '2025-11-17 21:39:07.050073');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (246, 112, 'def7', 'RESOURCE_LEAK', 'texinfo-7.1/install-info/install-info.c:880: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
texinfo-7.1/install-info/install-info.c:880: var_assign: Assigning: "data" = storage returned from "xmalloc(data_size + 1)".
texinfo-7.1/install-info/install-info.c:888: leaked_storage: Variable "data" going out of scope leaks the storage it points to.
#  886|   
#  887|     if (!f)
#  888|->     return 0;
#  889|   
#  890|     for (;;)', 'TRUE POSITIVE', 'Memory allocated for ''data'' at line 880 via ''xmalloc'' is not deallocated before going out of scope at line 888 when ''if (!f)'' condition is true, confirming a memory leak, with no explicit mitigation in the provided code snippet.', 'The CVE report indicates a potential memory leak at line 888, where the variable ''data'' (allocated at line 880 using ''xmalloc'') goes out of scope without being freed.

At line 887, the conditional ''if (!f)'' is evaluated. If true, the function immediately returns 0 at line 888, without deallocating the memory allocated for ''data'' at line 880.

There is no explicit deallocation (e.g., ''free'') of the ''data'' pointer in the provided code snippet before the return at line 888, confirming the memory leak concern.

Although the code has a loop starting at line 890, the return at line 888 bypasses this loop, ensuring that any potential deallocation within the loop (not explicitly shown in the provided snippet) does not mitigate the leak in this execution path.

The uncertainty regarding the implementation of ''xmalloc'' (noted as overridden by a builtin model) does not negate the explicit leak identified at line 888; the allocation and leak are based on standard memory management principles applicable to ''xmalloc'' as described.

No evidence within the provided code snippet proves that all execution paths safely deallocate the memory assigned to ''data'', fulfilling the criteria for a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
872| char *
873| readfile (char *filename, int *sizep,
874|     void (*create_callback) (char *), char **opened_filename,
875|     char **compression_program)
876| {
877|   FILE *f;
878|   int filled = 0;
879|   int data_size = 8192;
880|   char *data = xmalloc (data_size + 1);
881| 
882|   /* If they passed the space for the file name to return, use it.  */
883|   f = open_possibly_compressed_file (filename, create_callback,
884|                                      opened_filename,
885|                                      compression_program);
886| 
887|   if (!f)
888|     return 0;
889| 
890|   for (;;)
891|     {
892|       int nread = fread (data + filled, 1, data_size - filled, f);
893|       if (nread < 0)
894|         return 0;
895|       if (nread == 0)
896|         break;
897| 
898|       filled += nread;
899|       if (filled == data_size)
900|         {
901|           data_size += 65536;
902|           data = xrealloc (data, data_size + 1);
903|         }
904|     }
905| 
906|   /* We need to close the stream, since on some systems the pipe created
907|      by popen is simulated by a temporary file which only gets removed
908|      inside pclose.  */
909|   if (compression_program && *compression_program)
910|     pclose (f);
911|   else
912|     fclose (f);
913| 
914|   *sizep = filled;
915|   data[filled] = ''\0'';
916| 
917|   return data;
918| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050073');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (247, 112, 'def8', 'RESOURCE_LEAK', 'texinfo-7.1/install-info/install-info.c:750: alloc_fn: Storage is returned from allocation function "fopen".
texinfo-7.1/install-info/install-info.c:750: var_assign: Assigning: "f" = storage returned from "fopen(*opened_filename, "r")".
texinfo-7.1/install-info/install-info.c:753: noescape: Resource "f" is not freed or pointed-to in "fread". [Note: The source code implementation of the function has been overridden by a builtin model.]
texinfo-7.1/install-info/install-info.c:856: noescape: Resource "f" is not freed or pointed-to in "fseek".
texinfo-7.1/install-info/install-info.c:857: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  855|         /* Seek back over the magic bytes.  */
#  856|         if (fseek (f, 0, 0) < 0)
#  857|->         return 0;
#  858|   #endif
#  859|       }', 'TRUE POSITIVE', 'Resource `f` allocated by `fopen` (line 750) is not freed in the execution path where `fseek` returns an error (line 857), directly correlating with CWE-772 (Resource Leak) vulnerability.', 'The CVE report indicates a potential resource leak due to unfreed storage allocated by `fopen` (lines 750, 857 in the CVE report).

Upon examining the code, the `fopen` call indeed allocates a resource stored in the `f` variable (line 750, `f = fopen (*opened_filename, FOPEN_RBIN);`).

The `fread` (line 753) and `fseek` (line 856) operations utilize this resource but do not free it.

Critically, at line 857, if `fseek` returns an error (< 0), the function immediately returns 0 without freeing the resource `f`, leading to a resource leak.

While the code does contain `fclose` calls in other branches (e.g., lines 832, 843, and implicitly through `freopen` at line 851), the specific execution path leading to line 857 does not ensure the resource is freed, aligning with the CWE-772 (Resource Leak) vulnerability described.

Uncertainty about other execution paths does not negate the identified vulnerable path; hence, a single confirmed vulnerable path is sufficient to classify this as TRUE POSITIVE.

Direct correlation exists between the code''s behavior at lines 750, 856, and 857 and the described vulnerability, fulfilling the requirement for a direct link.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050074');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (248, 112, 'def9', 'USE_AFTER_FREE', 'texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:539: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  537|                                                         ref_list[0]->nodename,
#  538|                                                         0);
#  539|->           free (*error); *error = 0;
#  540|             node_via_menus = info_follow_menus (initial_node, argv, error, 0);
#  541|             if (node_via_menus)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:539: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  537|                                                         ref_list[0]->nodename,
#  538|                                                         0);
#  539|->           free (*error); *error = 0;
#  540|             node_via_menus = info_follow_menus (initial_node, argv, error, 0);
#  541|             if (node_via_menus)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:539: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  537|                                                         ref_list[0]->nodename,
#  538|                                                         0);
#  539|->           free (*error); *error = 0;
#  540|             node_via_menus = info_follow_menus (initial_node, argv, error, 0);
#  541|             if (node_via_menus)
(Example-1) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:525: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  523|                   {
#  524|                     argv += argc; argc = 0;
#  525|->                   free (*error); *error = 0;
#  526|   
#  527|                     info_reference_free (ref_list[0]);
(Example-2) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

', '2025-11-17 21:39:07.050074');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (249, 112, 'def10', 'INTEGER_OVERFLOW', 'texinfo-7.1/info/makedoc.c:299: tainted_data_argument: The check "offset < file_size - decl_len" contains the tainted expression "file_size - decl_len" which causes "offset" to be considered tainted.
texinfo-7.1/info/makedoc.c:309: overflow: The expression "offset += decl_len" is deemed overflowed because at least one of its arguments has overflowed.
texinfo-7.1/info/makedoc.c:310: assign: Assigning: "point" = "offset".
texinfo-7.1/info/makedoc.c:347: assign: Assigning: "offset" = "point".
texinfo-7.1/info/makedoc.c:349: overflow: The expression "offset - point" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:349: overflow_sink: "offset - point", which might have underflowed, is passed to "strncpy(func, buffer + point, offset - point)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  347|         for (offset = point; buffer[offset] != '',''; offset++);
#  348|         func = xmalloc (1 + (offset - point));
#  349|->       strncpy (func, buffer + point, offset - point);
#  350|         func[offset - point] = ''\0'';
#  351|', 'TRUE POSITIVE', 'A potential buffer overflow vulnerability exists due to an underflowed `offset - point` value being passed to `strncpy` (line 349), caused by the propagation of a potentially overflowed `offset` value (lines 309-310, 347), directly correlating with the described vulnerability in the CVE report.', '1. **Tainted Data Argument**: At line 299, the check `offset < file_size - decl_len` uses `file_size - decl_len`, which is considered tainted. This taint is then propagated to `offset` (lines 309-310). While the taint itself doesn''t confirm a vulnerability, it indicates a potential issue with how user/input data (`file_size`) is handled in relation to `offset`.

2. **Overflow in Offset Calculation**: The expression `offset += decl_len` (line 309) is flagged for overflow because one of its arguments has overflowed. This could potentially lead to an incorrect `offset` value, affecting subsequent memory allocations and string operations.

3. **Assignment and Propagation of Potentially Overflowed Value**: The value of `offset` (potentially overflowed) is assigned to `point` (line 310) and later reassigned back to `offset` (line 347). This ensures that any overflow condition is preserved and carried forward in the execution path.

4. **Underflow in `offset - point`**: At line 349, the expression `offset - point` is deemed underflowed. Critically, this underflowed value is **directly passed to `strncpy` as the third argument**, which specifies the maximum number of characters to be copied. An underflow here could potentially lead to a large, unintended value being passed to `strncpy`, causing it to copy beyond the intended bounds.

5. **Direct Correlation with Vulnerability**: The described issue directly correlates with a potential buffer overflow vulnerability in the `strncpy` function call (line 349). If `offset - point` underflows, it could result in `strncpy` copying more data than intended, potentially overflowing the buffer allocated for `func` (line 348).

6. **Single Vulnerable Path Identified**: A specific sequence of execution (overflow at line 309, propagated through assignments, leading to underflow at line 349, and then used in `strncpy`) demonstrates a potential vulnerability, satisfying the condition for a TRUE POSITIVE finding.', 'Validate the feasibility of the overflow and underflow conditions under normal and edge-case input scenarios for `file_size` and `decl_len`.

Assess the impact of using a builtin model for `strncpy` on the potential buffer overflow vulnerability, including any bounds checking or security features it may incorporate.

Investigate the broader codebase for any mitigating security measures that could affect the exploitability of the described vulnerability.', 0.0000, '*** Source Code Context ***

code of info/makedoc.c file:
258| static void
259| process_one_file (char *filename, FILE *doc_stream, FILE *funs_stream)
260| {
261|   int descriptor, decl_len;
262|   char *buffer, *decl_str;
263|   struct stat finfo;
264|   long offset;
265|   long file_size;
266|   EMACS_TAG_BLOCK *block;
267| 
268|   if (stat (filename, &finfo) == -1)
269|     fatal_file_error (filename);
270| 
271|   descriptor = open (filename, O_RDONLY, 0666);
272| 
273|   if (descriptor == -1)
274|     fatal_file_error (filename);
275| 
276|   file_size = (long) finfo.st_size;
277|   buffer = xmalloc (1 + file_size);
278|   /* On some systems, the buffer will actually contain
279|      less characters than the full file''s size, because
280|      the CR characters are removed from line endings.  */
281|   file_size = read (descriptor, buffer, file_size);
282|   close (descriptor);
283| 
284|   offset = 0;
285|   decl_str = DECLARATION_STRING;
286|   decl_len = strlen (decl_str);
287| 
288|   block = make_emacs_tag_block (filename);
289| 
290|   while (1)
291|     {
292|       long point = 0;
293|       long line_start = 0;
294|       int line_number = 0;
295| 
296|       char *func, *doc;
297|       char *func_name;
298| 
299|       for (; offset < (file_size - decl_len); offset++)
300|         {
301|           if (buffer[offset] == ''
'')
302|             {
303|               line_number++;
304|               line_start = offset + 1;
305|             }
306| 
307|           if (strncmp (buffer + offset, decl_str, decl_len) == 0)
308|             {
309|               offset += decl_len;
310|               point = offset;
311|               break;
312|             }
313|         }
314| 
315|       if (!point)
316|         break;
317| 
318|       /* Skip forward until we find the open paren. */
319|       while (point < file_size)
320|         {
321|           if (buffer[point] == ''
'')
322|             {
323|               line_number++;
324|               line_start = point + 1;
325|             }
326|           else if (buffer[point] == ''('')
327|             break;
328| 
329|           point++;
330|         }
331| 
332|       while (point++ < file_size)
333|         {
334|           if (!whitespace_or_newline (buffer[point]))
335|             break;
336|           else if (buffer[point] == ''
'')
337|             {
338|               line_number++;
339|               line_start = point + 1;
340|             }
341|         }
342| 
343|       if (point >= file_size)
344|         break;
345| 
346|       /* Now looking at name of function.  Get it. */
347|       for (offset = point; buffer[offset] != '',''; offset++);
348|       func = xmalloc (1 + (offset - point));
349|       strncpy (func, buffer + point, offset - point);
350|       func[offset - point] = ''\0'';
351| 
352|       /* Remember this tag in the current block. */
353|       {
354|         char *tag_name;
355| 
356|         tag_name = xmalloc (1 + (offset - line_start));
357|         strncpy (tag_name, buffer + line_start, offset - line_start);
358|         tag_name[offset - line_start] = ''\0'';
359|         add_tag_to_block (block, tag_name, line_number, point);
360|       }
361| 
362|       /* Generate the user-visible function name from the function''s name. */
363|       {
364|         register int i;
365|         char *name_start;
366| 
367|         name_start = func;
368| 
369|         if (strncmp (name_start, "info_", 5) == 0)
370|           name_start += 5;
371| 
372|         func_name = xstrdup (name_start);
373| 
374|         /* Fix up "ea" commands. */
375|         if (strncmp (func_name, "ea_", 3) == 0)
376|           {
377|             char *temp_func_name;
378| 
379|             temp_func_name = xmalloc (10 + strlen (func_name));
380|             strcpy (temp_func_name, "echo_area_");
381|             strcat (temp_func_name, func_name + 3);
382|             free (func_name);
383|             func_name = temp_func_name;
384|           }
385| 
386|         for (i = 0; func_name[i]; i++)
387|           if (func_name[i] == ''_'')
388|             func_name[i] = ''-'';
389|       }
390| 
391|       /* Find doc string. */
392|       point = offset + 1;
393| 
394|       while (point < file_size)
395|         {
396|           if (buffer[point] == ''
'')
397|             {
398|               line_number++;
399|               line_start = point + 1;
400|             }
401| 
402|           if (buffer[point] == ''"'')
403|             break;
404|           else
405|             point++;
406|         }
407| 
408|       offset = point + 1;
409| 
410|       while (offset < file_size)
411|         {
412|           if (buffer[offset] == ''
'')
413|             {
414|               line_number++;
415|               line_start = offset + 1;
416|             }
417| 
418|           if (buffer[offset] == ''\\'')
419|             offset += 2;
420|           else if (buffer[offset] == ''"'')
421|             break;
422|           else
423|             offset++;
424|         }
425| 
426|       offset++;
427|       if (offset >= file_size)
428|         {
429|           free (func_name);
430|           free (func);
431|           break;
432|         }
433| 
434|       doc = xmalloc (1 + (offset - point));
435|       strncpy (doc, buffer + point, offset - point);
436|       doc[offset - point] = ''\0'';
437| 
438|       fprintf (doc_stream,
439|           "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },
",
440|           func, func_name, doc);
441| 
442|       free (func_name);
443| 
444|       fprintf (funs_stream, "#define A_%s %u
", func, next_func_key());
445|       fprintf (funs_stream,
446|           "extern void %s (WINDOW *window, int count);
",
447|           func);
448|       free (func);
449|       free (doc);
450|     }
451|   free (buffer);
452| 
453|   /* If we created any tags, remember this file on our global list.  Otherwise,
454|      free the memory already allocated to it. */
455|   if (block->entries)
456|     add_pointer_to_array (block, emacs_tags_index, emacs_tags,
457|                           emacs_tags_slots, 10);
458|   else
459|     {
460|       free (block->filename);
461|       free (block);
462|     }
463| }


*** Examples ***
', '2025-11-17 21:39:07.050075');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (250, 112, 'def11', 'USE_AFTER_FREE', 'texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1079: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1077|         if (error)
# 1078|           {
# 1079|->           info_error ("%s", error);
# 1080|             exit (1);
# 1081|           }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1079: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1077|         if (error)
# 1078|           {
# 1079|->           info_error ("%s", error);
# 1080|             exit (1);
# 1081|           }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1079: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1077|         if (error)
# 1078|           {
# 1079|->           info_error ("%s", error);
# 1080|             exit (1);
# 1081|           }
(Example-1) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1069: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1067|         if (error)
# 1068|           {
# 1069|->           info_error ("%s", error);
# 1070|             exit (1);
# 1071|           }
(Example-2) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

', '2025-11-17 21:39:07.050075');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (251, 112, 'def12', 'RESOURCE_LEAK', 'texinfo-7.1/install-info/install-info.c:662: alloc_fn: Storage is returned from allocation function "fopen".
texinfo-7.1/install-info/install-info.c:662: var_assign: Assigning: "f" = storage returned from "fopen(*opened_filename, "r")".
texinfo-7.1/install-info/install-info.c:735: noescape: Resource "f" is not freed or pointed-to in "fread". [Note: The source code implementation of the function has been overridden by a builtin model.]
texinfo-7.1/install-info/install-info.c:741: noescape: Resource "f" is not freed or pointed-to in "feof".
texinfo-7.1/install-info/install-info.c:760: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  758|           }
#  759|         errno = 0;
#  760|->       return 0; /* unknown error */
#  761|       }
#  762|', 'TRUE POSITIVE', 'Variable `f`, assigned the return value of `fopen` (line 662), is not freed on the error path leading to line 760, where the function returns 0, confirming a resource leak, as no `fclose(f)` call is made in this specific execution path.', 'The CVE report indicates a potential resource leak due to unfreed storage allocated by `fopen` (line 662).

The variable `f` is assigned the return value of `fopen` and is used in subsequent `fread` (line 735) and `feof` (line 741) calls.

At line 760, the function returns 0 (indicating an unknown error) without freeing the resource pointed to by `f`, which is within the scope of the reported error.

There is no explicit `fclose(f)` or equivalent call on the error path leading to line 760, which would release the allocated resource.

Although `fclose(f)` is called in other parts of the code (e.g., line 832), the specific execution path ending at line 760 does not include such a call, confirming the leak.

Uncertainties about other parts of the system or environment do not affect this conclusion, as the analysis is restricted to the provided code snippet and CVE report.

A single vulnerable path (the error return at line 760 without freeing `f`) is sufficient to classify this as a TRUE POSITIVE.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050075');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (252, 112, 'def13', 'USE_AFTER_FREE', 'texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: deref_arg: Calling "show_error_node" dereferences freed pointer "error".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: deref_arg: Calling "show_error_node" dereferences freed pointer "error".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: deref_arg: Calling "show_error_node" dereferences freed pointer "error".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|
(Example-1) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/session.c:2903: freed_arg: "info_follow_menus" frees "error".
texinfo-7.1/info/session.c:2906: pass_freed_arg: Passing freed pointer "error" as an argument to "show_error_node".
# 2904|             info_set_node_of_window (window, node);
# 2905|             if (error)
# 2906|->             show_error_node (error);
# 2907|           }
# 2908|
(Example-2) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

', '2025-11-17 21:39:07.050076');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (253, 112, 'def14', 'CPPCHECK_WARNING', 'texinfo-7.1/install-info/install-info.c:755: error[resourceLeak]: Resource leak: f
#  753|                 nread = fread (data, sizeof (data), 1, f);
#  754|                 if (nread == 0)
#  755|->                 return 0;
#  756|                 goto determine_file_type; /* success */
#  757|               }', 'TRUE POSITIVE', 'File pointer `f` is not closed before returning 0 at line 755 when `nread == 0`, following a successful `fread` operation at line 753, with no intervening resource release or exception handling.', 'The CVE report snippet explicitly highlights a resource leak at line 755, where the function returns 0 without closing the file pointer `f`.

At line 755, the `return 0` statement is executed when `nread == 0`, without any preceding `fclose(f)` call to release the file resource.

The file pointer `f` was successfully opened prior to this point, as evidenced by the `fread` operation at line 753, which would not have executed if `f` were NULL.

There is no conditional statement or exception handling between lines 753-755 that would mitigate the resource leak by closing `f` before returning.

The `goto determine_file_type` statement at line 756 is not executed when `nread == 0`, thus any potential resource management (e.g., `fclose(f)`) that might occur later in the function (e.g., at line 832) does not apply to this specific execution path.

Given the direct correlation between the code''s behavior at lines 753-755 and the described vulnerability (resource leak), and without any explicit proof that `f` is safely closed in this specific execution path, the finding cannot be conclusively deemed a FALSE POSITIVE.', 'Provide the full function containing line 755 to assess all possible execution paths and resource management practices.

Clarify the program''s behavior immediately after returning from this function, including any potential file pointer management.

Evaluate the exploitability of the resource leak in the context of the program''s deployment environment (e.g., constraints on file descriptor limits, typical usage patterns).', 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
', '2025-11-17 21:39:07.050076');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (399, 102, 'def2', 'UNINIT', 'glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2250: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2250: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2248|   					  + 2 * (runp->nmbs - 1));
# 2249|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2250|-> 		obstack_make_room (&extrapool, added);
# 2251|   
# 2252|   		/* More than one consecutive entry.  We mark this by having', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2250: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2250: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2248|    + 2 * (runp->nmbs - 1));
# 2249|   .assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2250|->  obstack_make_room (&extrapool, added);
# 2251|   
# 2252|   /* More than one consecutive entry.  We mark this by having', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2250: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2250: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2248|   					  + 2 * (runp->nmbs - 1));
# 2249|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2250|-> 		obstack_make_room (&extrapool, added);
# 2251|   
# 2252|   		/* More than one consecutive entry.  We mark this by having
(Example-1) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2309: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2309: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2307|   					  + runp->nmbs - 1);
# 2308|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2309|-> 		obstack_make_room (&extrapool, added);
# 2310|   
# 2311|   		obstack_int32_grow_fast (&extrapool, weightidx);
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118802');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (254, 112, 'def15', 'OVERRUN', 'texinfo-7.1/info/session.c:3483: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 3481|             char *nodename;
# 3482|   
# 3483|->           nodename = xmalloc (strlen (program) + strlen (*try_node));
# 3484|             sprintf (nodename, *try_node, program);
# 3485|             /* The last resort "%s" is dangerous, so we restrict it', 'TRUE POSITIVE', 'Insufficient memory allocation at line 3483 (`strlen(program) + strlen(*try_node)`) neglects the required null-terminator byte, potentially leading to buffer overflow or undefined behavior when followed by `sprintf` at line 3484.', 'The allocation size for `nodename` at line 3483 is calculated as `strlen(program) + strlen(*try_node)`, which does not account for the additional byte required for the null-terminator (`
`) in C strings.

Immediately after allocation, `sprintf` is used at line 3484 to populate `nodename`. The format string `*try_node` may contain format specifiers (e.g., `%s`), and `program` is passed as an argument. Even if `*try_node` is just a simple string without format specifiers, the minimum requirement for a null-terminated string is not met by the allocation.

The comment at line 3485 hints at awareness of potential issues with certain format strings, but it does not address the insufficient memory allocation for the null-terminator.

Given the explicit operations performed, there is a direct correlation between the allocation at line 3483 and the potential for a buffer overflow or undefined behavior when `sprintf` attempts to null-terminate the string, aligning with the CVE description of allocating insufficient memory for the terminating null.

No explicit proof within the provided code snippet ensures all execution paths safely handle the allocation for the null-terminator, leading to the conclusion that this is not a false positive.', NULL, 0.0000, '*** Source Code Context ***

code of info/session.c file:
3416| REFERENCE *
3417| info_intuit_options_node (NODE *node, char *program)
3418| {
3419|   /* The list of node names typical for GNU manuals where the program
3420|      usage and specifically the command-line arguments are described.
3421|      This is pure heuristics.  I gathered these node names by looking
3422|      at all the Info files I could put my hands on.  If you are
3423|      looking for evidence to complain to the GNU project about
3424|      non-uniform style of documentation, here you have your case!  */
3425|   static const char *invocation_nodes[] = {
3426|     "%s invocation",
3427|     "Invoking %s",
3428|     "Preliminaries",    /* m4 has Invoking under Preliminaries! */
3429|     "Invocation",
3430|     "Command Arguments",/* Emacs */
3431|     "Invoking `%s''",
3432|     "%s options",
3433|     "Options",
3434|     "Option ",          /* e.g. "Option Summary" */
3435|     "Invoking",
3436|     "All options",      /* tar, paxutils */
3437|     "Arguments",
3438|     "%s cmdline",       /* ar */
3439|     "%s",               /* last resort */
3440|     (const char *)0
3441|   };
3442| 
3443|   char *filename = node->fullpath;
3444|   if (!strcmp ("Top", node->nodename))
3445|     {
3446|       /* Look through the list of nodes (and anchors) in the file for a node to 
3447|          start at.  There may be an invocation node that is not listed in the 
3448|          top-level menu (this is the case for the Bash 4.2 manual), or it may 
3449|          be referred to with an anchor ("Invoking makeinfo" in Texinfo 
3450|          manual).  */
3451|       FILE_BUFFER *fb;
3452|       NODE *n;
3453|       fb = info_find_file (filename);
3454|       if (!fb)
3455|         return 0;
3456|       n = find_invocation_node_by_nodename (fb, program);
3457|       if (n)
3458|         {
3459|           free_history_node (node);
3460|           node = n;
3461|         }
3462|     }
3463| 
3464|   /* We keep looking deeper and deeper in the menu structure until
3465|      there are no more menus or no menu items from the above list.
3466|      Some manuals have the invocation node sitting 3 or 4 levels deep
3467|      in the menu hierarchy...  */
3468|   while (1)
3469|     {
3470|       const char **try_node;
3471|       REFERENCE *entry = NULL;
3472| 
3473|       /* If no menu in this node, stop here.  Perhaps this node
3474|          is the one they need.  */
3475|       if (!node->references)
3476|         break;
3477| 
3478|       /* Look for node names typical for usage nodes in this menu.  */
3479|       for (try_node = invocation_nodes; *try_node; try_node++)
3480|         {
3481|           char *nodename;
3482| 
3483|           nodename = xmalloc (strlen (program) + strlen (*try_node));
3484|           sprintf (nodename, *try_node, program);
3485|           /* The last resort "%s" is dangerous, so we restrict it
3486|              to exact matches here.  */
3487|           entry = info_get_menu_entry_by_label
3488|             (node, nodename, strcmp (*try_node, "%s"));
3489|           free (nodename);
3490|           if (entry)
3491|             break;
3492|         }
3493| 
3494|       if (!entry)
3495|         break;
3496| 
3497|       /* Go down into menu, and repeat. */ 
3498| 
3499|       if (!entry->filename)
3500|         entry->filename = xstrdup (filename);
3501| 
3502|       {
3503|         NODE *node2;
3504|         node2 = info_get_node (entry->filename, entry->nodename);
3505|         if (!node2)
3506|           break;
3507|         free_history_node (node);
3508|         node = node2;
3509|       }
3510|     }
3511| 
3512|   {
3513|     char *n = node->nodename;
3514|     node->nodename = 0;
3515|     free_history_node (node);
3516|     return info_new_reference (filename, n);
3517|   }
3518| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|
(Example-1) Reason Marked as False Positive:
There''s more than sufficient memory as the "description" stores just a substring of entry (entry is in format "NAME. DESCRIPTION")

', '2025-11-17 21:39:07.050076');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (255, 112, 'def16', 'CPPCHECK_WARNING', 'texinfo-7.1/install-info/install-info.c:857: error[resourceLeak]: Resource leak: f
#  855|         /* Seek back over the magic bytes.  */
#  856|         if (fseek (f, 0, 0) < 0)
#  857|->         return 0;
#  858|   #endif
#  859|       }', 'TRUE POSITIVE', 'File descriptor `f` is not explicitly closed via `fclose(f)` in the error path at line 857, following a failed `fseek(f, 0, 0)`, directly correlating with the definition of a resource leak.', 'The reported error at line 857 indicates a potential resource leak of file descriptor `f`.

Upon examining the code, at line 857, if `fseek (f, 0, 0)` returns an error (< 0), the function immediately returns 0 without closing the file descriptor `f`.

There is no explicit call to `fclose(f)` or any equivalent resource release mechanism in the error path leading to the return at line 857.

The surrounding context (lines 848-859) shows that in the non-error case for text files (when `O_BINARY` is not defined), the file descriptor is indeed manipulated but not explicitly closed in the error scenario of `fseek` failing.

The absence of a closure for `f` in the error path directly correlates with the definition of a resource leak, as system resources associated with `f` are not properly released.

Given the explicit behavior of the provided source code, there is a direct and demonstrable link between the code''s behavior and the vulnerability described in the CVE (resource leak).

Since at least one execution path (the error case of `fseek`) potentially leads to the described vulnerability, the finding cannot be considered a FALSE POSITIVE.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
', '2025-11-17 21:39:07.050076');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (256, 112, 'def17', 'USE_AFTER_FREE', 'texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1085: pass_freed_arg: Passing freed pointer "error" as an argument to "info_session".
# 1083|       }
# 1084|       
# 1085|->   info_session (ref_list, all_matches_p ? user_filename : 0, error);
# 1086|     close_info_session ();
# 1087|     exit (0);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1085: pass_freed_arg: Passing freed pointer "error" as an argument to "info_session".
# 1083|       }
# 1084|       
# 1085|->   info_session (ref_list, all_matches_p ? user_filename : 0, error);
# 1086|     close_info_session ();
# 1087|     exit (0);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1085: pass_freed_arg: Passing freed pointer "error" as an argument to "info_session".
# 1083|       }
# 1084|       
# 1085|->   info_session (ref_list, all_matches_p ? user_filename : 0, error);
# 1086|     close_info_session ();
# 1087|     exit (0);
(Example-1) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1079: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1077|         if (error)
# 1078|           {
# 1079|->           info_error ("%s", error);
# 1080|             exit (1);
# 1081|           }
(Example-2) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

', '2025-11-17 21:39:07.050077');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (257, 112, 'def18', 'nan', 'nan', 'FALSE POSITIVE', 'Investigation yields FALSE POSITIVE due to insufficient information: no CVE report snippet, source code context, or comparative examples were provided to facilitate a conclusive vulnerability assessment.', 'No CVE Report Snippet is provided to analyze against the source code.

No Source Code Context is provided to examine for potential vulnerabilities.

No Examples of verified CVEs with the same CWE are provided for comparative analysis.

Without explicit information about the CVE, source code, and comparative examples, a conclusive determination of TRUE POSITIVE or FALSE POSITIVE based on the provided instructions is impossible.', 'Provide a detailed report snippet describing the CVE, including its identifier, summary, and affected components.

Supply relevant source code snippets that contextualize the potential vulnerability, highlighting specific lines or functions of interest.

Offer examples of validated CVEs with the same CWE for comparative analysis to enhance understanding of the vulnerability''s nature and potential impact.

Clarify the environment and configurations in which the vulnerability is suspected to exist (e.g., operating system, software versions).', 0.0000, '*** Source Code Context ***


*** Examples ***
', '2025-11-17 21:39:07.050077');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (258, 112, 'def19', 'OVERRUN', 'texinfo-7.1/info/session.c:2337: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 2335|             if (defentry)
# 2336|               {
# 2337|->               prompt = xmalloc (strlen (defentry->label)
# 2338|                                   + strlen (_("Menu item (%s): ")));
# 2339|                 sprintf (prompt, _("Menu item (%s): "), defentry->label);', 'TRUE POSITIVE', 'Presence of default value indicates a failure to replace it, confirming an actual issue (True Positive).', 'This is a default value, if it''s not replaced, something went wrong', 'Perform a thorough examination of the memory allocation for `prompt` in `texinfo-7.1/info/session.c:2337`, considering the concatenation of strings and the subsequent `sprintf` usage.

Verify if the `builtin model` override for the function implementation affects the memory allocation behavior in this context.

Compare the allocation pattern in the reported CVE with the known false positive (Example-1) to identify any distinguishing factors.

Assess the potential impact of the allocated memory size on the `sprintf` function call at line 2339, considering buffer overflow possibilities.', 0.0000, '*** Source Code Context ***

code of info/session.c file:
2258| static void
2259| info_menu_or_ref_item (WINDOW *window, int menu_item, int xref, int ask_p)
2260| {
2261|   REFERENCE *defentry = NULL; /* Default link */
2262|   REFERENCE **refs = window->node->references;
2263|   REFERENCE *entry;
2264| 
2265|   /* Name of destination */
2266|   char *line;
2267| 
2268|   int line_no;
2269|   int this_line, next_line;
2270| 
2271|   int which, closest = -1;
2272| 
2273|   reference_bool_fn exclude; 
2274| 
2275|   if (!refs)
2276|     return;
2277| 
2278|   if (menu_item && !xref)
2279|     {
2280|       exclude = &exclude_cross_references;
2281|     }
2282|   else if (!menu_item && xref)
2283|     {
2284|       exclude = &exclude_menu_items;
2285|     }
2286|   else if (menu_item && xref)
2287|     {
2288|       exclude = &exclude_nothing;
2289|     }
2290|   else /* !menu_item && !xref */
2291|     return;
2292| 
2293|   line_no = window_line_of_point (window);
2294|   this_line = window->line_starts[line_no];
2295|   if (window->line_starts[line_no + 1])
2296|     next_line = window->line_starts[line_no + 1];
2297|   else
2298|     next_line = window->node->nodelen;
2299| 
2300|   /* Look for a reference in the current line, preferring one that
2301|      the point is in, otherwise preferring after the point. */
2302|   for (which = 0; refs[which]; which++)
2303|     {
2304|       /* If we got to the next line without finding an eligible reference. */
2305|       if (refs[which]->start >= next_line)
2306|         break;
2307| 
2308|       /* Check the type of reference is one we are looking for. */
2309|       if (!(  (menu_item && refs[which]->type == REFERENCE_MENU_ITEM)
2310|            || (xref      && refs[which]->type == REFERENCE_XREF)))
2311|         continue;
2312| 
2313|       /* Reference is eligible if any part of it is in the line. */
2314|       if (refs[which]->start >= this_line && refs[which]->start < next_line
2315|           || refs[which]->start < this_line && refs[which]->end > this_line)
2316|         {
2317|           closest = which;
2318| 
2319|           /* Use the first reference that either contains the point
2320|              or is after the point. */
2321|           if (refs[which]->end > window->point)
2322|             break;
2323|         }
2324|     }
2325|   if (closest != -1)
2326|     defentry = refs[closest];
2327| 
2328|   if (ask_p)
2329|     {
2330|       char *prompt;
2331| 
2332|       /* Build the prompt string. */
2333|       if (menu_item && !xref)
2334|         {
2335|           if (defentry)
2336|             {
2337|               prompt = xmalloc (strlen (defentry->label)
2338|                                 + strlen (_("Menu item (%s): ")));
2339|               sprintf (prompt, _("Menu item (%s): "), defentry->label);
2340|             }
2341|           else
2342|             prompt = xstrdup (_("Menu item: "));
2343|         }
2344|       else
2345|         {
2346|           if (defentry)
2347|             {
2348|               prompt = xmalloc (strlen (defentry->label)
2349|                                 + strlen (_("Follow xref (%s): ")));
2350|               sprintf (prompt, _("Follow xref (%s): "), defentry->label);
2351|             }
2352|           else
2353|             prompt = xstrdup (_("Follow xref: "));
2354|         }
2355| 
2356|       line = info_read_completing_in_echo_area_with_exclusions (prompt, refs,
2357|                                                                 exclude);
2358|       free (prompt);
2359| 
2360|       window = active_window;
2361| 
2362|       /* User aborts, just quit. */
2363|       if (!line)
2364|         {
2365|           info_abort_key (window, 0);
2366|           return;
2367|         }
2368| 
2369|       /* If we had a default and the user accepted it, use that. */
2370|       if (!*line)
2371|         {
2372|           free (line);
2373|           if (defentry)
2374|             line = xstrdup (defentry->label);
2375|           else
2376|             line = NULL;
2377|         }
2378|     }
2379|   else
2380|     {
2381|       /* Not going to ask any questions.  If we have a default entry, use
2382|          that, otherwise return. */
2383|       if (!defentry)
2384|         return;
2385|       else
2386|         line = xstrdup (defentry->label);
2387|     }
2388| 
2389|   if (line)
2390|     {
2391|       /* It is possible that the references have more than a single
2392|          entry with the same label, and also LINE is down-cased, which
2393|          complicates matters even more.  Try to be as accurate as we
2394|          can: if they''ve chosen the default, use defentry directly. */
2395|       if (defentry && strcmp (line, defentry->label) == 0)
2396|         entry = defentry;
2397|       else
2398|         /* Find the selected label in the references.  If there are
2399|            more than one label which matches, find the one that''s
2400|            closest to point.  */
2401|         {
2402|           register int i;
2403|           int best = -1, min_dist = window->node->nodelen;
2404|           REFERENCE *ref;
2405| 
2406|           for (i = 0; refs && (ref = refs[i]); i++)
2407|             {
2408|               /* Need to use mbscasecmp because LINE is downcased
2409|                  inside info_read_completing_in_echo_area.  */
2410|               if (mbscasecmp (line, ref->label) == 0)
2411|                 {
2412|                   /* ref->end is more accurate estimate of position
2413|                      for menus than ref->start.  Go figure.  */
2414|                   int dist = abs (window->point - ref->end);
2415| 
2416|                   if (dist < min_dist)
2417|                     {
2418|                       min_dist = dist;
2419|                       best = i;
2420|                     }
2421|                 }
2422|             }
2423|           if (best != -1)
2424|             entry = refs[best];
2425|           else
2426|             entry = NULL;
2427|         }
2428| 
2429|       if (!entry && defentry)
2430|         info_error (_("The reference disappeared! (%s)"), line);
2431|       else
2432|         {
2433|           info_select_reference (window, entry);
2434|         }
2435| 
2436|       free (line);
2437|     }
2438| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|
(Example-1) Reason Marked as False Positive:
There''s more than sufficient memory as the "description" stores just a substring of entry (entry is in format "NAME. DESCRIPTION")

', '2025-11-17 21:39:07.050078');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (259, 112, 'def20', 'CPPCHECK_WARNING', 'texinfo-7.1/install-info/install-info.c:835: error[resourceLeak]: Resource leak: f2
#  833|         f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
#  834|         if (!f)
#  835|->         return 0;
#  836|         f = popen (command, "r");
#  837|         fclose (f2);', 'TRUE POSITIVE', 'Resource leak confirmed: `f2` (assigned at line 833) is not closed if the function returns at line 835 (when `f` is null), as `fclose(f2)` at line 837 is bypassed in this execution path.', 'The CVE report snippet explicitly highlights a resource leak for file descriptor `f2` at line 835.

At line 833, `f2` is assigned the result of `freopen(*opened_filename, FOPEN_RBIN, stdin)` which potentially allocates a new file descriptor.

The error condition checked at line 834 is for `f`, not `f2`. This implies that if `f` is null (or false), the function will return 0 at line 835, regardless of `f2`''s state.

Critically, the `fclose(f2)` statement, which would release the resource, is located at line 837, **after** the potential return at line 835. This means if the function returns at line 835 (due to `f` being null), `f2` will **not** be closed, confirming the resource leak.

There is no conditional statement or alternative execution path provided in the snippet that would ensure `f2` is closed in the event of the return at line 835, based on the provided code context.

Given the direct correlation between the code''s behavior and the described vulnerability (resource leak of `f2`), and identifying a specific sequence of execution (when `f` is null) that triggers this vulnerability, the finding is justified.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
', '2025-11-17 21:39:07.050078');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (260, 112, 'def21', 'UNINIT', 'texinfo-7.1/info/infokey.c:211: var_decl: Declaring variable "seq" without initializer.
texinfo-7.1/info/infokey.c:450: uninit_use: Using uninitialized value "seq[0]".
#  448|                            this default binding is disabled with "#stop".)
#  449|                            E.g. do not allow "b menu-digit".  */
#  450|->                       if (seq[0] != ''1'' || seq[1] != ''\0''
#  451|                             || section != info)
#  452|                           {', 'FALSE POSITIVE', 'Variable `seq` is initialized through the `To_seq(c)` macro within the `get_keyseq` state before its elements are accessed at line 450, ensuring no execution path leaves `seq[0]` uninitialized due to the preceding state machine flow (lines 233-577).', 'The variable `seq` is declared without an initializer at line 211, but its usage at line 450 is contingent upon previous assignments.

Upon examining the code, `seq` is populated through the `To_seq(c)` macro (defined at line 220) within the `get_keyseq` state (lines 294-419).

Specifically, `seq[0]` is assigned a value when a character `c` is processed in the `normal` seqstate (line 313) or through other seqstates (e.g., `slosh`, `octal`, `control`, `special_key`) that ultimately call `To_seq(c)`.

Before reaching line 450, the code checks for the completion of the key sequence (`state = got_keyseq`, lines 421-427), ensuring that `seq` has been populated before its elements are accessed.

The condition at line 450 (`if (seq[0] != ''1'' || seq[1] != ''
'' || section != info)`) is protected by the preceding state machine, which initializes `seq` elements before this check.

There is no identified execution path where `seq[0]` remains uninitialized when accessed at line 450, given the structured flow through the state machine (lines 233-577).

**Explicit Initialization Evidence:** The `To_seq(c)` macro (line 220-231) explicitly initializes `seq` elements, and its invocation precedes the usage of `seq[0]` at line 450, within the defined state machine flow.', 'Perform a comprehensive path analysis to confirm that all possible execution flows leading to line 450 initialize `seq[0]` before use.

Verify the program''s error handling (e.g., lines 304-305) to ensure it prevents undefined behavior due to uninitialized `seq[0]` in all conceivable error scenarios.', 0.0000, '*** Source Code Context ***

code of info/infokey.c file:
159| int
160| compile (FILE *fp, const char *filename, int *suppress_info, int *suppress_ea)
161| {
162|   int error = 0; /* Set if there was a fatal error in reading init file. */
163|   char rescan = 0; /* Whether to reuse the same character when moving onto the
164|                       next state. */
165|   unsigned int lnum = 0;
166|   int c = 0;
167| 
168|   /* This parser is a true state machine, with no sneaky fetching
169|      of input characters inside the main loop.  In other words, all
170|      state is fully represented by the following variables:
171|    */
172|   enum
173|     {
174|       start_of_line,
175|       start_of_comment,
176|       in_line_comment,
177|       in_trailing_comment,
178|       get_keyseq,
179|       got_keyseq,
180|       get_action,
181|       got_action,
182|       get_varname,
183|       got_varname,
184|       get_equals,
185|       got_equals,
186|       get_value
187|     }
188|   state = start_of_line;
189|   enum sect_e section = info;
190|   enum
191|     {
192|       normal,
193|       slosh,
194|       control,
195|       octal,
196|       special_key
197|     }
198|   seqstate = normal;	/* used if state == get_keyseq */
199|   char meta = 0;
200|   char ocnt = 0;	/* used if state == get_keyseq && seqstate == octal */
201| 
202|   /* Data is accumulated in the following variables.  The code
203|      avoids overflowing these strings, and throws an error
204|      where appropriate if a string limit is exceeded.  These string
205|      lengths are arbitrary (and should be large enough) and their
206|      lengths are not hard-coded anywhere else, so increasing them
207|      here will not break anything.  */
208|   char oval = 0;
209|   char comment[10];
210|   unsigned int clen = 0;
211|   int seq[20];
212|   unsigned int slen = 0;
213|   char act[80];
214|   unsigned int alen = 0;
215|   char varn[80];
216|   unsigned int varlen = 0;
217|   char val[80];
218|   unsigned int vallen = 0;
219| 
220| #define	To_seq(c) \
221| 		  do { \
222| 		    if (slen < sizeof seq/sizeof(int)) \
223| 		      seq[slen++] = meta ? KEYMAP_META(c) : (c); \
224| 		    else \
225| 		      { \
226| 			syntax_error(filename, lnum, \
227| 				     _("key sequence too long")); \
228| 			error = 1; \
229| 		      } \
230| 		    meta = 0; \
231| 		  } while (0)
232| 
233|   while (!error && (rescan || (c = fgetc (fp)) != EOF))
234|     {
235|       rescan = 0;
236|       switch (state)
237| 	{
238| 	case start_of_line:
239| 	  lnum++;
240| 	  if (c == ''#'')
241| 	    state = start_of_comment;
242| 	  else if (c != ''
'')
243| 	    {
244| 	      switch (section)
245| 		{
246| 		case info:
247| 		case ea:
248| 		  state = get_keyseq;
249| 		  seqstate = normal;
250| 		  slen = 0;
251| 		  break;
252| 		case var:
253| 		  state = get_varname;
254| 		  varlen = 0;
255| 		  break;
256| 		}
257| 	      rescan = 1;
258| 	    }
259| 	  break;
260| 
261| 	case start_of_comment:
262| 	  clen = 0;
263| 	  state = in_line_comment;
264| 	  /* fall through */
265| 	case in_line_comment:
266| 	  if (c == ''
'')
267| 	    {
268| 	      state = start_of_line;
269| 	      comment[clen] = ''\0'';
270| 	      if (strcmp (comment, "info") == 0)
271| 		section = info;
272| 	      else if (strcmp (comment, "echo-area") == 0)
273| 		section = ea;
274| 	      else if (strcmp (comment, "var") == 0)
275| 		section = var;
276| 	      else if (strcmp (comment, "stop") == 0
277| 		       && (section == info || section == ea))
278|                 {
279|                   if (section == info)
280|                     *suppress_info = 1;
281|                   else
282|                     *suppress_ea = 1;
283|                 }
284| 	    }
285| 	  else if (clen < sizeof comment - 1)
286| 	    comment[clen++] = c;
287| 	  break;
288| 
289| 	case in_trailing_comment:
290| 	  if (c == ''
'')
291| 	    state = start_of_line;
292| 	  break;
293| 
294| 	case get_keyseq:
295| 	  switch (seqstate)
296| 	    {
297| 	    case normal:
298| 	      if (c == ''
'' || isspace (c))
299| 		{
300| 		  state = got_keyseq;
301| 		  rescan = 1;
302| 		  if (slen == 0)
303| 		    {
304| 		      syntax_error (filename, lnum, _("missing key sequence"));
305| 		      error = 1;
306| 		    }
307| 		}
308| 	      else if (c == ''\\'')
309| 		seqstate = slosh;
310| 	      else if (c == ''^'')
311| 		seqstate = control;
312| 	      else
313| 		To_seq (c);
314| 	      break;
315| 
316| 	    case slosh:
317| 	      switch (c)
318| 		{
319| 		case ''0'': case ''1'': case ''2'': case ''3'':
320| 		case ''4'': case ''5'': case ''6'': case ''7'':
321| 		  seqstate = octal;
322| 		  oval = c - ''0'';
323| 		  ocnt = 1;
324| 		  break;
325| 		case ''b'':
326| 		  To_seq (''\b'');
327| 		  seqstate = normal;
328| 		  break;
329| 		case ''e'':
330| 		  To_seq (''\033'');
331| 		  seqstate = normal;
332| 		  break;
333| 		case ''n'':
334| 		  To_seq (''
'');
335| 		  seqstate = normal;
336| 		  break;
337| 		case ''r'':
338| 		  To_seq (''\r'');
339| 		  seqstate = normal;
340| 		  break;
341| 		case ''t'':
342| 		  To_seq (''\t'');
343| 		  seqstate = normal;
344| 		  break;
345| 		case ''m'':
346| 		  meta = 1;
347| 		  seqstate = normal;
348| 		  break;
349| 		case ''k'':
350| 		  seqstate = special_key;
351| 		  break;
352| 		default:
353| 		  /* Backslash followed by any other char
354| 		     just means that char.  */
355| 		  To_seq (c);
356| 		  seqstate = normal;
357| 		  break;
358| 		}
359| 	      break;
360| 
361| 	    case octal:
362| 	      switch (c)
363| 		{
364| 		case ''0'': case ''1'': case ''2'': case ''3'':
365| 		case ''4'': case ''5'': case ''6'': case ''7'':
366| 		  if (++ocnt <= 3)
367| 		    oval = oval * 8 + c - ''0'';
368| 		  if (ocnt == 3)
369| 		    seqstate = normal;
370| 		  break;
371| 		default:
372| 		  ocnt = 4;
373| 		  seqstate = normal;
374| 		  rescan = 1;
375| 		  break;
376| 		}
377| 	      if (seqstate != octal)
378| 		{
379| 		  if (oval)
380| 		    To_seq (oval);
381| 		  else
382| 		    {
383| 		      syntax_error (filename, lnum,
384| 				    _("NUL character (\\000) not permitted"));
385| 		      error = 1;
386| 		    }
387| 		}
388| 	      break;
389| 
390| 	    case special_key:
391| 	      switch (c)
392| 		{
393| 		case ''u'': To_seq (KEY_UP_ARROW); break;
394| 		case ''d'': To_seq (KEY_DOWN_ARROW); break;
395| 		case ''r'': To_seq (KEY_RIGHT_ARROW); break;
396| 		case ''l'': To_seq (KEY_LEFT_ARROW); break;
397| 		case ''U'': To_seq (KEY_PAGE_UP); break;
398| 		case ''D'': To_seq (KEY_PAGE_DOWN); break;
399| 		case ''h'': To_seq (KEY_HOME); break;
400| 		case ''e'': To_seq (KEY_END); break;
401| 		case ''x'': To_seq (KEY_DELETE); break;
402| 		default:  To_seq (c); rescan = 1; break;
403| 		}
404| 	      seqstate = normal;
405| 	      break;
406| 
407| 	    case control:
408| 	      if (CONTROL (c))
409| 		To_seq (CONTROL (c));
410| 	      else
411| 		{
412| 		  syntax_error (filename, lnum,
413| 				_("NUL character (^%c) not permitted"), c);
414| 		  error = 1;
415| 		}
416| 	      seqstate = normal;
417| 	      break;
418| 	    }
419| 	  break;
420| 
421| 	case got_keyseq:
422| 	  if (isspace (c) && c != ''
'')
423| 	    break;
424| 	  state = get_action;
425| 	  alen = 0;
426| 	  /* fall through */
427| 	case get_action:
428| 	  if (c == ''
'' || isspace (c))
429| 	    {
430| 	      int a;
431| 
432| 	      state = got_action;
433| 	      rescan = 1;
434| 	      if (alen == 0)
435| 		{
436| 		  syntax_error (filename, lnum, _("missing action name"));
437| 		  error = 1;
438| 		}
439| 	      else
440| 		{
441|                   int keymap_bind_keyseq (Keymap, int *, KEYMAP_ENTRY *);
442| 
443| 		  act[alen] = ''\0'';
444| 		  a = lookup_action (act);
445|                   if (a == A_info_menu_digit)
446| 		    {
447|                       /* Only allow "1 menu-digit".  (This is useful if
448|                          this default binding is disabled with "#stop".)
449|                          E.g. do not allow "b menu-digit".  */
450|                       if (seq[0] != ''1'' || seq[1] != ''\0''
451|                           || section != info)
452|                         {
453|                           syntax_error (filename, lnum,
454|                                  _("cannot bind key sequence to menu-digit"));
455|                         }
456|                       else
457|                         {
458|                           /* Bind each key from ''1'' to ''9'' to ''menu-digit''. */
459|                           KEYMAP_ENTRY ke;
460|                           int i;
461|                       
462|                           ke.type = ISFUNC;
463|                           ke.value.function = &function_doc_array[a];
464| 
465|                           for (i = ''1''; i <= ''9''; i++)
466|                             {
467|                               seq[0] = i;
468|                               keymap_bind_keyseq (info_keymap, seq, &ke);
469|                             }
470|                         }
471| 		    }
472| 		  else if (a == -1)
473| 		    {
474|                       /* Print an error message, but keep going (don''t set
475|                          error = 1) for compatibility with infokey files aimed
476|                          at future versions which may have different
477|                          actions. */
478| 		      syntax_error (filename, lnum, _("unknown action `%s''"),
479| 				    act);
480| 		    }
481|                   else
482| 		    {
483|                       KEYMAP_ENTRY ke;
484|                       static InfoCommand invalid_function = { 0 };
485|                       
486|                       ke.type = ISFUNC;
487|                       ke.value.function = a != A_INVALID
488|                                             ? &function_doc_array[a]
489|                                             : &invalid_function;
490|                       To_seq (0);
491| 
492|                       if (section == info)
493|                         keymap_bind_keyseq (info_keymap, seq, &ke);
494|                       else /* section == ea */
495|                         keymap_bind_keyseq (echo_area_keymap, seq, &ke);
496| 		    }
497| 		}
498| 	    }
499| 	  else if (alen < sizeof act - 1)
500| 	    act[alen++] = c;
501| 	  else
502| 	    {
503| 	      syntax_error (filename, lnum, _("action name too long"));
504| 	      error = 1;
505| 	    }
506| 	  break;
507| 
508| 	case got_action:
509| 	  if (c == ''#'')
510| 	    state = in_trailing_comment;
511| 	  else if (c == ''
'')
512| 	    state = start_of_line;
513| 	  else if (!isspace (c))
514| 	    {
515| 	      syntax_error (filename, lnum,
516| 			    _("extra characters following action `%s''"),
517| 			    act);
518| 	      error = 1;
519| 	    }
520| 	  break;
521| 
522| 	case get_varname:
523| 	  if (c == ''='')
524| 	    {
525| 	      if (varlen == 0)
526| 		{
527| 		  syntax_error (filename, lnum, _("missing variable name"));
528| 		  error = 1;
529| 		}
530| 	      state = get_value;
531| 	      vallen = 0;
532| 	    }
533| 	  else if (c == ''
'' || isspace (c))
534| 	    {
535| 	      syntax_error (filename, lnum,
536| 			    _("missing `='' immediately after variable name"));
537| 	      error = 1;
538| 	    }
539| 	  else if (varlen < sizeof varn - 1)
540| 	    varn[varlen++] = c;
541| 	  else
542| 	    {
543| 	      syntax_error (filename, lnum, _("variable name too long"));
544| 	      error = 1;
545| 	    }
546| 	  break;
547| 
548| 	case get_value:
549| 	  if (c == ''
'')
550| 	    {
551|               VARIABLE_ALIST *v;
552| 
553|               state = start_of_line;
554|               varn[varlen] = ''\0'';
555|               val[vallen] = ''\0'';
556|               v = variable_by_name (varn);
557|               if (!v)
558|                 info_error (_("%s: no such variable"), varn);
559|               else if (!set_variable_to_value (v, val, SET_IN_CONFIG_FILE))
560|                 info_error (_("value %s is not valid for variable %s"),
561|                               val, varn);
562| 	    }
563| 	  else if (vallen < sizeof val - 1)
564| 	    val[vallen++] = c;
565| 	  else
566| 	    {
567| 	      syntax_error (filename, lnum, _("value too long"));
568| 	      error = 1;
569| 	    }
570| 	  break;
571| 
572|         case get_equals:
573|         case got_equals:
574|         case got_varname:
575|           break;
576| 	}
577|     }
578| 
579| #undef To_seq
580| 
581|   return !error;
582| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1132: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1137: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1135|     mbi_avail (iter);
# 1136|   
# 1137|->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
# 1138|   }
# 1139|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1133

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/display.c:492: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.bytes" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc_valid" when calling "mbiter_multi_copy".
#  517|       {
#  518|         int delim;
#  519|->       mbi_copy (&bol_iter, &iter);
#  520|         bol_ref_index = ref_index;
#  521|         bol_match_index = match_index;
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 513

', '2025-11-17 21:39:07.050078');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (261, 112, 'def22', 'UNINIT', 'texinfo-7.1/info/session.c:2926: var_decl: Declaring variable "description" without initializer.
texinfo-7.1/info/session.c:2936: uninit_use: Using uninitialized value "description".
# 2934|       description = window->node->prev;
# 2935|   
# 2936|->   if (!description)
# 2937|       {
# 2938|         info_error (msg_no_pointer, label);', 'FALSE POSITIVE', 'Variable ''description'' is conditionally assigned a value (lines 2929-2933) before its use (line 2936), and a NULL check is performed, indicating the code manages potential uninitialized use through explicit assignment and error handling.', 'The variable ''description'' is declared without an initializer on line 2926, but this does not necessarily mean it remains uninitialized when used.

The code explicitly assigns a value to ''description'' based on the ''label'' condition in the preceding lines (2929-2933): ''description'' is set to either ''window->node->up'', ''window->node->next'', or ''window->node->prev'' before its use.

The specific line mentioned in the CVE report (2936) as using an uninitialized value, ''if (!description)'', is actually part of a conditional statement that checks if ''description'' is NULL after the potential assignments (2929-2934).

Given the conditional assignments (2929-2933) immediately precede the use of ''description'' (2936), and assuming ''window->node->up'', ''window->node->next'', and ''window->node->prev'' are properly managed (a reasonable assumption based on the provided context), ''description'' will not be used uninitialized if the program executes normally through this branch.

The error handling at line 2938 (info_error) for the case when ''description'' is NULL (implying no valid assignment was made) further indicates the code anticipates and manages the scenario where ''description'' might not be set to a valid value.', NULL, 0.0000, '*** Source Code Context ***

code of info/session.c file:
2923| static int
2924| info_handle_pointer (char *label, WINDOW *window)
2925| {
2926|   char *description;
2927|   NODE *node;
2928| 
2929|   if (!strcmp (label, "Up"))
2930|     description = window->node->up;
2931|   else if (!strcmp (label, "Next"))
2932|     description = window->node->next;
2933|   else if (!strcmp (label, "Prev"))
2934|     description = window->node->prev;
2935| 
2936|   if (!description)
2937|     {
2938|       info_error (msg_no_pointer, label);
2939|       return 0;
2940|     }
2941| 
2942|   info_parse_node (description);
2943|   node = info_get_node_with_defaults (info_parsed_filename,
2944|                                       info_parsed_nodename,
2945|                                       window->node);
2946|   if (!node)
2947|     {
2948|       if (info_recent_file_error)
2949|         info_error ("%s", info_recent_file_error);
2950|       else
2951|         info_error (msg_cant_find_node, description);
2952|       return 0;
2953|     }
2954| 
2955|   /* If we are going up, look for the current node in the menu. */
2956|   if (strcmp (label, "Up") == 0)
2957|     {
2958|       REFERENCE **r;
2959| 
2960|       for (r = node->references; (*r); r++)
2961|         {
2962|           if ((*r)->type == REFERENCE_MENU_ITEM
2963|               && strcmp ((*r)->nodename, window->node->nodename) == 0)
2964|             {
2965|               node->display_pos = (*r)->start;
2966|               break;
2967|             }
2968|         }
2969|     }
2970| 
2971|   info_set_node_of_window (window, node);
2972|   return 1;
2973| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

', '2025-11-17 21:39:07.050079');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (262, 112, 'def23', 'UNINIT', 'texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''\n'';
# 1126|   }
# 1127|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   .win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

', '2025-11-17 21:39:07.050079');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (305, 100, 'def22', 'OVERRUN', 'cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:1009: alias: Assigning: "bufp" = "buf + 23UL". "bufp" now points to byte 23 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1019: ptr_decr: Decrementing "bufp". "bufp" now points to byte 22 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1048: decr: Decrementing "width". The value of "width" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: cond_at_most: Checking "_n < _w" implies that "_n" may be up to 2147483645 on the true branch.
cpio-2.15/gnu/nstrftime.c:1051: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)bufp" of 23 bytes by passing it to a function which accesses it at byte offset 2147483666 using argument "_n" (which evaluates to 2147483645). [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1049|                 }
# 1050|   
# 1051|->             cpy (numlen, bufp);
# 1052|             }
# 1053|             break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:1009: alias: Assigning: "bufp" = "buf + 23UL". "bufp" now points to byte 23 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1019: ptr_decr: Decrementing "bufp". "bufp" now points to byte 22 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1048: decr: Decrementing "width". The value of "width" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: cond_at_most: Checking "_n < _w" implies that "_n" may be up to 2147483645 on the true branch.
cpio-2.15/gnu/nstrftime.c:1051: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)bufp" of 23 bytes by passing it to a function which accesses it at byte offset 2147483666 using argument "_n" (which evaluates to 2147483645).
# 1049|                 }
# 1050|   
# 1051|->             cpy (numlen, bufp);
# 1052|             }
# 1053|             break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:1009: alias: Assigning: "bufp" = "buf + 23UL". "bufp" now points to byte 23 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1019: ptr_decr: Decrementing "bufp". "bufp" now points to byte 22 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1048: decr: Decrementing "width". The value of "width" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: cond_at_most: Checking "_n < _w" implies that "_n" may be up to 2147483645 on the true branch.
cpio-2.15/gnu/nstrftime.c:1051: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)bufp" of 23 bytes by passing it to a function which accesses it at byte offset 2147483666 using argument "_n" (which evaluates to 2147483645). [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1049|                 }
# 1050|   
# 1051|->             cpy (numlen, bufp);
# 1052|             }
# 1053|             break;
(Example-1) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L153-196

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:885: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483647.
cpio-2.15/gnu/nstrftime.c:885: cond_between: Checking "_n < _w" implies that "_n" is between 0 and 2147483646 (inclusive) on the true branch.
cpio-2.15/gnu/nstrftime.c:885: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)(ubuf + 1)" of 1024 bytes by passing it to a function which accesses it at byte offset 2147483646 using argument "_n" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  883|               len = strftime (ubuf, sizeof ubuf, ufmt, tp);
#  884|               if (len != 0)
#  885|->               cpy (len - 1, ubuf + 1);
#  886|             }
#  887|             break;
(Example-2) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L153-196

', '2025-11-17 21:39:07.068559');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (263, 112, 'def24', 'UNINIT', 'texinfo-7.1/info/session.c:1132: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1137: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1135|     mbi_avail (iter);
# 1136|   
# 1137|->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
# 1138|   }
# 1139|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c: uninit_use: Using uninitialized value "iter.cur.wc_valid".
#     mbi_avail (iter);
#    
#->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
#   }
#   ', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1132: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1137: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1135|     mbi_avail (iter);
# 1136|   
# 1137|->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
# 1138|   }
# 1139|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1133

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

', '2025-11-17 21:39:07.050079');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (264, 112, 'def25', 'RESOURCE_LEAK', 'texinfo-7.1/info/session.c:4189: alloc_fn: Storage is returned from allocation function "info_node_of_tag_fast".
texinfo-7.1/info/session.c:4189: var_assign: Assigning: "node" = storage returned from "info_node_of_tag_fast(file_buffer, &tag)".
texinfo-7.1/info/session.c:4226: leaked_storage: Variable "node" going out of scope leaks the storage it points to.
# 4224|   
# 4225|   funexit:
# 4226|->   return -1;
# 4227|   }
# 4228|', 'TRUE POSITIVE', 'Storage allocated by `info_node_of_tag_fast` at line 4189 is assigned to `node` without evident deallocation before going out of scope at line 4226, specifically in the `funexit` path, potentially leading to a memory leak.', 'The CVE report indicates a potential memory leak, where storage allocated by `info_node_of_tag_fast` is assigned to `node` (lines 4189, referenced in CVE report).

Upon examining the provided source code, the `node` variable is indeed assigned the return value of `info_node_of_tag_fast` at line 4189.

The CVE report highlights a concern at line 4226, where `node` goes out of scope without explicit deallocation, potentially leading to a memory leak.

Analyzing the code path leading to `funexit` (line 4225), there is no evident call to a deallocation function (e.g., `free`) for the `node` variable after its assignment at line 4189 and before it goes out of scope at line 4226.

Although `free_history_node (node)` is called at line 4127 under certain conditions, this does not cover the specific execution path leading to `funexit` (line 4225) where the leak is reported, as the condition for `free_history_node (node)` is `if (node != window->node)`.

Given the direct correlation between the code''s behavior and the vulnerability described in the CVE, and without definitive proof of deallocation for all execution paths, the finding cannot be conclusively marked as a FALSE POSITIVE.

Uncertainty regarding the implementation of `info_node_of_tag_fast` is mitigated by the explicit concern raised in the CVE report about the allocation and subsequent lack of deallocation for `node`, focusing the analysis on the provided code''s behavior.', 'Verify the implementation of `info_node_of_tag_fast` to ensure no implicit deallocation occurs for the returned storage.

Exhaustively examine all execution paths involving `node` to confirm the absence of deallocation calls beyond the identified `free_history_node (node)` under specific conditions.

Investigate if any memory management mechanisms (e.g., custom allocators, garbage collection) are in place that could mitigate the reported leak, not immediately apparent from the provided source code snippets.', 0.0000, '*** Source Code Context ***

code of info/session.c file:
4072| static int
4073| info_search_internal (char *string, WINDOW *window,
4074| 		      int dir, int case_sensitive,
4075|                       long *start_off)
4076| {
4077|   register int i;
4078|   FILE_BUFFER *file_buffer;
4079|   long start;
4080|   enum search_result result;
4081|   int search_other_nodes = 1;
4082|   int number_of_tags = -1, starting_tag = -1, current_tag = -1;
4083|   NODE *node = window->node; /* Node to search in. */
4084|   char *subfile_name = 0;
4085|   TAG *tag;
4086|   char *msg = 0;
4087|   int first_time = 1;
4088|   
4089|   /* If this node isn''t part of a larger file, search this node only. */
4090|   file_buffer = file_buffer_of_window (window);
4091|   if (!file_buffer || !file_buffer->tags
4092|       || !strcmp (window->node->nodename, "*"))
4093|     search_other_nodes = 0;
4094| 
4095|   /* Find number of tags and current tag. */
4096|   if (search_other_nodes)
4097|     {
4098|       char *initial_nodename = window->node->nodename;
4099| 
4100|       for (i = 0; file_buffer->tags[i]; i++)
4101|         if (strcmp (initial_nodename, file_buffer->tags[i]->nodename) == 0)
4102|           {
4103|             starting_tag = i;
4104|             subfile_name = file_buffer->tags[i]->filename;
4105|           }
4106| 
4107|       number_of_tags = i;
4108| 
4109|       /* Our tag wasn''t found.  This shouldn''t happen. */
4110|       if (starting_tag == -1)
4111|         return -1;
4112|       current_tag = starting_tag;
4113|     }
4114| 
4115|   /* Set starting position of search. */
4116|   start = *start_off;
4117|   
4118|   /* Search through subsequent nodes, wrapping around to the top
4119|      of the Info file until we find the string or return to this
4120|      window''s node and point. */
4121|   while (1)
4122|     {
4123|       result = info_search_in_node_internal (window, node, string, start, dir,
4124|                  case_sensitive, use_regex, start_off);
4125| 
4126|       if (node != window->node)
4127|         free_history_node (node);
4128| 
4129|       if (result == search_invalid)
4130|         return 1;
4131| 
4132|       if (result == search_success)
4133|         {
4134|           if (!echo_area_is_active)
4135|             {
4136|               if (msg)
4137|                 window_message_in_echo_area ("%s", _(msg));
4138|               else
4139|                 window_clear_echo_area ();
4140|             }
4141|           return 0;
4142|         }
4143| 
4144|       if (!search_other_nodes)
4145|         break;
4146| 
4147| search_next_node:
4148|       /* If we''ve searched our starting node twice, there are no matches.
4149|          Bail out.  (We searched the second time in case there were matches 
4150|          before the starting offset.) */
4151|       if (current_tag == starting_tag && !first_time)
4152|         break;
4153|       first_time = 0;
4154|   
4155|       /* Find the next tag that isn''t an anchor.  */
4156|       for (i = current_tag + dir; ; i += dir)
4157|         {
4158|           if (i < 0)
4159|             {
4160|               msg = N_("Search continued from the end of the document");
4161|               i = number_of_tags - 1;
4162|             }
4163|           else if (i == number_of_tags)
4164|             {
4165|               msg = N_("Search continued from the beginning of the document");
4166|               i = 0;
4167|             }
4168|           
4169|           tag = file_buffer->tags[i];
4170|           if (tag->cache.nodelen != 0)
4171|             break;
4172|         }
4173| 
4174|       current_tag = i;
4175| 
4176|       /* Display message when searching a new subfile. */
4177|       if (!echo_area_is_active && tag->filename != subfile_name)
4178|         {
4179|           subfile_name = tag->filename;
4180| 
4181|           window_message_in_echo_area
4182|             (_("Searching subfile %s ..."),
4183|              filename_non_directory (subfile_name));
4184|         }
4185| 
4186|       /* Get a new node to search in. */
4187|       free_matches (&window->matches);
4188| 
4189|       node = info_node_of_tag_fast (file_buffer, &tag);
4190|       if (!node)
4191|         {
4192|           /* If not doing i-search... */
4193|           if (!echo_area_is_active)
4194|             {
4195|               if (info_recent_file_error)
4196|                 {
4197|                   info_error ("%s", info_recent_file_error);
4198|                   return -1;
4199|                 }
4200|               else
4201|                 {
4202|                   info_error (msg_cant_file_node,
4203|                               filename_non_directory (file_buffer->filename),
4204|                               tag->nodename);
4205|                   goto search_next_node;
4206|                 }
4207|             }
4208|         }
4209| 
4210|       if (dir < 0)
4211|         start = tag->cache.nodelen;
4212|       else
4213|         start = 0;
4214| 
4215|       /* Allow C-g to quit the search, failing it if pressed. */
4216|       fill_input_buffer (0); \
4217|       if (info_input_buffer[pop_index] == Control (''g''))
4218|         goto funexit;
4219|     }
4220| 
4221|   /* Not in interactive search. */
4222|   if (!echo_area_is_active)
4223|     info_error ("%s", _("Search failed"));
4224| 
4225| funexit:
4226|   return -1;
4227| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.05008');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (265, 112, 'def26', 'RESOURCE_LEAK', 'texinfo-7.1/install-info/install-info.c:828: alloc_fn: Storage is returned from allocation function "concat".
texinfo-7.1/install-info/install-info.c:828: var_assign: Assigning: "command" = storage returned from "concat(*compression_program, " -d", "")".
texinfo-7.1/install-info/install-info.c:832: leaked_storage: Variable "command" going out of scope leaks the storage it points to.
#  830|   
#  831|         if (fclose (f) < 0)
#  832|->         return 0;
#  833|         f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
#  834|         if (!f)', 'TRUE POSITIVE', 'Memory leak occurs on error path (lines 830-832) where `fclose(f)` fails, causing premature return (line 832) without executing the later `free(command)` (line 844), leaving allocated storage from `concat` (line 828) unfreed.', 'The `concat` function (line 828) allocates storage for the `command` variable, as indicated by `alloc_fn: Storage is returned from allocation function ''concat''`.

The allocated storage is assigned to `command` (line 828), as shown by `var_assign: Assigning: 

On the execution path where `fclose (f) < 0` (line 831), the function immediately returns 0 (line 832) without freeing the allocated storage for `command`.

There is no explicit `free(command)` statement on this specific error-handling path (between lines 830-832), leading to a memory leak.

Although `free(command)` is present in the code (line 844), it is not executed in the scenario where `fclose(f)` fails (line 831), as the function returns prematurely (line 832).

The provided code snippet does not include the implementation of `concat`, but based on its usage, it is clear that it dynamically allocates memory, which is not freed in the described error path.', 'Obtain and examine the implementation of the `concat` function to determine the type of memory allocation used (e.g., malloc, calloc, custom allocator).

Verify if there are any mechanisms in place (outside the provided code snippet) that might free or manage the memory allocated by `concat` before it goes out of scope, especially in the error-handling path.', 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }

code of /shared-data/source/texinfo-7.1/install-info/install-info.c file:
255| char *
256| concat (const char *s1, const char *s2, const char *s3)
257| {
258|   int len1 = strlen (s1), len2 = strlen (s2), len3 = strlen (s3);
259|   char *result = (char *) xmalloc (len1 + len2 + len3 + 1);
260| 
261|   strcpy (result, s1);
262|   strcpy (result + len1, s2);
263|   strcpy (result + len1 + len2, s3);
264|   *(result + len1 + len2 + len3) = 0;
265| 
266|   return result;
267| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.05008');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (266, 112, 'def27', 'OVERRUN', 'texinfo-7.1/info/session.c:3558: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 3556|     default_program_name = program_name_from_file_name (file_name);
# 3557|   
# 3558|->   prompt = xmalloc (strlen (default_program_name) +
# 3559|   		    strlen (invocation_prompt));
# 3560|     sprintf (prompt, invocation_prompt, default_program_name);', 'TRUE POSITIVE', 'Insufficient memory allocation at line 3558 (excluding null-terminator space) for `prompt` buffer, followed by `sprintf` at line 3560, potentially leading to buffer overflow or undefined behavior due to implicit null-terminator addition.', 'The CVE report specifically highlights an issue with allocating insufficient memory for the terminating null of the string at line 3558.

The allocation size calculated at line 3558 only accounts for the combined lengths of `default_program_name` and `invocation_prompt` using `strlen`, which does not include space for the null-terminator (`_x0000_`) required in C strings.

Immediately after allocation, `sprintf` is used at line 3560 to populate the `prompt` buffer, which will append a null-terminator. Without explicit allocation for this null-terminator, the buffer is technically undersized for the operation, potentially leading to a buffer overflow or undefined behavior when the null-terminator is added.

There is no explicit evidence in the provided code snippet that the `xmalloc` function (whose implementation is noted as overridden by a builtin model) automatically includes space for a null-terminator beyond the requested length.

Given the direct correlation between the allocation at line 3558, the lack of explicit null-terminator space allocation, and the subsequent use of `sprintf` which implies the need for such a terminator, there is a clear, demonstrable link to the vulnerability described in the CVE.', 'Obtain and review the implementation details of the `xmalloc` function, as overridden by the builtin model, to determine if it inherently includes space for a null-terminator.

Verify if there are any compiler flags, project settings, or surrounding code that might influence the allocation behavior of `xmalloc` in this specific context.', 0.0000, '*** Source Code Context ***

code of info/session.c file:
3544| DECLARE_INFO_COMMAND (info_goto_invocation_node,
3545|                       _("Find the node describing program invocation"))
3546| {
3547|   const char *invocation_prompt = _("Find Invocation node of [%s]: ");
3548|   char *program_name, *line;
3549|   char *default_program_name, *prompt, *file_name;
3550|   NODE *top_node;
3551|   REFERENCE *invocation_ref;
3552| 
3553|   /* Intuit the name of the program they are likely to want.
3554|      We use the file name of the current Info file as a hint.  */
3555|   file_name = window->node->fullpath;
3556|   default_program_name = program_name_from_file_name (file_name);
3557| 
3558|   prompt = xmalloc (strlen (default_program_name) +
3559| 		    strlen (invocation_prompt));
3560|   sprintf (prompt, invocation_prompt, default_program_name);
3561|   line = info_read_in_echo_area (prompt);
3562|   free (prompt);
3563|   if (!line)
3564|     {
3565|       info_abort_key (window, 0);
3566|       free (default_program_name);
3567|       return;
3568|     }
3569|   if (*line)
3570|     program_name = line;
3571|   else
3572|     program_name = default_program_name;
3573| 
3574|   /* In interactive usage they''d probably expect us to begin looking
3575|      from the Top node.  */
3576|   top_node = info_get_node (file_name, 0);
3577|   if (!top_node)
3578|     info_error (msg_cant_find_node, "Top");
3579| 
3580|   invocation_ref = info_intuit_options_node (top_node, program_name);
3581| 
3582|   /* We''ve got our best shot at the invocation node.  Now select it.  */
3583|   if (invocation_ref)
3584|     {
3585|       info_select_reference (window, invocation_ref);
3586|       info_reference_free (invocation_ref);
3587|     }
3588| 
3589|   free (line);
3590|   free (default_program_name);
3591| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
texinfo-7.1/install-info/install-info.c:1611: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1609|   
# 1610|     ptr++;
# 1611|->   *description = xmalloc (strlen (entry));
# 1612|     (*description)[0] = ''\0'';
# 1613|
(Example-1) Reason Marked as False Positive:
There''s more than sufficient memory as the "description" stores just a substring of entry (entry is in format "NAME. DESCRIPTION")

', '2025-11-17 21:39:07.05008');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (267, 112, 'def28', 'RESOURCE_LEAK', 'texinfo-7.1/install-info/install-info.c:750: alloc_fn: Storage is returned from allocation function "fopen".
texinfo-7.1/install-info/install-info.c:750: var_assign: Assigning: "f" = storage returned from "fopen(*opened_filename, "r")".
texinfo-7.1/install-info/install-info.c:753: noescape: Resource "f" is not freed or pointed-to in "fread". [Note: The source code implementation of the function has been overridden by a builtin model.]
texinfo-7.1/install-info/install-info.c:755: leaked_storage: Variable "f" going out of scope leaks the storage it points to.
#  753|                 nread = fread (data, sizeof (data), 1, f);
#  754|                 if (nread == 0)
#  755|->                 return 0;
#  756|                 goto determine_file_type; /* success */
#  757|               }', 'TRUE POSITIVE', 'Presence of default value indicates a failure to replace it, confirming an error occurred.', 'This is a default value, if it''s not replaced, something went wrong', 'Conduct a thorough review of the error handling mechanisms in `install-info.c`, particularly around lines 750-755.

Verify if there are any conditional statements or error paths that might lead to the proper closure or freeing of the resource `f` before it goes out of scope.

Investigate the program''s behavior when `fread` fails or returns an unexpected value, and how this affects the resource `f`.', 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.05008');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (269, 112, 'def30', 'UNINIT', 'texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''\n'';
# 1126|   }
# 1127|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c: uninit_use: Using uninitialized value "iter.cur.wc".
# ... (omitted for brevity, assuming only relevant parts are compared)
#->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1121: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1125: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1123|   	    win->node->nodelen - point);
# 1124|     mbi_avail (iter);
# 1125|->   return mbi_cur (iter).wc_valid && mbi_cur (iter).wc == ''
'';
# 1126|   }
# 1127|
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1122

', '2025-11-17 21:39:07.050081');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (270, 112, 'def31', 'USE_AFTER_FREE', 'texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:525: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  523|                   {
#  524|                     argv += argc; argc = 0;
#  525|->                   free (*error); *error = 0;
#  526|   
#  527|                     info_reference_free (ref_list[0]);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:525: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  523|                   {
#  524|                     argv += argc; argc = 0;
#  525|->                   free (*error); *error = 0;
#  526|   
#  527|                     info_reference_free (ref_list[0]);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:525: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  523|                   {
#  524|                     argv += argc; argc = 0;
#  525|->                   free (*error); *error = 0;
#  526|   
#  527|                     info_reference_free (ref_list[0]);
(Example-1) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:499: freed_arg: "info_follow_menus" frees "*error".
texinfo-7.1/info/info.c:539: double_free: Calling "free" frees pointer "*error" which has already been freed.
#  537|                                                         ref_list[0]->nodename,
#  538|                                                         0);
#  539|->           free (*error); *error = 0;
#  540|             node_via_menus = info_follow_menus (initial_node, argv, error, 0);
#  541|             if (node_via_menus)
(Example-2) Reason Marked as False Positive:
info_follow_menus() frees "error" on lines 2769, 2791, 2815 but allocates it right again with xasprintf (wrapper to asprintf) on the following lines 2770, 2792, 2816

', '2025-11-17 21:39:07.050081');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (271, 112, 'def32', 'UNINIT', 'texinfo-7.1/info/display.c:492: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.bytes" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc_valid" when calling "mbiter_multi_copy".
#  517|       {
#  518|         int delim;
#  519|->       mbi_copy (&bol_iter, &iter);
#  520|         bol_ref_index = ref_index;
#  521|         bol_match_index = match_index;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/display.c: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/display.c: uninit_use_in_call: Using uninitialized value "iter.cur.bytes" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c: uninit_use_in_call: Using uninitialized value "iter.cur.wc" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c: uninit_use_in_call: Using uninitialized value "iter.cur.wc_valid" when calling "mbiter_multi_copy".
# ... (method calls and line numbers ignored for comparison)
#->       mbi_copy (&bol_iter, &iter);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/display.c:492: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.bytes" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc_valid" when calling "mbiter_multi_copy".
#  517|       {
#  518|         int delim;
#  519|->       mbi_copy (&bol_iter, &iter);
#  520|         bol_ref_index = ref_index;
#  521|         bol_match_index = match_index;
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 513

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1132: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1137: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1135|     mbi_avail (iter);
# 1136|   
# 1137|->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
# 1138|   }
# 1139|
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1133

', '2025-11-17 21:39:07.050082');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (272, 112, 'def33', 'UNINIT', 'texinfo-7.1/install-info/install-info.c:1839: var_decl: Declaring variable "err" without initializer.
texinfo-7.1/install-info/install-info.c:1885: uninit_use: Using uninitialized value "err".
# 1883|             if (sprintf (opt, "--regex=%s", regex) == -1)
# 1884|               err = 1;
# 1885|->           if (!err)
# 1886|               err = argz_add (&argz, &argz_len, opt);
# 1887|             free (opt); opt = NULL;', 'TRUE POSITIVE', 'Variable `err` is used on line 1885 without guaranteed initialization, as its assignment on line 1884 only occurs if `sprintf` on line 1883 returns -1, leaving `err` uninitialized if `sprintf` succeeds.', 'The variable `err` is declared without an initializer on line 1839, as reported.

There is a conditional assignment to `err` on line 1884, but this only occurs if the `sprintf` call on line 1883 returns -1.

The use of `err` on line 1885 is within a conditional statement `if (!err)`, implying its value is being evaluated.

If the `sprintf` call on line 1883 **does not** return -1 (i.e., it succeeds), the value of `err` remains **uninitialized** when it is used on line 1885.

Since there is at least one execution path (successful `sprintf` call) where `err` is used without being initialized, the reported vulnerability (using an uninitialized value) is valid.

Uncertainty about the behavior of `sprintf` or other functions is irrelevant; the code''s explicit operations do not guarantee `err` initialization in all cases before its use.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
1834| static int
1835| munge_old_style_debian_options (int argc, char **argv, 
1836|                                 int *new_argc, char ***new_argv)
1837| {
1838|   char *opt = NULL;
1839|   int i, err;
1840|   char *argz = NULL;
1841|   size_t argz_len = 0;
1842|   const char *regex, *title;
1843|   int munge = 0;
1844| 
1845|   /* Flip through the options to detect the old `--section REGEX TITLE'' 
1846|      syntax */
1847|   for (i = 0; i < argc; i++)
1848|     {
1849|       if (strcmp (argv[i], "--section") == 0)
1850|         {
1851|           FILE *fileptr;
1852|           /* Go forward one arg and obtain the REGEX. */
1853|           if (i + 1 < argc)
1854|             i++;
1855|           else
1856|             return -1;
1857|           regex = argv[i];
1858|           /* Go forward another arg and obtain the TITLE. */
1859|           if (i + 1 < argc)
1860|             i++;
1861|           else
1862|             return -1;
1863|           title = argv[i];
1864|           /* When the title starts with a `-'' it''s probably an option,
1865|              and not a title. */
1866|           if (title[0] == ''-'')
1867|             break;
1868|           /* When the title is a filename it''s probably an Info file, or
1869|              a dir file, and not a title. */
1870|           fileptr = fopen (title, "r");
1871|           if (fileptr)
1872|             {
1873|               fclose (fileptr);
1874|               break;
1875|             }
1876|           /* Okay, it looks like we''re using the old debian syntax 
1877|              for --section. */
1878|           munge = 1;
1879|         
1880|           /* Okay, we munge the options to look like this:
1881|              --regex=REGEX --section=TITLE --add-once */
1882|           opt = xmalloc (strlen (regex) + sizeof ("--regex="));
1883|           if (sprintf (opt, "--regex=%s", regex) == -1)
1884|             err = 1;
1885|           if (!err)
1886|             err = argz_add (&argz, &argz_len, opt);
1887|           free (opt); opt = NULL;
1888| 
1889|           opt = xmalloc (strlen (title) + sizeof ("--section="));
1890|           if (sprintf (opt, "--section=%s", title) == -1)
1891|             err = 1;
1892|           if (!err)
1893|             err = argz_add (&argz, &argz_len, opt);
1894|           free (opt); opt = NULL;
1895| 
1896|           if (!err)
1897|             err = argz_add (&argz, &argz_len, "--add-once");
1898|         }
1899|       else
1900|         err = argz_add (&argz, &argz_len, argv[i]); 
1901|       if (err)
1902|         return -1;
1903|     }
1904| 
1905|   if (munge)
1906|     {
1907|       *new_argc = argz_count (argz, argz_len);
1908|       *new_argv = xmalloc ((*new_argc + 1) * sizeof (char *));
1909| 
1910|       opt = NULL; i = 0;
1911|       while ((opt = argz_next (argz, argz_len, opt)))
1912|         {
1913|           (*new_argv)[i] = xstrdup (opt);
1914|           i++;
1915|         }
1916|       (*new_argv)[*new_argc] = NULL;
1917|     }
1918|   free (argz);
1919|   return munge;
1920| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/session.c:1132: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/session.c:1137: uninit_use: Using uninitialized value "iter.cur.wc_valid".
# 1135|     mbi_avail (iter);
# 1136|   
# 1137|->   return mbi_cur (iter).wc_valid && iswalnum (mbi_cur (iter).wc);
# 1138|   }
# 1139|
(Example-1) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 1133

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
texinfo-7.1/info/display.c:492: var_decl: Declaring variable "iter" without initializer.
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.bytes" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc" when calling "mbiter_multi_copy".
texinfo-7.1/info/display.c:519: uninit_use_in_call: Using uninitialized value "iter.cur.wc_valid" when calling "mbiter_multi_copy".
#  517|       {
#  518|         int delim;
#  519|->       mbi_copy (&bol_iter, &iter);
#  520|         bol_ref_index = ref_index;
#  521|         bol_match_index = match_index;
(Example-2) Reason Marked as False Positive:
"iter" is inicialized with mbi_init() on line 513

', '2025-11-17 21:39:07.050082');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (329, 98, 'def13', 'OVERRUN', 'audit-4.0/lib/netlink.c:219: cond_at_least: Checking "size" implies that "size" is at least 1 on the true branch.
audit-4.0/lib/netlink.c:220: overrun-buffer-arg: Overrunning struct type nlmsghdr of 16 bytes by passing it to a function which accesses it at byte offset 16 using argument "size" (which evaluates to 1). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  218|   	req.nlh.nlmsg_seq = sequence;
#  219|   	if (size && data)
#  220|-> 		memcpy(NLMSG_DATA(&req.nlh), data, size);
#  221|   	memset(&addr, 0, sizeof(addr));
#  222|   	addr.nl_family = AF_NETLINK;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/lib/netlink.c:219: cond_at_least: Checking "size" implies that "size" is at least 1 on the true branch.
audit-4.0/lib/netlink.c:220: overrun-buffer-arg: Overrunning struct type nlmsghdr of 16 bytes by passing it to a function which accesses it at byte offset 16 using argument "size" (which evaluates to 1).
#  218|    req.nlh.nlmsg_seq = sequence;
#  219|    if (size && data)
#  220|->     memcpy(NLMSG_DATA(&req.nlh), data, size);
#  221|    memset(&addr, 0, sizeof(addr));
#  222|    addr.nl_family = AF_NETLINK;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/lib/netlink.c:219: cond_at_least: Checking "size" implies that "size" is at least 1 on the true branch.
audit-4.0/lib/netlink.c:220: overrun-buffer-arg: Overrunning struct type nlmsghdr of 16 bytes by passing it to a function which accesses it at byte offset 16 using argument "size" (which evaluates to 1). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  218|   	req.nlh.nlmsg_seq = sequence;
#  219|   	if (size && data)
#  220|-> 		memcpy(NLMSG_DATA(&req.nlh), data, size);
#  221|   	memset(&addr, 0, sizeof(addr));
#  222|   	addr.nl_family = AF_NETLINK;
(Example-1) Reason Marked as False Positive:
This turned out to be a false positive, as per upstream discussion
https://github.com/linux-audit/audit-userspace/pull/395

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/auparse/auparse.c:514: strlen_assign: Setting variable "len" to the return value of strlen called with argument "buf".
audit-4.0/auparse/auparse.c:515: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  513|   				goto bad_exit;
#  514|   			len = strlen(buf);
#  515|-> 			if (databuf_init(&au->databuf, len,
#  516|   					 DATABUF_FLAG_PRESERVE_HEAD) < 0)
#  517|   				goto bad_exit;
(Example-2) Reason Marked as False Positive:
Data inside databuf does not need to be null-terminated because the length is tracked internally, memory copy/move operations are performed based on the actual length.

', '2025-11-17 21:39:07.076109');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (273, 112, 'def34', 'INTEGER_OVERFLOW', 'texinfo-7.1/info/makedoc.c:299: tainted_data_argument: The check "offset < file_size - decl_len" contains the tainted expression "file_size - decl_len" which causes "offset" to be considered tainted.
texinfo-7.1/info/makedoc.c:309: overflow: The expression "offset += decl_len" is deemed overflowed because at least one of its arguments has overflowed.
texinfo-7.1/info/makedoc.c:310: assign: Assigning: "point" = "offset".
texinfo-7.1/info/makedoc.c:347: assign: Assigning: "offset" = "point".
texinfo-7.1/info/makedoc.c:348: overflow: The expression "offset - point" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:348: overflow: The expression "1L + (offset - point)" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:348: overflow_sink: "1L + (offset - point)", which might have underflowed, is passed to "xmalloc(1L + (offset - point))". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  346|         /* Now looking at name of function.  Get it. */
#  347|         for (offset = point; buffer[offset] != '',''; offset++);
#  348|->       func = xmalloc (1 + (offset - point));
#  349|         strncpy (func, buffer + point, offset - point);
#  350|         func[offset - point] = ''\0'';', 'TRUE POSITIVE', 'Potential vulnerabilities arise from tainted data usage (line 299), unmitigated overflow risks in `offset += decl_len` (line 309), and underflow concerns in `1L + (offset - point)` (line 348) passed to `xmalloc`, all stemming from dependent, user-data-influenced variables `offset` and `point` without explicit sanitization or bounds checking.', '1. **Tainted Data Argument**: At line 299, the check `offset < file_size - decl_len` uses `file_size - decl_len`, which is considered tainted. This taint is propagated to `offset` (CVE report). **No explicit sanitization or validation** of `file_size` or `decl_len` is shown in the provided code to mitigate this concern.

2. **Potential Overflow at Line 309**: The expression `offset += decl_len` is flagged for overflow because one of its arguments has overflowed. Although the code doesn''t explicitly show the overflow occurring, the lack of bounds checking for `decl_len` before addition to `offset` leaves room for potential overflow, especially since `offset` is later used in memory allocation (line 348).

3. **Assignment and Reassignment of `offset` and `point`**: The assignments `point = offset` (line 310) and `offset = point` (line 347) create a dependency chain where the validity of `offset` directly affects `point` and vice versa. Any issue with `offset` (like overflow) could thus impact `point`.

4. **Underflow Concern at Line 348**: The expressions `offset - point` and `1L + (offset - point)` are deemed underflowed. Given that `offset` and `point` are reassigned and dependent (as noted in justification 3), and considering the context of these variables in a loop iterating through a buffer (lines 347-348), there''s a plausible execution path where `offset` could be less than `point`, leading to underflow.

5. **Overflow Sink at Line 348**: The potentially underflowed expression `1L + (offset - point)` is passed to `xmalloc()`. Even if the underflow doesn''t occur, the direct allocation based on user/data-dependent variables (`offset` and `point`) without explicit bounds checking for the allocation size raises concerns about the robustness against overflow/underflow attacks, especially given the earlier warnings about `offset`''s integrity.', 'Provide the full implementation or detailed specification of `xmalloc()` to assess its handling of potentially underflowed allocation sizes.

Include any input validation or sanitization mechanisms for `file_size` and `decl_len` that may be present elsewhere in the codebase.

Supply additional context or constraints on the buffer size and the loop iterating through it (lines 347-348) to better evaluate underflow and overflow risks.

Conduct a thorough examination of all execution paths for the dependencies between `offset` and `point`, including edge cases.', 0.0000, '*** Source Code Context ***

code of info/makedoc.c file:
258| static void
259| process_one_file (char *filename, FILE *doc_stream, FILE *funs_stream)
260| {
261|   int descriptor, decl_len;
262|   char *buffer, *decl_str;
263|   struct stat finfo;
264|   long offset;
265|   long file_size;
266|   EMACS_TAG_BLOCK *block;
267| 
268|   if (stat (filename, &finfo) == -1)
269|     fatal_file_error (filename);
270| 
271|   descriptor = open (filename, O_RDONLY, 0666);
272| 
273|   if (descriptor == -1)
274|     fatal_file_error (filename);
275| 
276|   file_size = (long) finfo.st_size;
277|   buffer = xmalloc (1 + file_size);
278|   /* On some systems, the buffer will actually contain
279|      less characters than the full file''s size, because
280|      the CR characters are removed from line endings.  */
281|   file_size = read (descriptor, buffer, file_size);
282|   close (descriptor);
283| 
284|   offset = 0;
285|   decl_str = DECLARATION_STRING;
286|   decl_len = strlen (decl_str);
287| 
288|   block = make_emacs_tag_block (filename);
289| 
290|   while (1)
291|     {
292|       long point = 0;
293|       long line_start = 0;
294|       int line_number = 0;
295| 
296|       char *func, *doc;
297|       char *func_name;
298| 
299|       for (; offset < (file_size - decl_len); offset++)
300|         {
301|           if (buffer[offset] == ''
'')
302|             {
303|               line_number++;
304|               line_start = offset + 1;
305|             }
306| 
307|           if (strncmp (buffer + offset, decl_str, decl_len) == 0)
308|             {
309|               offset += decl_len;
310|               point = offset;
311|               break;
312|             }
313|         }
314| 
315|       if (!point)
316|         break;
317| 
318|       /* Skip forward until we find the open paren. */
319|       while (point < file_size)
320|         {
321|           if (buffer[point] == ''
'')
322|             {
323|               line_number++;
324|               line_start = point + 1;
325|             }
326|           else if (buffer[point] == ''('')
327|             break;
328| 
329|           point++;
330|         }
331| 
332|       while (point++ < file_size)
333|         {
334|           if (!whitespace_or_newline (buffer[point]))
335|             break;
336|           else if (buffer[point] == ''
'')
337|             {
338|               line_number++;
339|               line_start = point + 1;
340|             }
341|         }
342| 
343|       if (point >= file_size)
344|         break;
345| 
346|       /* Now looking at name of function.  Get it. */
347|       for (offset = point; buffer[offset] != '',''; offset++);
348|       func = xmalloc (1 + (offset - point));
349|       strncpy (func, buffer + point, offset - point);
350|       func[offset - point] = ''\0'';
351| 
352|       /* Remember this tag in the current block. */
353|       {
354|         char *tag_name;
355| 
356|         tag_name = xmalloc (1 + (offset - line_start));
357|         strncpy (tag_name, buffer + line_start, offset - line_start);
358|         tag_name[offset - line_start] = ''\0'';
359|         add_tag_to_block (block, tag_name, line_number, point);
360|       }
361| 
362|       /* Generate the user-visible function name from the function''s name. */
363|       {
364|         register int i;
365|         char *name_start;
366| 
367|         name_start = func;
368| 
369|         if (strncmp (name_start, "info_", 5) == 0)
370|           name_start += 5;
371| 
372|         func_name = xstrdup (name_start);
373| 
374|         /* Fix up "ea" commands. */
375|         if (strncmp (func_name, "ea_", 3) == 0)
376|           {
377|             char *temp_func_name;
378| 
379|             temp_func_name = xmalloc (10 + strlen (func_name));
380|             strcpy (temp_func_name, "echo_area_");
381|             strcat (temp_func_name, func_name + 3);
382|             free (func_name);
383|             func_name = temp_func_name;
384|           }
385| 
386|         for (i = 0; func_name[i]; i++)
387|           if (func_name[i] == ''_'')
388|             func_name[i] = ''-'';
389|       }
390| 
391|       /* Find doc string. */
392|       point = offset + 1;
393| 
394|       while (point < file_size)
395|         {
396|           if (buffer[point] == ''
'')
397|             {
398|               line_number++;
399|               line_start = point + 1;
400|             }
401| 
402|           if (buffer[point] == ''"'')
403|             break;
404|           else
405|             point++;
406|         }
407| 
408|       offset = point + 1;
409| 
410|       while (offset < file_size)
411|         {
412|           if (buffer[offset] == ''
'')
413|             {
414|               line_number++;
415|               line_start = offset + 1;
416|             }
417| 
418|           if (buffer[offset] == ''\\'')
419|             offset += 2;
420|           else if (buffer[offset] == ''"'')
421|             break;
422|           else
423|             offset++;
424|         }
425| 
426|       offset++;
427|       if (offset >= file_size)
428|         {
429|           free (func_name);
430|           free (func);
431|           break;
432|         }
433| 
434|       doc = xmalloc (1 + (offset - point));
435|       strncpy (doc, buffer + point, offset - point);
436|       doc[offset - point] = ''\0'';
437| 
438|       fprintf (doc_stream,
439|           "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },
",
440|           func, func_name, doc);
441| 
442|       free (func_name);
443| 
444|       fprintf (funs_stream, "#define A_%s %u
", func, next_func_key());
445|       fprintf (funs_stream,
446|           "extern void %s (WINDOW *window, int count);
",
447|           func);
448|       free (func);
449|       free (doc);
450|     }
451|   free (buffer);
452| 
453|   /* If we created any tags, remember this file on our global list.  Otherwise,
454|      free the memory already allocated to it. */
455|   if (block->entries)
456|     add_pointer_to_array (block, emacs_tags_index, emacs_tags,
457|                           emacs_tags_slots, 10);
458|   else
459|     {
460|       free (block->filename);
461|       free (block);
462|     }
463| }


*** Examples ***
', '2025-11-17 21:39:07.050082');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (274, 112, 'def35', 'RESOURCE_LEAK', 'texinfo-7.1/info/filesys.c:155: alloc_fn: Storage is returned from allocation function "tilde_expand_word".
texinfo-7.1/info/filesys.c:155: var_assign: Assigning: "expanded_dirname" = storage returned from "tilde_expand_word(dirname)".
texinfo-7.1/info/filesys.c:156: var_assign: Assigning: "dirname" = "expanded_dirname".
texinfo-7.1/info/filesys.c:157: leaked_storage: Variable "expanded_dirname" going out of scope leaks the storage it points to.
texinfo-7.1/info/filesys.c:159: noescape: Resource "dirname" is not freed or pointed-to in "info_add_extension".
texinfo-7.1/info/filesys.c:172: leaked_storage: Variable "dirname" going out of scope leaks the storage it points to.
#  170|               }
#  171|             else
#  172|->             return with_extension;
#  173|           }
#  174|       }', 'TRUE POSITIVE', 'Storage allocated by `tilde_expand_word` (line 155) is not explicitly freed before going out of scope (lines 157, 172), and its fate within `info_add_extension` (line 159) is unknown, directly supporting the CWE-772 Resource Leak vulnerability.', 'The `tilde_expand_word` function allocates storage for `expanded_dirname` (line 155), which is then assigned to `dirname` (line 156).

There is no explicit `free` or reuse of the storage pointed to by `expanded_dirname` before it goes out of scope (line 157), indicating a potential memory leak.

The `dirname` variable, now pointing to the allocated storage, is passed to `info_add_extension` (line 159) but there''s no evidence within the provided code that this function frees or retains the pointer, suggesting another potential memory leak.

Upon returning from the function (line 172), `dirname` (and thus the allocated storage) goes out of scope without being freed, reinforcing the memory leak concern.

No code within the provided context explicitly frees the storage allocated by `tilde_expand_word`, aligning with the CWE-772 (Resource Leak) vulnerability described in the CVE report.

Uncertainty about the behavior of `info_add_extension` could suggest a need for further investigation, but based solely on the provided code, the explicit allocation without corresponding deallocation supports the TRUE POSITIVE finding.', 'Obtain and analyze the implementation of `info_add_extension` to determine if it frees or retains the pointer to the allocated storage.

Verify if there are any other execution paths in `filesys.c` that could lead to the deallocation of the storage allocated by `tilde_expand_word`.

Check for any memory management functions (e.g., custom allocators/deallocators) that might be used within the `texinfo-7.1/info` project that could affect the storage''s lifetime.', 0.0000, '*** Source Code Context ***

code of info/filesys.c file:
127| char *
128| info_file_find_next_in_path (char *filename, int *path_index, struct stat *finfo)
129| {
130|   struct stat dummy;
131| 
132|   /* Used for output of stat in case the caller doesn''t care about
133|      its value. */
134|   if (!finfo)
135|     finfo = &dummy;
136| 
137|   /* Reject ridiculous cases up front, to prevent infinite recursion
138|      later on.  E.g., someone might say "info ''(.)foo''"...  */
139|   if (!*filename || STREQ (filename, ".") || STREQ (filename, ".."))
140|     return NULL;
141| 
142|   while (1)
143|     {
144|       char *dirname, *with_extension = 0;
145| 
146|       dirname = infopath_next (path_index);
147|       if (!dirname)
148|         break;
149| 
150|       debug(1, (_("looking for file %s in %s"), filename, dirname));
151| 
152|       /* Expand a leading tilde if one is present. */
153|       if (*dirname == ''~'')
154|         {
155|           char *expanded_dirname = tilde_expand_word (dirname);
156|           dirname = expanded_dirname;
157|         }
158| 
159|       with_extension = info_add_extension (dirname, filename, finfo);
160| 
161|       if (with_extension)
162|         {
163|           if (!IS_ABSOLUTE (with_extension))
164|             {
165|               /* Prefix "./" to it. */
166|               char *s;
167|               xasprintf (&s, "%s%s", "./", with_extension);
168|               free (with_extension);
169|               return s;
170|             }
171|           else
172|             return with_extension;
173|         }
174|     }
175|   return NULL;
176| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050083');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (275, 112, 'def36', 'RESOURCE_LEAK', 'texinfo-7.1/info/filesys.c:155: alloc_fn: Storage is returned from allocation function "tilde_expand_word".
texinfo-7.1/info/filesys.c:155: var_assign: Assigning: "expanded_dirname" = storage returned from "tilde_expand_word(dirname)".
texinfo-7.1/info/filesys.c:156: var_assign: Assigning: "dirname" = "expanded_dirname".
texinfo-7.1/info/filesys.c:157: leaked_storage: Variable "expanded_dirname" going out of scope leaks the storage it points to.
texinfo-7.1/info/filesys.c:159: noescape: Resource "dirname" is not freed or pointed-to in "info_add_extension".
texinfo-7.1/info/filesys.c:174: leaked_storage: Variable "dirname" going out of scope leaks the storage it points to.
#  172|               return with_extension;
#  173|           }
#  174|->     }
#  175|     return NULL;
#  176|   }', 'TRUE POSITIVE', 'Storage allocated by `tilde_expand_word` for `expanded_dirname` (line 155) is not explicitly freed, leading to confirmed memory leaks when `expanded_dirname` (line 157) and its alias `dirname` (line 174) go out of scope.', 'The `tilde_expand_word` function allocates storage for `expanded_dirname` (line 155), which is then assigned to `dirname` (line 156).

There is no explicit `free` or reuse of the storage pointed to by `expanded_dirname` before it goes out of scope (line 157), indicating a potential memory leak.

After reassignment, `dirname` (now pointing to the same storage as `expanded_dirname`) is passed to `info_add_extension` (line 159) without being freed or having its pointer persisted, suggesting another potential memory leak.

Upon reaching the end of the scope (line 174), `dirname` (and thus the storage originally allocated for `expanded_dirname`) is confirmed to leak as it goes out of scope without being freed.

No code within the provided context explicitly frees the storage allocated by `tilde_expand_word`, fulfilling the CWE-772 (Resource Leak) criteria described in the CVE.

Uncertainty about the behavior of `info_add_extension` does not negate the leak identified at lines 157 and 174, as the leak is confirmed upon scope exit regardless of `info_add_extension`''s handling.', NULL, 0.0000, '*** Source Code Context ***

code of info/filesys.c file:
127| char *
128| info_file_find_next_in_path (char *filename, int *path_index, struct stat *finfo)
129| {
130|   struct stat dummy;
131| 
132|   /* Used for output of stat in case the caller doesn''t care about
133|      its value. */
134|   if (!finfo)
135|     finfo = &dummy;
136| 
137|   /* Reject ridiculous cases up front, to prevent infinite recursion
138|      later on.  E.g., someone might say "info ''(.)foo''"...  */
139|   if (!*filename || STREQ (filename, ".") || STREQ (filename, ".."))
140|     return NULL;
141| 
142|   while (1)
143|     {
144|       char *dirname, *with_extension = 0;
145| 
146|       dirname = infopath_next (path_index);
147|       if (!dirname)
148|         break;
149| 
150|       debug(1, (_("looking for file %s in %s"), filename, dirname));
151| 
152|       /* Expand a leading tilde if one is present. */
153|       if (*dirname == ''~'')
154|         {
155|           char *expanded_dirname = tilde_expand_word (dirname);
156|           dirname = expanded_dirname;
157|         }
158| 
159|       with_extension = info_add_extension (dirname, filename, finfo);
160| 
161|       if (with_extension)
162|         {
163|           if (!IS_ABSOLUTE (with_extension))
164|             {
165|               /* Prefix "./" to it. */
166|               char *s;
167|               xasprintf (&s, "%s%s", "./", with_extension);
168|               free (with_extension);
169|               return s;
170|             }
171|           else
172|             return with_extension;
173|         }
174|     }
175|   return NULL;
176| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050083');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (276, 112, 'def37', 'INTEGER_OVERFLOW', 'texinfo-7.1/info/makedoc.c:299: tainted_data_argument: The check "offset < file_size - decl_len" contains the tainted expression "file_size - decl_len" which causes "offset" to be considered tainted.
texinfo-7.1/info/makedoc.c:309: overflow: The expression "offset += decl_len" is deemed overflowed because at least one of its arguments has overflowed.
texinfo-7.1/info/makedoc.c:310: assign: Assigning: "point" = "offset".
texinfo-7.1/info/makedoc.c:347: assign: Assigning: "offset" = "point".
texinfo-7.1/info/makedoc.c:357: overflow: The expression "offset - line_start" is deemed underflowed because at least one of its arguments has underflowed.
texinfo-7.1/info/makedoc.c:357: overflow_sink: "offset - line_start", which might have underflowed, is passed to "strncpy(tag_name, buffer + line_start, offset - line_start)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  355|   
#  356|           tag_name = xmalloc (1 + (offset - line_start));
#  357|->         strncpy (tag_name, buffer + line_start, offset - line_start);
#  358|           tag_name[offset - line_start] = ''\0'';
#  359|           add_tag_to_block (block, tag_name, line_number, point);', 'TRUE POSITIVE', 'Potential buffer overflow/underflow via `strncpy()` at Line 357, where an underflowed/overflowed `offset - line_start` (long) is passed as an unsigned size_t, potentially leading to undefined behavior, directly correlating with the CVE''s described vulnerability.', '1. **Tainted Data Argument (Line 299)**: The expression `file_size - decl_len` is indeed tainted because `file_size` is derived from user-input (file size, Line 276) and `decl_len` is a constant. However, the concern here is the potential for `offset` to exceed `file_size - decl_len` due to this taint. **Uncertainty remains** about the impact without further context on `decl_len`''s value, but given the direct use of user-influenced data, caution leans towards a potential issue.

2. **Overflow at Line 309**: The expression `offset += decl_len` is flagged for overflow. Given that `offset` is a `long` (Line 264) and `decl_len` is an `int` (Line 261), the sum could theoretically overflow if `offset` is near the maximum value for `long` and `decl_len` is sufficiently large. **No explicit bounds checking** is shown in the provided code to prevent this.

3. **Assignment and Reassignment (Lines 310, 347)**: While these assignments themselves are not vulnerabilities, they propagate the potentially overflowed `offset` value, ensuring that any subsequent issue with `offset` is preserved and potentially exacerbated.

4. **Underflow and Overflow Sink (Line 357)**: The expression `offset - line_start` is deemed underflowed, and this value is passed to `strncpy()`. **Critical**: If `offset` is indeed underflowed (or overflows in the subtraction), passing this to `strncpy()` as the third argument could lead to **buffer overflow** or **undefined behavior**, as `strncpy()` expects a size_t (unsigned) for its third parameter. Given `offset` and `line_start` are `long`, a negative result (underflow) would be interpreted as a large unsigned value, potentially overflowing the `tag_name` buffer.

5. **Direct Correlation to CVE Description**: The provided code snippets directly correlate with the CVE report''s concerns, showing potential vulnerabilities in handling user-influenced data (`file_size`) and in arithmetic operations that could lead to buffer overflows or underflows.', 'Provide the exact data types for `offset` and `decl_len` as defined in the compilation context of `makedoc.c`.

Clarify the value range of `decl_len` to assess the likelihood of `offset` exceeding `file_size - decl_len`.

Verify the presence and effectiveness of implicit or explicit bounds checking for the `offset + decl_len` operation in the broader code context.

Determine the possible range of `offset` and `line_start` values to confirm the feasibility of underflow/overflow in `offset - line_start`.

Inspect the implementation of `xmalloc` to ensure it handles allocation requests based on potentially tainted or overflowed values securely.', 0.0000, '*** Source Code Context ***

code of info/makedoc.c file:
258| static void
259| process_one_file (char *filename, FILE *doc_stream, FILE *funs_stream)
260| {
261|   int descriptor, decl_len;
262|   char *buffer, *decl_str;
263|   struct stat finfo;
264|   long offset;
265|   long file_size;
266|   EMACS_TAG_BLOCK *block;
267| 
268|   if (stat (filename, &finfo) == -1)
269|     fatal_file_error (filename);
270| 
271|   descriptor = open (filename, O_RDONLY, 0666);
272| 
273|   if (descriptor == -1)
274|     fatal_file_error (filename);
275| 
276|   file_size = (long) finfo.st_size;
277|   buffer = xmalloc (1 + file_size);
278|   /* On some systems, the buffer will actually contain
279|      less characters than the full file''s size, because
280|      the CR characters are removed from line endings.  */
281|   file_size = read (descriptor, buffer, file_size);
282|   close (descriptor);
283| 
284|   offset = 0;
285|   decl_str = DECLARATION_STRING;
286|   decl_len = strlen (decl_str);
287| 
288|   block = make_emacs_tag_block (filename);
289| 
290|   while (1)
291|     {
292|       long point = 0;
293|       long line_start = 0;
294|       int line_number = 0;
295| 
296|       char *func, *doc;
297|       char *func_name;
298| 
299|       for (; offset < (file_size - decl_len); offset++)
300|         {
301|           if (buffer[offset] == ''
'')
302|             {
303|               line_number++;
304|               line_start = offset + 1;
305|             }
306| 
307|           if (strncmp (buffer + offset, decl_str, decl_len) == 0)
308|             {
309|               offset += decl_len;
310|               point = offset;
311|               break;
312|             }
313|         }
314| 
315|       if (!point)
316|         break;
317| 
318|       /* Skip forward until we find the open paren. */
319|       while (point < file_size)
320|         {
321|           if (buffer[point] == ''
'')
322|             {
323|               line_number++;
324|               line_start = point + 1;
325|             }
326|           else if (buffer[point] == ''('')
327|             break;
328| 
329|           point++;
330|         }
331| 
332|       while (point++ < file_size)
333|         {
334|           if (!whitespace_or_newline (buffer[point]))
335|             break;
336|           else if (buffer[point] == ''
'')
337|             {
338|               line_number++;
339|               line_start = point + 1;
340|             }
341|         }
342| 
343|       if (point >= file_size)
344|         break;
345| 
346|       /* Now looking at name of function.  Get it. */
347|       for (offset = point; buffer[offset] != '',''; offset++);
348|       func = xmalloc (1 + (offset - point));
349|       strncpy (func, buffer + point, offset - point);
350|       func[offset - point] = ''\0'';
351| 
352|       /* Remember this tag in the current block. */
353|       {
354|         char *tag_name;
355| 
356|         tag_name = xmalloc (1 + (offset - line_start));
357|         strncpy (tag_name, buffer + line_start, offset - line_start);
358|         tag_name[offset - line_start] = ''\0'';
359|         add_tag_to_block (block, tag_name, line_number, point);
360|       }
361| 
362|       /* Generate the user-visible function name from the function''s name. */
363|       {
364|         register int i;
365|         char *name_start;
366| 
367|         name_start = func;
368| 
369|         if (strncmp (name_start, "info_", 5) == 0)
370|           name_start += 5;
371| 
372|         func_name = xstrdup (name_start);
373| 
374|         /* Fix up "ea" commands. */
375|         if (strncmp (func_name, "ea_", 3) == 0)
376|           {
377|             char *temp_func_name;
378| 
379|             temp_func_name = xmalloc (10 + strlen (func_name));
380|             strcpy (temp_func_name, "echo_area_");
381|             strcat (temp_func_name, func_name + 3);
382|             free (func_name);
383|             func_name = temp_func_name;
384|           }
385| 
386|         for (i = 0; func_name[i]; i++)
387|           if (func_name[i] == ''_'')
388|             func_name[i] = ''-'';
389|       }
390| 
391|       /* Find doc string. */
392|       point = offset + 1;
393| 
394|       while (point < file_size)
395|         {
396|           if (buffer[point] == ''
'')
397|             {
398|               line_number++;
399|               line_start = point + 1;
400|             }
401| 
402|           if (buffer[point] == ''"'')
403|             break;
404|           else
405|             point++;
406|         }
407| 
408|       offset = point + 1;
409| 
410|       while (offset < file_size)
411|         {
412|           if (buffer[offset] == ''
'')
413|             {
414|               line_number++;
415|               line_start = offset + 1;
416|             }
417| 
418|           if (buffer[offset] == ''\\'')
419|             offset += 2;
420|           else if (buffer[offset] == ''"'')
421|             break;
422|           else
423|             offset++;
424|         }
425| 
426|       offset++;
427|       if (offset >= file_size)
428|         {
429|           free (func_name);
430|           free (func);
431|           break;
432|         }
433| 
434|       doc = xmalloc (1 + (offset - point));
435|       strncpy (doc, buffer + point, offset - point);
436|       doc[offset - point] = ''\0'';
437| 
438|       fprintf (doc_stream,
439|           "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },
",
440|           func, func_name, doc);
441| 
442|       free (func_name);
443| 
444|       fprintf (funs_stream, "#define A_%s %u
", func, next_func_key());
445|       fprintf (funs_stream,
446|           "extern void %s (WINDOW *window, int count);
",
447|           func);
448|       free (func);
449|       free (doc);
450|     }
451|   free (buffer);
452| 
453|   /* If we created any tags, remember this file on our global list.  Otherwise,
454|      free the memory already allocated to it. */
455|   if (block->entries)
456|     add_pointer_to_array (block, emacs_tags_index, emacs_tags,
457|                           emacs_tags_slots, 10);
458|   else
459|     {
460|       free (block->filename);
461|       free (block);
462|     }
463| }


*** Examples ***
', '2025-11-17 21:39:07.050083');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (330, 98, 'def14', 'INTEGER_OVERFLOW', 'audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: tainted_data_return: Called function "write(sk, buf, len)", and a possible return value may be less than zero.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1249: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: overflow_sink: "len", which might have overflowed, is passed to "write(sk, buf, len)".
# 1236|           while (len > 0) {
# 1237|                   do {
# 1238|->                         r = write(sk, buf, len);
# 1239|                   } while (r < 0 && errno == EINTR);
# 1240|                   if (r < 0) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/audisp/plugins/remote/audisp-remote.c: tainted_data_return: Called function "write(sk, buf, len)", and a possible return value may be less than zero.
audit-4.0/audisp/plugins/remote/audisp-remote.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/audisp/plugins/remote/audisp-remote.c: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/audisp/plugins/remote/audisp-remote.c: overflow_sink: "len", which might have overflowed, is passed to "write(sk, buf, len)".
#           while (len > 0) {
#                   do {
#->                         r = write(sk, buf, len);
#                   } while (r < 0 && errno == EINTR);
#                   if (r < 0) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: tainted_data_return: Called function "write(sk, buf, len)", and a possible return value may be less than zero.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1249: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/audisp/plugins/remote/audisp-remote.c:1238: overflow_sink: "len", which might have overflowed, is passed to "write(sk, buf, len)".
# 1236|           while (len > 0) {
# 1237|                   do {
# 1238|->                         r = write(sk, buf, len);
# 1239|                   } while (r < 0 && errno == EINTR);
# 1240|                   if (r < 0) {
(Example-1) Reason Marked as False Positive:
If the return value of write() is less than zero, it is handled appropriately, ensuring that it will not be negative if write() is called again

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:739: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr += r" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow: The expression "8970U - io->bufptr" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow_sink: "8970U - io->bufptr", which might have underflowed, is passed to "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  593|   	   data.  */
#  594|   read_more:
#  595|-> 	r = read (io->io.fd,
#  596|   		  io->buffer + io->bufptr,
#  597|   		  MAX_AUDIT_MESSAGE_LENGTH - io->bufptr);
(Example-2) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again

', '2025-11-17 21:39:07.07611');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (277, 112, 'def38', 'RESOURCE_LEAK', 'texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|    
# 3686|   /* **************************************************************** */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
texinfo-7.1/info/session.c:3660: alloc_fn: Storage is returned from allocation function "info_read_in_echo_area".
texinfo-7.1/info/session.c:3660: var_assign: Assigning: "line" = storage returned from "info_read_in_echo_area(dcgettext(NULL, "Find file: ", 5))".
texinfo-7.1/info/session.c:3684: leaked_storage: Variable "line" going out of scope leaks the storage it points to.
# 3682|         free (line);
# 3683|       }
# 3684|-> }
# 3685|   _x000C_
# 3686|   /* **************************************************************** */
(Example-1) Reason Marked as False Positive:
info_read_in_echo_area() reads string and returns pointer to it or NULL. If "line" is NULL the function returns on line 3664, otherwise "line" is free''d on line 3682

', '2025-11-17 21:39:07.050084');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (278, 112, 'def39', 'VARARGS', 'texinfo-7.1/info/util.c:38: va_init: Initializing va_list "v".
texinfo-7.1/info/util.c:39: missing_va_end: "va_end" was not called for "v".
#   37|     va_list v;
#   38|     va_start (v, template);
#   39|->   return xvasprintf (ptr, template, v);
#   40|   }
#   41|', 'TRUE POSITIVE', 'Lack of `va_end` after `va_start` on lines 38-39 introduces a potential vulnerability, as `va_end` is not called within the provided `xasprintf` function or its context, leading to possible undefined behavior due to improper `va_list` cleanup.', 'The CVE report explicitly states ''missing_va_end: "va_end" was not called for "v"'' (line 39), indicating a potential vulnerability due to the lack of `va_end` after `va_start`.

Code analysis confirms this: `va_start (v, template);` is called on line 38, initializing the `va_list v`.

Immediately after, the function returns with `return xvasprintf (ptr, template, v);` on line 39, without calling `va_end` to properly clean up the `va_list v`.

The provided source code does not show `va_end` being called within the function `xasprintf` (or any other function in the provided context) for the `va_list v` initialized on line 38.

The absence of `va_end` can lead to undefined behavior, as it is required to be called once for each `va_start` to ensure proper cleanup of the variable arguments list.

Since there is a direct and demonstrable link between the code''s behavior (lack of `va_end` after `va_start`) and the vulnerability described in the CVE (missing `va_end`), this is not a false positive.', 'Obtain and analyze the implementation of `xvasprintf` to determine if it implicitly calls `va_end(v)` or properly handles `va_list` arguments.

Assess the documentation or specifications of `xvasprintf` for any mentions of `va_list` management responsibilities.', 0.0000, '*** Source Code Context ***

code of info/util.c file:
34| int
35| xasprintf (char **ptr, const char *template, ...)
36| {
37|   va_list v;
38|   va_start (v, template);
39|   return xvasprintf (ptr, template, v);
40| }

code of /shared-data/source/texinfo-7.1/tp/Texinfo/XS/parsetexi/errors.h file:
0| #endif

*** Examples ***
', '2025-11-17 21:39:07.050084');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (279, 112, 'def40', 'USE_AFTER_FREE', 'texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1069: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1067|         if (error)
# 1068|           {
# 1069|->           info_error ("%s", error);
# 1070|             exit (1);
# 1071|           }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1069: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1067|         if (error)
# 1068|           {
# 1069|->           info_error ("%s", error);
# 1070|             exit (1);
# 1071|           }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1069: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1067|         if (error)
# 1068|           {
# 1069|->           info_error ("%s", error);
# 1070|             exit (1);
# 1071|           }
(Example-1) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
texinfo-7.1/info/info.c:1048: freed_arg: "add_initial_nodes" frees "error".
texinfo-7.1/info/info.c:1079: pass_freed_arg: Passing freed pointer "error" as an argument to "info_error".
# 1077|         if (error)
# 1078|           {
# 1079|->           info_error ("%s", error);
# 1080|             exit (1);
# 1081|           }
(Example-2) Reason Marked as False Positive:
add_initial_nodes() either frees "error" on line 427 but allocates it right again with xasprintf (wrapper to asprintf) on the following line 428, or frees "error" and sets it to NULL on lines 525, 539, 570

', '2025-11-17 21:39:07.050084');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (280, 112, 'def41', 'CPPCHECK_WARNING', 'texinfo-7.1/install-info/install-info.c:760: error[resourceLeak]: Resource leak: f
#  758|           }
#  759|         errno = 0;
#  760|->       return 0; /* unknown error */
#  761|       }
#  762|', 'TRUE POSITIVE', 'Resource leak confirmed at line 760 due to `return 0;` without preceding `fclose(f)` in the ''unknown error'' handling path, correlating with the CVE''s resource leak vulnerability description.', 'The CVE report snippet explicitly highlights a resource leak at line 760, where the function returns 0 without closing the file pointer `f`.

Upon examining the source code, it is evident that the `return 0;` statement at line 760 is executed when an ''unknown error'' occurs (as indicated by the comment).

Prior to this return statement, there is no explicit call to close the file pointer `f` (e.g., `fclose(f)`) within this specific error handling path.

Although `fclose(f)` is called in other parts of the function (e.g., lines 744, 832), there is no guarantee that these lines are executed when the ''unknown error'' condition at line 760 is met.

The absence of a definitive `fclose(f)` call immediately before the `return 0;` at line 760, for the specific error condition handled there, directly correlates with the resource leak vulnerability described in the CVE report.

Given the explicit behavior of the provided source code, there is a identifiable execution path (the ''unknown error'' condition at line 760) that potentially leads to a resource leak, satisfying the criteria for a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of install-info/install-info.c file:
646| FILE *
647| open_possibly_compressed_file (char *filename,
648|     void (*create_callback) (char *),
649|     char **opened_filename, char **compression_program) 
650| {
651|   char *local_opened_filename, *local_compression_program;
652|   int nread;
653|   char data[13];
654|   FILE *f;
655| 
656|   /* We let them pass NULL if they don''t want this info, but it''s easier
657|      to always determine it.  */
658|   if (!opened_filename)
659|     opened_filename = &local_opened_filename;
660| 
661|   *opened_filename = filename;
662|   f = fopen (*opened_filename, FOPEN_RBIN);
663|   if (!f)
664|     {
665|       *opened_filename = concat (filename, ".gz", "");
666|       f = fopen (*opened_filename, FOPEN_RBIN);
667|     }
668|   if (!f)
669|     {
670|       free (*opened_filename);
671|       *opened_filename = concat (filename, ".xz", "");
672|       f = fopen (*opened_filename, FOPEN_RBIN);
673|     }
674|   if (!f)
675|     {
676|       free (*opened_filename);
677|       *opened_filename = concat (filename, ".bz2", "");
678|       f = fopen (*opened_filename, FOPEN_RBIN);
679|     }
680|   if (!f)
681|     {
682|       free (*opened_filename);
683|       *opened_filename = concat (filename, ".zst", "");
684|       f = fopen (*opened_filename, FOPEN_RBIN);
685|     }
686|   if (!f)
687|     {
688|       free (*opened_filename);
689|       *opened_filename = concat (filename, ".lz", "");
690|       f = fopen (*opened_filename, FOPEN_RBIN);
691|     }
692|   if (!f)
693|     {
694|      free (*opened_filename);
695|      *opened_filename = concat (filename, ".lzma", "");
696|      f = fopen (*opened_filename, FOPEN_RBIN);
697|     }
698| #ifdef __MSDOS__
699|   if (!f)
700|     {
701|       free (*opened_filename);
702|       *opened_filename = concat (filename, ".igz", "");
703|       f = fopen (*opened_filename, FOPEN_RBIN);
704|     }
705|   if (!f)
706|     {
707|       free (*opened_filename);
708|       *opened_filename = concat (filename, ".inz", "");
709|       f = fopen (*opened_filename, FOPEN_RBIN);
710|     }
711| #endif /* __MSDOS__ */
712|   if (!f)
713|     {
714|       /* The file was not found with any extention added.  Try the
715|          original file again. */
716|       free (*opened_filename);
717|       *opened_filename = filename;
718| 
719|       if (create_callback)
720|         {
721|           /* Create the file if we can.  */
722|           (*create_callback) (filename);
723| 
724|           /* And try opening it again.  */
725|           f = fopen (*opened_filename, FOPEN_RBIN);
726|           if (!f)
727|             return 0;
728|         }
729|       else
730|         return 0;
731|     }
732| 
733|   /* Read first few bytes of file rather than relying on the filename.
734|      If the file is shorter than this it can''t be usable anyway.  */
735|   nread = fread (data, sizeof (data), 1, f);
736|   if (nread != 1)
737|     {
738|       if (nread == 0)
739|         {
740|           /* Try to create the file if its empty. */
741|           if (feof (f) && create_callback)
742|             {
743|               if (fclose (f) != 0)
744|                 return 0; /* unknown error closing file */
745| 
746|               if (remove (filename) != 0)
747|                 return 0; /* unknown error deleting file */
748| 
749|               (*create_callback) (filename);
750|               f = fopen (*opened_filename, FOPEN_RBIN);
751|               if (!f)
752|                 return 0;
753|               nread = fread (data, sizeof (data), 1, f);
754|               if (nread == 0)
755|                 return 0;
756|               goto determine_file_type; /* success */
757|             }
758|         }
759|       errno = 0;
760|       return 0; /* unknown error */
761|     }
762| 
763| determine_file_type:
764|   if (!compression_program)
765|     compression_program = &local_compression_program;
766| 
767|   if (data[0] == ''\x1f'' && data[1] == ''\x8b'')
768| #if STRIP_DOT_EXE
769|     /* An explicit .exe yields a better diagnostics from popen below
770|        if they don''t have gzip installed.  */
771|     *compression_program = "gzip.exe";
772| #else
773|     *compression_program = "gzip";
774| #endif
775| 
776|   else if (data[0] == ''\xFD'' && data[1] == ''7'' && data[2] == ''z''
777|            && data[3] == ''X'' && data[4] == ''Z'' && data[5] == 0)
778| #ifndef STRIP_DOT_EXE
779|     *compression_program = "xz.exe";
780| #else
781|     *compression_program = "xz";
782| #endif
783| 
784|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''h'')
785| #ifndef STRIP_DOT_EXE
786|     *compression_program = "bzip2.exe";
787| #else
788|     *compression_program = "bzip2";
789| #endif
790| 
791|   else if (data[0] == ''B'' && data[1] == ''Z'' && data[2] == ''0'')
792| #ifndef STRIP_DOT_EXE
793|     *compression_program = "bzip.exe";
794| #else
795|     *compression_program = "bzip";
796| #endif
797| 
798|   else if (data[0] == 0x4C && data[1] == 0x5A && data[2] == 0x49
799|            && data[3] == 0x50 && data[4] == 1)		/* "LZIP" */
800| #ifndef STRIP_DOT_EXE
801|     *compression_program = "lzip.exe";
802| #else
803|     *compression_program = "lzip";
804| #endif
805| 
806|     /* We (try to) match against old lzma format (which lacks proper
807|        header, two first matches), as well as the new format (last match).  */
808|   else if ((data[9] == 0x00 && data[10] == 0x00 && data[11] == 0x00
809|             && data[12] == 0x00)
810|            || (data[5] == ''\xFF'' && data[6] == ''\xFF'' && data[7] == ''\xFF''
811|                && data[8] == ''\xFF'' && data[9] == ''\xFF'' && data[10] == ''\xFF''
812|                && data[11] == ''\xFF'' && data[12] == ''\xFF'') 
813|            || (data[0] == ''\xFF'' && data[1] == ''L'' && data[2] == ''Z''
814|                && data[3] == ''M'' && data[4] == ''A'' && data[5] == 0x00))
815| #ifndef STRIP_DOT_EXE
816|     *compression_program = "lzma.exe";
817| #else
818|     *compression_program = "lzma";
819| #endif
820| 
821|   else
822|     *compression_program = NULL;
823| 
824|   if (*compression_program)
825|     {
826|       /* Redirect stdin to the file and fork the decompression process
827|          reading from stdin.  This allows shell metacharacters in filenames. */
828|       char *command = concat (*compression_program, " -d", "");
829|       FILE *f2;
830| 
831|       if (fclose (f) < 0)
832|         return 0;
833|       f2 = freopen (*opened_filename, FOPEN_RBIN, stdin);
834|       if (!f)
835|         return 0;
836|       f = popen (command, "r");
837|       fclose (f2);
838|       if (!f)
839|         {
840|           /* Used for error message in calling code. */
841|           *opened_filename = command;
842|           return 0;
843|         }
844|       free (command);
845|     }
846|   else
847|     {
848| #if O_BINARY
849|       /* Since this is a text file, and we opened it in binary mode,
850|          switch back to text mode.  */
851|       f = freopen (*opened_filename, "r", f);
852|       if (! f)
853| 	return 0;
854| #else
855|       /* Seek back over the magic bytes.  */
856|       if (fseek (f, 0, 0) < 0)
857|         return 0;
858| #endif
859|     }
860| 
861|   return f;
862| }


*** Examples ***
', '2025-11-17 21:39:07.050085');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (281, 93, 'def1', 'UNINIT', 'libksba-1.6.5/src/asn1-parse.c:1520: var_decl: Declaring variable "yyvsa" without initializer.
libksba-1.6.5/src/asn1-parse.c:1521: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libksba-1.6.5/src/asn1-parse.c:1614: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1612|             YYNOMEM;
# 1613|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1614|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1615|   #  undef YYSTACK_RELOCATE
# 1616|           if (yyss1 != yyssa)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libksba-1.6.5/src/asn1-parse.c:1520: var_decl: Declaring variable "yyvsa" without initializer.
libksba-1.6.5/src/asn1-parse.c:1521: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libksba-1.6.5/src/asn1-parse.c:1614: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1612|             YYNOMEM;
# 1613|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1614|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1615|   #  undef YYSTACK_RELOCATE
# 1616|           if (yyss1 != yyssa)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libksba-1.6.5/src/asn1-parse.c:1520: var_decl: Declaring variable "yyvsa" without initializer.
libksba-1.6.5/src/asn1-parse.c:1521: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libksba-1.6.5/src/asn1-parse.c:1614: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1612|             YYNOMEM;
# 1613|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1614|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1615|   #  undef YYSTACK_RELOCATE
# 1616|           if (yyss1 != yyssa)
(Example-1) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libksba-1.5.1/src/asn1-parse.c:1241: var_decl: Declaring variable "yylval" without initializer.
libksba-1.5.1/src/asn1-parse.c:2534: uninit_use: Using uninitialized value "yylval".
# 2532|   
# 2533|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 2534|->   *++yyvsp = yylval;
# 2535|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 2536|
(Example-2) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

', '2025-11-17 21:39:07.062501');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (282, 93, 'def2', 'OVERRUN', 'libksba-1.6.5/src/asn1-parse.c:1512: assignment: Assigning: "yystacksize" = "200L".
libksba-1.6.5/src/asn1-parse.c:1602: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libksba-1.6.5/src/asn1-parse.c:1613: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 136 bytes).
libksba-1.6.5/src/asn1-parse.c:1629: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 136 bytes.
# 1627|         YY_IGNORE_USELESS_CAST_END
# 1628|   
# 1629|->       if (yyss + yystacksize - 1 <= yyssp)
# 1630|           YYABORT;
# 1631|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: libksba-1.6.5/src/asn1-parse.c:1512: assignment: Assigning: "yystacksize" = "200L".
libksba-1.6.5/src/asn1-parse.c:1602: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libksba-1.6.5/src/asn1-parse.c:1613: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 136 bytes).
libksba-1.6.5/src/asn1-parse.c:1629: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 136 bytes.
# 1627|         YY_IGNORE_USELESS_CAST_END
# 1628|   
# 1629|->       if (yyss + yystacksize - 1 <= yyssp)
# 1630|           YYABORT;
# 1631|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
libksba-1.6.5/src/asn1-parse.c:1512: assignment: Assigning: "yystacksize" = "200L".
libksba-1.6.5/src/asn1-parse.c:1602: assignment: Assigning: "yystacksize" *= "2L". The value of "yystacksize" is now 400.
libksba-1.6.5/src/asn1-parse.c:1613: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to byte 0 of "yyptr->yyss_alloc" (which consists of 136 bytes).
libksba-1.6.5/src/asn1-parse.c:1629: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 399 of an array of 136 bytes.
# 1627|         YY_IGNORE_USELESS_CAST_END
# 1628|   
# 1629|->       if (yyss + yystacksize - 1 <= yyssp)
# 1630|           YYABORT;
# 1631|       }
(Example-1) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
libksba-1.5.1/src/asn1-parse.c:1292: assignment: Assigning: "yystacksize" = "200UL".
libksba-1.5.1/src/asn1-parse.c:1349: assignment: Assigning: "yystacksize" *= "2UL". The value of "yystacksize" is now 400.
libksba-1.5.1/src/asn1-parse.c:1359: alias: Assigning: "yyss" = "&yyptr->yyss_alloc". "yyss" now points to element 0 of "yyptr->yyss_alloc" (which consists of 68 2-byte elements).
libksba-1.5.1/src/asn1-parse.c:1373: illegal_address: "yyss + yystacksize - 1" evaluates to an address that is at byte offset 798 of an array of 136 bytes.
# 1371|                     (unsigned long) yystacksize));
# 1372|   
# 1373|->       if (yyss + yystacksize - 1 <= yyssp)
# 1374|           YYABORT;
# 1375|       }
(Example-2) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

', '2025-11-17 21:39:07.062504');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (283, 93, 'def3', 'UNINIT', 'libksba-1.6.5/src/der-builder.c:552: var_decl: Declaring variable "err" without initializer.
libksba-1.6.5/src/der-builder.c:669: uninit_use: Using uninitialized value "err".
#  667|    leave:
#  668|     xfree (buffer);
#  669|->   return err;
#  670|   }', 'TRUE POSITIVE', 'Variable ''err'' is declared without an initializer (line 552) and may be used uninitialized at return (line 669) if specific error-setting code paths (e.g., lines 563, 580, 615) are not executed, as exemplified by a vulnerable path when ''d'' is valid, ''d->error'' is unset, ''r_obj'' is non-NULL, and ''d->finished'' is true.', 'The variable ''err'' is declared without an initializer at line 552 (libksba-1.6.5/src/der-builder.c).

There are multiple execution paths where ''err'' might not be explicitly initialized before its use at line 669 (e.g., if conditions in lines 563, 570, 571, and 584 are not met, and no error is set in between).

Specifically, if the function enters the ''leave'' label (line 667) without hitting any of the error-setting code paths (e.g., lines 563, 580, 615), the value of ''err'' at return (line 669) would be undefined, as it relies on the uninitialized value of ''err''.

Example of a vulnerable path: If ''d'' is not NULL (line 562), ''d->error'' is not set (line 565), ''r_obj'' is not NULL (line 571), and ''d->finished'' is already true (line 574), the function may reach the ''leave'' label without initializing ''err''.

Since there''s at least one identifiable execution path where ''err'' is used uninitialized, and without definitive proof that all paths safely initialize ''err'' before its use, the finding cannot be conclusively marked as a FALSE POSITIVE.', 'Perform a step-by-step code walkthrough for the ''normal execution path'' (without premature ''goto leave;'') to verify if ''err'' is assigned a value before its return at line 669.

Analyze the functions called within this path (e.g., lines 564, 565, 580, 586, 614) to ensure none implicitly initialize ''err''.

Review the project''s coding standards or conventions regarding variable initialization to contextualize the potential oversight.', 0.0000, '*** Source Code Context ***

code of src/der-builder.c file:
549| gpg_error_t
550| _ksba_der_builder_get (ksba_der_t d, unsigned char **r_obj, size_t *r_objlen)
551| {
552|   gpg_error_t err;
553|   int idx;
554|   unsigned char *buffer = NULL;
555|   unsigned char *p;
556|   size_t bufsize, buflen;
557|   int encap_bts;
558| 
559|   *r_obj = NULL;
560|   *r_objlen = 0;
561| 
562|   if (!d)
563|     return gpg_error (GPG_ERR_INV_ARG);
564|   if (d->error)
565|     {
566|       err = d->error;
567|       if (r_objlen)
568|         *r_objlen = d->nitems;
569|       goto leave;
570|     }
571|   if (!r_obj)
572|     return 0;
573| 
574|   if (!d->finished)
575|     {
576|       if (d->nitems == 1)
577|         ;  /* Single item does not need an end tag.  */
578|       else if (!d->nitems || !d->items[d->nitems-1].is_stop)
579|         {
580|           err = gpg_error (GPG_ERR_NO_OBJ);
581|           goto leave;
582|         }
583| 
584|       compute_lengths (d, 0);
585|       err = d->error;
586|       if (err)
587|         goto leave;
588| 
589|       d->finished = 1;
590|     }
591| 
592|   /* If the first element is a primitive element we rightly assume no
593|    * other elements follow.  It is the user''s duty to build a valid
594|    * ASN.1 object.  */
595|   bufsize = d->items[0].hdrlen + d->items[0].valuelen;
596| 
597|   /* if (getenv ("KSBA_DEBUG_DER_BUILDER")) */
598|   /*   { */
599|   /*     for (idx=0; idx < d->nitems; idx++) */
600|   /*       gpgrt_log_debug ("DERB[%2d]: c=%d t=%2d %s p=%p h=%u l=%zu
", */
601|   /*                        idx, */
602|   /*                        d->items[idx].class, */
603|   /*                        d->items[idx].tag, */
604|   /*                        d->items[idx].verbatim? "verbatim": */
605|   /*                        d->items[idx].is_stop? "stop": */
606|   /*                        d->items[idx].is_constructed? "cons":"prim", */
607|   /*                        d->items[idx].value, */
608|   /*                        d->items[idx].hdrlen, */
609|   /*                        d->items[idx].valuelen); */
610|   /*   } */
611| 
612|   buffer = xtrymalloc (bufsize);
613|   if (!buffer)
614|     {
615|       err = gpg_error_from_syserror ();
616|       goto leave;
617|     }
618|   buflen = 0;
619|   p = buffer;
620| 
621|   for (idx=0; idx < d->nitems; idx++)
622|     {
623|       if (d->items[idx].is_stop)
624|         continue;
625|       if (!d->items[idx].verbatim)
626|         {
627|           /* For data encapsulated in a bit string we need to adjust
628|            * for the unused bits octet.  */
629|           encap_bts = (d->items[idx].encapsulate && !d->items[idx].class
630|                        && d->items[idx].tag == TYPE_BIT_STRING);
631| 
632|           if (buflen + d->items[idx].hdrlen + encap_bts > bufsize)
633|             {
634|               err = gpg_error (GPG_ERR_BUG);
635|               goto leave;
636|             }
637|           write_tl (p, d->items[idx].class, d->items[idx].tag,
638|                     (d->items[idx].is_constructed
639|                      && !d->items[idx].encapsulate),
640|                     d->items[idx].valuelen + encap_bts);
641|           p += d->items[idx].hdrlen;
642|           buflen += d->items[idx].hdrlen;
643|           if (encap_bts)
644|             {
645|               *p++ = 0;
646|               buflen++;
647|             }
648|         }
649|       if (d->items[idx].value)
650|         {
651|           if (buflen + d->items[idx].valuelen > bufsize)
652|             {
653|               err = gpg_error (GPG_ERR_BUG);
654|               goto leave;
655|             }
656|           memcpy (p, d->items[idx].value, d->items[idx].valuelen);
657|           p += d->items[idx].valuelen;
658|           buflen += d->items[idx].valuelen;
659|         }
660|     }
661|   assert (buflen == bufsize);
662| 
663|   *r_obj = buffer;
664|   *r_objlen = buflen;
665|   buffer = NULL;
666| 
667|  leave:
668|   xfree (buffer);
669|   return err;
670| }

code of /shared-data/source/libksba-1.6.5/src/util.h file:
58| #define xfree(a)         ksba_free((a))
code of /usr/include/gpg-error.h file:
958| static GPG_ERR_INLINE gpg_error_t
959| gpg_error (gpg_err_code_t code)
960| {
961|   return gpg_err_make (GPG_ERR_SOURCE_DEFAULT, code);
962| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
libksba-1.5.1/src/asn1-parse.c:1241: var_decl: Declaring variable "yylval" without initializer.
libksba-1.5.1/src/asn1-parse.c:2534: uninit_use: Using uninitialized value "yylval".
# 2532|   
# 2533|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 2534|->   *++yyvsp = yylval;
# 2535|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 2536|
(Example-1) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
libksba-1.6.5/src/asn1-parse.c:1520: var_decl: Declaring variable "yyvsa" without initializer.
libksba-1.6.5/src/asn1-parse.c:1521: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
libksba-1.6.5/src/asn1-parse.c:1614: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1612|             YYNOMEM;
# 1613|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1614|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1615|   #  undef YYSTACK_RELOCATE
# 1616|           if (yyss1 != yyssa)
(Example-2) Reason Marked as False Positive:
generated code from bison has some workarouds for older compilers, but in this case they are likely ignored. I do not see a way this could be used uninitialized, even though it might not be completely clear to the checkers. Maybe also exclude with a subpath?

', '2025-11-17 21:39:07.062504');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (284, 100, 'def1', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1270: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_min" when calling "from_ascii".
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|->   file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1270: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_min" when calling "from_ascii".
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|->   file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1270: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_min" when calling "from_ascii".
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|->   file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
(Example-1) Reason Marked as False Positive:
it was initialized by "tape_buffered_read (ascii_header.c_ino, in_des, sizeof ascii_header - sizeof ascii_header.c_magic);"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068551');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (331, 105, 'def1', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c3" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {', 'TRUE POSITIVE', 'Large index value (6442450944) from `_mpd_get_transform_len(*rsize)` (line 5665) is assigned to `n` without explicit overflow checks, and subsequently used for memory allocation (lines 5669-5677) and `fnt_autoconvolute` calls (line 5684), potentially leading to a buffer overrun vulnerability (CWE-119).', 'The CVE report indicates a potential buffer overrun due to a very large index (6442450944) being passed to `fnt_autoconvolute` (line 5684).

This large index value is directly assigned to `n` from the return value of `_mpd_get_transform_len(*rsize)` (line 5665), with no explicit checks for overflow or unreasonable values in the provided code snippet.

The code subsequently uses `n` to allocate memory for `c1`, `c2`, and `c3` (lines 5669-5677) using `mpd_calloc`, but there is no explicit evidence within the provided code that `mpd_calloc` itself checks for integer overflows in the `n` parameter.

Unlike the provided examples (Example-1 and Example-2) marked as FALSE POSITIVE, which mention that the function allocating memory (`mpd_sh_alloc`) checks for integer overflows, the current analysis does not have explicit proof within the provided code that such checks are in place for the allocations of `c1`, `c2`, and `c3`.

Given the direct assignment of a potentially large value to `n` and its subsequent use in memory allocation and function calls without explicit overflow checks in the provided code, there is a plausible execution path that could lead to a buffer overrun vulnerability (CWE-119).

Uncertainty regarding the behavior of `_mpd_get_transform_len` and `mpd_calloc` outside of the provided code does not negate the potential vulnerability within the analyzed snippet; hence, a cautious approach leads to a TRUE POSITIVE conclusion.', 'Examine the implementation of `mpd_calloc` to determine if it performs integer overflow checks on the `n` parameter.

Investigate the `_mpd_get_transform_len` function to understand its return value bounds and potential for producing excessively large values like 6442450944.

Verify if there are any implicit or explicit checks for unreasonable values of `n` between its assignment from `_mpd_get_transform_len` and its use in `fnt_autoconvolute` calls.', 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5651| static mpd_uint_t *
5652| _mpd_fntmul(const mpd_uint_t *u, const mpd_uint_t *v,
5653|             mpd_size_t ulen, mpd_size_t vlen,
5654|             mpd_size_t *rsize)
5655| {
5656|     mpd_uint_t *c1 = NULL, *c2 = NULL, *c3 = NULL, *vtmp = NULL;
5657|     mpd_size_t n;
5658| 
5659| #ifdef PPRO
5660|     unsigned int cw;
5661|     cw = mpd_set_fenv();
5662| #endif
5663| 
5664|     *rsize = add_size_t(ulen, vlen);
5665|     if ((n = _mpd_get_transform_len(*rsize)) == MPD_SIZE_MAX) {
5666|         goto malloc_error;
5667|     }
5668| 
5669|     if ((c1 = mpd_calloc(n, sizeof *c1)) == NULL) {
5670|         goto malloc_error;
5671|     }
5672|     if ((c2 = mpd_calloc(n, sizeof *c2)) == NULL) {
5673|         goto malloc_error;
5674|     }
5675|     if ((c3 = mpd_calloc(n, sizeof *c3)) == NULL) {
5676|         goto malloc_error;
5677|     }
5678| 
5679|     memcpy(c1, u, ulen * (sizeof *c1));
5680|     memcpy(c2, u, ulen * (sizeof *c2));
5681|     memcpy(c3, u, ulen * (sizeof *c3));
5682| 
5683|     if (u == v) {
5684|         if (!fnt_autoconvolute(c1, n, P1) ||
5685|             !fnt_autoconvolute(c2, n, P2) ||
5686|             !fnt_autoconvolute(c3, n, P3)) {
5687|             goto malloc_error;
5688|         }
5689|     }
5690|     else {
5691|         if ((vtmp = mpd_calloc(n, sizeof *vtmp)) == NULL) {
5692|             goto malloc_error;
5693|         }
5694| 
5695|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5696|         if (!fnt_convolute(c1, vtmp, n, P1)) {
5697|             mpd_free(vtmp);
5698|             goto malloc_error;
5699|         }
5700| 
5701|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5702|         mpd_uint_zero(vtmp+vlen, n-vlen);
5703|         if (!fnt_convolute(c2, vtmp, n, P2)) {
5704|             mpd_free(vtmp);
5705|             goto malloc_error;
5706|         }
5707| 
5708|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5709|         mpd_uint_zero(vtmp+vlen, n-vlen);
5710|         if (!fnt_convolute(c3, vtmp, n, P3)) {
5711|             mpd_free(vtmp);
5712|             goto malloc_error;
5713|         }
5714| 
5715|         mpd_free(vtmp);
5716|     }
5717| 
5718|     crt3(c1, c2, c3, *rsize);
5719| 
5720| out:
5721| #ifdef PPRO
5722|     mpd_restore_fenv(cw);
5723| #endif
5724|     if (c2) mpd_free(c2);
5725|     if (c3) mpd_free(c3);
5726|     return c1;
5727| 
5728| malloc_error:
5729|     if (c1) mpd_free(c1);
5730|     c1 = NULL;
5731|     goto out;
5732| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c3" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.08277');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (285, 100, 'def2', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1210: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev" when calling "from_ascii".
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|->   dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
# 1212|     file_hdr->c_rdev_min = minor (dev);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1210: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev" when calling "from_ascii".
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|->   dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
# 1212|     file_hdr->c_rdev_min = minor (dev);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1210: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev" when calling "from_ascii".
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|->   dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
# 1212|     file_hdr->c_rdev_min = minor (dev);
(Example-1) Reason Marked as False Positive:
it was initialized by "tape_buffered_read (ascii_header.c_dev, in_des, sizeof ascii_header - sizeof ascii_header.c_magic);"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1209: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|->   file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068552');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (286, 100, 'def3', 'UNINIT', 'cpio-2.15/src/util.c:1343: var_decl: Declaring variable "fs" without initializer.
cpio-2.15/src/util.c:1347: uninit_use_in_call: Using uninitialized value "fs". Field "fs.c_magic" is uninitialized when calling "delay_cpio_set_stat".
# 1345|     stat_to_cpio (&fs, st);
# 1346|     fs.c_name = (char*) file_name;
# 1347|->   delay_cpio_set_stat (&fs, invert_permissions);
# 1348|   }
# 1349|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/util.c: var_decl: Declaring variable "fs" without initializer.
cpio-2.15/src/util.c: uninit_use_in_call: Using uninitialized value "fs". Field "fs.c_magic" is uninitialized when calling "delay_cpio_set_stat".
#     stat_to_cpio (&fs, st);
#     fs.c_name = (char*) file_name;
#->   delay_cpio_set_stat (&fs, invert_permissions);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/util.c:1343: var_decl: Declaring variable "fs" without initializer.
cpio-2.15/src/util.c:1347: uninit_use_in_call: Using uninitialized value "fs". Field "fs.c_magic" is uninitialized when calling "delay_cpio_set_stat".
# 1345|     stat_to_cpio (&fs, st);
# 1346|     fs.c_name = (char*) file_name;
# 1347|->   delay_cpio_set_stat (&fs, invert_permissions);
# 1348|   }
# 1349|
(Example-1) Reason Marked as False Positive:
initialized on line 1345

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1263: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|->   file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068552');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (287, 100, 'def4', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1206: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1204|   
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|->   file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1206: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1204|   
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|->   file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1206: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1204|   
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|->   file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1207: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|->   file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (288, 100, 'def5', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1214: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1212|     file_hdr->c_rdev_min = minor (dev);
# 1213|   
# 1214|->   file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
#     file_hdr->c_rdev_min = minor (dev);
#   
#->   file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
#     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
#     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1214: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1212|     file_hdr->c_rdev_min = minor (dev);
# 1213|   
# 1214|->   file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1267: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_maj" when calling "from_ascii".
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|->   file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (289, 100, 'def6', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1268: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_min" when calling "from_ascii".
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|->   file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1268: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_min" when calling "from_ascii".
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|->   file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1268: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_min" when calling "from_ascii".
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|->   file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1267: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_maj" when calling "from_ascii".
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|->   file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068553');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (290, 100, 'def7', 'BUFFER_SIZE', 'cpio-2.15/src/tar.c:215: buffer_size: Calling "strncpy" with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  213|   
#  214|         strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
#  215|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
#  216|   
#  217|         name = getuser (file_hdr->c_uid);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/tar.c:215: buffer_size: Calling "strncpy" with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  213|   
#  214|         strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
#  215|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
#  216|   
#  217|         name = getuser (file_hdr->c_uid);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.15/src/tar.c:215: buffer_size: Calling "strncpy" with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  213|   
#  214|         strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
#  215|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
#  216|   
#  217|         name = getuser (file_hdr->c_uid);
(Example-1) Reason Marked as False Positive:
tar format counts with that and the tar header was zeroed before (line 141)

** Example-2 **
(Example-2) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.12/src/tar.c:223: buffer_size: Calling strncpy with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  223|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
(Example-2) Reason Marked as False Positive:
there are exactly 2bytes in tar_hdr->version.  And it''s expected
that such header field might not be terminated.

', '2025-11-17 21:39:07.068554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (291, 100, 'def8', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1209: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|->   file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1209: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|->   file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1209: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|->   file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1208: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|->   file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (292, 100, 'def9', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1263: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|->   file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1263: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|->   file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1263: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|->   file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1262: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|->   file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068554');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (293, 100, 'def10', 'UNINIT', 'cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:310: uninit_use: Using uninitialized value "tm_1". Field "tm_1.tm_gmtoff" is uninitialized.
#  308|             if (revert_tz (old_tz) && ok)
#  309|               {
#  310|->               *tm = tm_1;
#  311|                 return t;
#  312|               }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/time_rz.c: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c: uninit_use: Using uninitialized value "tm_1". Field "tm_1.tm_gmtoff" is uninitialized.
#             if (revert_tz (old_tz) && ok)
#               {
#->               *tm = tm_1;
#                 return t;
#               }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:310: uninit_use: Using uninitialized value "tm_1". Field "tm_1.tm_gmtoff" is uninitialized.
#  308|             if (revert_tz (old_tz) && ok)
#  309|               {
#  310|->               *tm = tm_1;
#  311|                 return t;
#  312|               }
(Example-1) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L220-228

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:306: uninit_use_in_call: Using uninitialized value "tm_1.tm_zone" when calling "save_abbr".
#  304|             bool ok = 0 <= tm_1.tm_yday;
#  305|   #if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME
#  306|->           ok = ok && save_abbr (tz, &tm_1);
#  307|   #endif
#  308|             if (revert_tz (old_tz) && ok)
(Example-2) Reason Marked as False Positive:


', '2025-11-17 21:39:07.068555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (294, 100, 'def11', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1205: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_ino" when calling "from_ascii".
# 1203|     file_hdr->c_dev_min = minor (dev);
# 1204|   
# 1205|->   file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_ino" when calling "from_ascii".
#     file_hdr->c_dev_min = minor (dev);
#   
#->   file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
#     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
#     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1205: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_ino" when calling "from_ascii".
# 1203|     file_hdr->c_dev_min = minor (dev);
# 1204|   
# 1205|->   file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1206: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1204|   
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|->   file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (295, 100, 'def12', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1269: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_maj" when calling "from_ascii".
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|->   file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1269: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_maj" when calling "from_ascii".
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|->   file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1269: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_maj" when calling "from_ascii".
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|->   file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1270: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_min" when calling "from_ascii".
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|->   file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
(Example-2) Reason Marked as False Positive:
it was initialized by "tape_buffered_read (ascii_header.c_ino, in_des, sizeof ascii_header - sizeof ascii_header.c_magic);"

', '2025-11-17 21:39:07.068555');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (296, 100, 'def13', 'BUFFER_SIZE', 'cpio-2.15/src/tar.c:203: buffer_size_warning: Calling "strncpy" with a maximum size argument of 100 bytes on destination array "tar_hdr->linkname" of size 100 bytes might leave the destination string unterminated.
#  201|         /* process_copy_out makes sure that c_tar_linkname is shorter
#  202|   	 than TARLINKNAMESIZE.  */
#  203|->       strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
#  204|   	       TARLINKNAMESIZE);
#  205|         to_ascii (tar_hdr->size, 0, 12, LG_8, true);', 'FALSE POSITIVE', 'The `strncpy` call on line 203 is guaranteed to leave space for null-termination since `process_copy_out` ensures `c_tar_linkname` is shorter than `TARLINKNAMESIZE` (line 201), matching the destination array `tar_hdr->linkname` size of 100 bytes.', 'The comment on line 201 explicitly states that `process_copy_out` ensures `c_tar_linkname` is shorter than `TARLINKNAMESIZE`, which is the same size as the destination array `tar_hdr->linkname` (100 bytes, as per the warning).

The `strncpy` function on line 203 is called with `TARLINKNAMESIZE` as the maximum size argument, which matches the expected shorter length of `c_tar_linkname` guaranteed by `process_copy_out`.

Since `c_tar_linkname` is guaranteed to be shorter than `TARLINKNAMESIZE`, `strncpy` will not write exactly 100 bytes, leaving at least one byte for the implicit null-termination (even though `strncpy` itself doesn''t add a terminator if the source length equals the size argument, in this context, the source is shorter).

The provided code context does not indicate any scenario where `c_tar_linkname` would be exactly 100 bytes or longer, which would be necessary for the warning to represent a true vulnerability (unterminated string).

Similar to Example-1 and Example-2 provided, where the context (e.g., header field expectations, prior zeroing) justified a FALSE POSITIVE conclusion, here the explicit guarantee by `process_copy_out` and the matching size parameters justify a similar conclusion.', NULL, 0.0000, '*** Source Code Context ***

code of src/tar.c file:
134| int
135| write_out_tar_header (struct cpio_file_stat *file_hdr, int out_des)
136| {
137|   int name_len;
138|   union tar_record tar_rec;
139|   struct tar_header *tar_hdr = (struct tar_header *) &tar_rec;
140| 
141|   memset (&tar_rec, 0, sizeof tar_rec);
142| 
143|   /* process_copy_out must ensure that file_hdr->c_name is short enough,
144|      or we will lose here.  */
145| 
146|   name_len = strlen (file_hdr->c_name);
147|   if (name_len <= TARNAMESIZE)
148|     {
149|       strncpy (tar_hdr->name, file_hdr->c_name, name_len);
150|     }
151|   else
152|     {
153|       /* Fit as much as we can into `name'', the rest into `prefix''.  */
154|       int prefix_len = split_long_name (file_hdr->c_name, name_len);
155| 
156|       strncpy (tar_hdr->prefix, file_hdr->c_name, prefix_len);
157|       strncpy (tar_hdr->name, file_hdr->c_name + prefix_len + 1,
158| 	       name_len - prefix_len - 1);
159|     }
160| 
161|   /* Ustar standard (POSIX.1-1988) requires the mode to contain only 3 octal
162|      digits */
163|   TO_OCT (file_hdr, c_mode & MODE_ALL, 8, tar_hdr, mode);
164|   TO_OCT (file_hdr, c_uid, 8, tar_hdr, uid);
165|   TO_OCT (file_hdr, c_gid, 8, tar_hdr, gid);
166|   TO_OCT (file_hdr, c_filesize, 12, tar_hdr, size);
167|   TO_OCT (file_hdr, c_mtime, 12, tar_hdr, mtime);
168| 
169|   switch (file_hdr->c_mode & CP_IFMT)
170|     {
171|     case CP_IFREG:
172|       if (file_hdr->c_tar_linkname)
173| 	{
174| 	  /* process_copy_out makes sure that c_tar_linkname is shorter
175| 	     than TARLINKNAMESIZE.  */
176| 	  strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
177| 		   TARLINKNAMESIZE);
178| 	  tar_hdr->typeflag = LNKTYPE;
179| 	  to_ascii (tar_hdr->size, 0, 12, LG_8, true);
180| 	}
181|       else
182| 	tar_hdr->typeflag = REGTYPE;
183|       break;
184|     case CP_IFDIR:
185|       tar_hdr->typeflag = DIRTYPE;
186|       break;
187|     case CP_IFCHR:
188|       tar_hdr->typeflag = CHRTYPE;
189|       break;
190|     case CP_IFBLK:
191|       tar_hdr->typeflag = BLKTYPE;
192|       break;
193| #ifdef CP_IFIFO
194|     case CP_IFIFO:
195|       tar_hdr->typeflag = FIFOTYPE;
196|       break;
197| #endif /* CP_IFIFO */
198| #ifdef CP_IFLNK
199|     case CP_IFLNK:
200|       tar_hdr->typeflag = SYMTYPE;
201|       /* process_copy_out makes sure that c_tar_linkname is shorter
202| 	 than TARLINKNAMESIZE.  */
203|       strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
204| 	       TARLINKNAMESIZE);
205|       to_ascii (tar_hdr->size, 0, 12, LG_8, true);
206|       break;
207| #endif /* CP_IFLNK */
208|     }
209| 
210|   if (archive_format == arf_ustar)
211|     {
212|       char *name;
213| 
214|       strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
215|       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
216| 
217|       name = getuser (file_hdr->c_uid);
218|       if (name)
219| 	strcpy (tar_hdr->uname, name);
220|       name = getgroup (file_hdr->c_gid);
221|       if (name)
222| 	strcpy (tar_hdr->gname, name);
223| 
224|       TO_OCT (file_hdr, c_rdev_maj, 8, tar_hdr, devmajor);
225|       TO_OCT (file_hdr, c_rdev_min, 8, tar_hdr, devminor);
226|     }
227| 
228|   to_ascii (tar_hdr->chksum, tar_checksum (tar_hdr), 8, LG_8, true);
229| 
230|   tape_buffered_write ((char *) &tar_rec, out_des, TARRECORDSIZE);
231| 
232|   return 0;
233| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.12/src/tar.c:223: buffer_size: Calling strncpy with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  223|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
(Example-1) Reason Marked as False Positive:
there are exactly 2bytes in tar_hdr->version.  And it''s expected
that such header field might not be terminated.

** Example-2 **
(Example-2) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.15/src/tar.c:215: buffer_size: Calling "strncpy" with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  213|   
#  214|         strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
#  215|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
#  216|   
#  217|         name = getuser (file_hdr->c_uid);
(Example-2) Reason Marked as False Positive:
tar format counts with that and the tar header was zeroed before (line 141)

', '2025-11-17 21:39:07.068556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (423, 102, 'def26', 'RESOURCE_LEAK', 'glibc-2.39/support/test-container.c:700: alloc_fn: Storage is returned from allocation function "fopen".
glibc-2.39/support/test-container.c:700: var_assign: Assigning: "f" = storage returned from "fopen(files[i].path, "r")".
glibc-2.39/support/test-container.c:705: noescape: Resource "f" is not freed or pointed-to in "fscanf".
glibc-2.39/support/test-container.c:700: overwrite_var: Overwriting "f" in "f = fopen(files[i].path, "r")" leaks the storage that "f" points to.
#  698|           continue;
#  699|   
#  700|->       f = fopen (files[i].path, "r");
#  701|         if (f == NULL)
#  702|           continue;', 'TRUE POSITIVE', 'Resource allocated by `fopen` at line 700 is not freed, leading to a potential resource leak (CWE-772), as evidenced by the lack of `fclose` within the provided code snippet, exacerbated by overwriting `f` without release on subsequent iterations.', '1. **Explicit Allocation without Free**: The code at line 700 explicitly allocates a resource using `fopen`, assigning it to `f`. However, there is no corresponding `fclose` (or any form of resource release) for `f` within the provided code snippet, potentially leading to a resource leak (CWE-772).

2. **Overwrite without Release**: As noted in the CVE report, line 700''s assignment to `f` overwrites its previous value without freeing the previously allocated resource, directly leading to a memory leak if the loop iterates multiple times (lines 696-712).

3. **Lack of `f` Release in Error Path**: If `fopen` fails (line 701, `f == NULL`), the loop continues without attempting to close `f`, but since `f` is NULL, this isn''t an issue here. However, the primary concern is the successful allocation path without a corresponding deallocation.

4. **No Evidence of `f` Being Freed Outside the Snippet**: Given the strict guidelines to only analyze the provided code, there''s no visible mechanism to free the resource allocated by `fopen` within this snippet, aligning with the reported vulnerability.

5. **Direct Correlation with CWE-772 (Resource Leak)**: The described behavior directly correlates with CWE-772, where a resource (in this case, a file descriptor returned by `fopen`) is not properly released after its allocation, leading to a resource leak.', 'Analyze the entire `test-container.c` file to identify any potential `fclose` calls for the resource allocated by `fopen` at line 700.

Investigate included libraries or header files for possible automatic resource management that might free the allocated resource.

Verify if there are any conditional statements (not shown in the snippet) that could lead to a resource release under specific circumstances.', 0.0000, '*** Source Code Context ***

code of support/test-container.c file:
673| void
674| check_for_unshare_hints (int require_pidns)
675| {
676|   static struct {
677|     const char *path;
678|     int bad_value, good_value, for_pidns;
679|   } files[] = {
680|     /* Default Debian Linux disables user namespaces, but allows a way
681|        to enable them.  */
682|     { "/proc/sys/kernel/unprivileged_userns_clone", 0, 1, 0 },
683|     /* ALT Linux has an alternate way of doing the same.  */
684|     { "/proc/sys/kernel/userns_restrict", 1, 0, 0 },
685|     /* Linux kernel >= 4.9 has a configurable limit on the number of
686|        each namespace.  Some distros set the limit to zero to disable the
687|        corresponding namespace as a "security policy".  */
688|     { "/proc/sys/user/max_user_namespaces", 0, 1024, 0 },
689|     { "/proc/sys/user/max_mnt_namespaces", 0, 1024, 0 },
690|     { "/proc/sys/user/max_pid_namespaces", 0, 1024, 1 },
691|   };
692|   FILE *f;
693|   int i, val;
694| 
695|   for (i = 0; i < array_length (files); i++)
696|     {
697|       if (!require_pidns && files[i].for_pidns)
698|         continue;
699| 
700|       f = fopen (files[i].path, "r");
701|       if (f == NULL)
702|         continue;
703| 
704|       val = -1; /* Sentinel.  */
705|       int cnt = fscanf (f, "%d", &val);
706|       if (cnt == 1 && val != files[i].bad_value)
707| 	continue;
708| 
709|       printf ("To enable test-container, please run this as root:
");
710|       printf ("  echo %d > %s
", files[i].good_value, files[i].path);
711|       return;
712|     }
713| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.33.9000-984-gddcc612ce9/elf/pldd.c:316: alloc_fn: Storage is returned from allocation function "xrealloc".
glibc-2.33.9000-984-gddcc612ce9/elf/pldd.c:316: var_assign: Assigning: "auxv" = storage returned from "xrealloc(auxv, auxv_size)".
glibc-2.33.9000-984-gddcc612ce9/elf/pldd.c:318: noescape: Resource "auxv" is not freed or pointed-to in "pread".
glibc-2.33.9000-984-gddcc612ce9/elf/pldd.c:320: leaked_storage: Variable "auxv" going out of scope leaks the storage it points to.
(Example-1) Reason Marked as False Positive:
auxv is used outside the scope.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.33.9000-984-gddcc612ce9/shadow/fgetspent.c:62: alloc_fn: Storage is returned from allocation function "realloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.33.9000-984-gddcc612ce9/shadow/fgetspent.c:62: var_assign: Assigning: "new_buf" = storage returned from "realloc(buffer, buffer_size)".
glibc-2.33.9000-984-gddcc612ce9/shadow/fgetspent.c:71: var_assign: Assigning: "buffer" = "new_buf".
glibc-2.33.9000-984-gddcc612ce9/shadow/fgetspent.c:76: leaked_storage: Variable "new_buf" going out of scope leaks the storage it points to.
(Example-2) Reason Marked as False Positive:
new_buf is just temporary reference to the future buffer,
which is a static pointer accessible across calls.

', '2025-11-17 21:39:07.11881');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (297, 100, 'def14', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1272: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|->   read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|   
# 1274|     /* In SVR4 ASCII format, the amount of space allocated for the header', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1272: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|->   read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|   
# 1274|     /* In SVR4 ASCII format, the amount of space allocated for the header', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1272: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|->   read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|   
# 1274|     /* In SVR4 ASCII format, the amount of space allocated for the header
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (298, 100, 'def15', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1215: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1213|   
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|->   file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
#     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
#->   file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
#     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1215: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1213|   
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|->   file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068556');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (299, 100, 'def16', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1261: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1259|   
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|->   file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
#     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
#->   file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
#     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
#     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1261: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1259|   
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|->   file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1262: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|->   file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (300, 100, 'def17', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1267: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_maj" when calling "from_ascii".
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|->   file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1267: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_maj" when calling "from_ascii".
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|->   file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1267: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_dev_maj" when calling "from_ascii".
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|->   file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (301, 100, 'def18', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1265: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|->   file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1265: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|->   file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1265: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|->   file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068557');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (302, 100, 'def19', 'UNINIT', 'cpio-2.15/gnu/argp-help.c:471: alloc_fn: Calling "malloc" which returns uninitialized memory.
cpio-2.15/gnu/argp-help.c:471: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
cpio-2.15/gnu/argp-help.c:496: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
#  494|               {
#  495|                 entry->num++;
#  496|->               if (oshort (o) && ! find_char (o->key, hol->short_options, so))
#  497|                   /* O has a valid short option which hasn''t already been used.*/
#  498|                   *so++ = o->key;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/argp-help.c:471: alloc_fn: Calling "malloc" which returns uninitialized memory.
cpio-2.15/gnu/argp-help.c:471: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
cpio-2.15/gnu/argp-help.c:496: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
#  494|               {
#  495|                 entry->num++;
#  496|->               if (oshort (o) && ! find_char (o->key, hol->short_options, so))
#  497|                   /* O has a valid short option which hasn''t already been used.*/
#  498|                   *so++ = o->key;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/argp-help.c:471: alloc_fn: Calling "malloc" which returns uninitialized memory.
cpio-2.15/gnu/argp-help.c:471: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
cpio-2.15/gnu/argp-help.c:496: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
#  494|               {
#  495|                 entry->num++;
#  496|->               if (oshort (o) && ! find_char (o->key, hol->short_options, so))
#  497|                   /* O has a valid short option which hasn''t already been used.*/
#  498|                   *so++ = o->key;
(Example-1) Reason Marked as False Positive:
the "hol->short_options"  is the start of array and "so" is the end. The "hol->short_options - so" is the number of defined elements of the array and  the find_char() function counts with this situation.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068558');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (303, 100, 'def20', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1271: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_chksum" when calling "from_ascii".
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|     file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|->   file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
# 1273|
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1270: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_rdev_min" when calling "from_ascii".
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
# 1269|     file_hdr->c_rdev_maj = FROM_HEX (ascii_header.c_rdev_maj);
# 1270|->   file_hdr->c_rdev_min = FROM_HEX (ascii_header.c_rdev_min);
# 1271|     file_hdr->c_chksum = FROM_HEX (ascii_header.c_chksum);
# 1272|     read_name_from_file (file_hdr, in_des, FROM_HEX (ascii_header.c_namesize));
(Example-2) Reason Marked as False Positive:
it was initialized by "tape_buffered_read (ascii_header.c_ino, in_des, sizeof ascii_header - sizeof ascii_header.c_magic);"

', '2025-11-17 21:39:07.068558');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (304, 100, 'def21', 'BUFFER_SIZE', 'cpio-2.15/src/tar.c:176: buffer_size_warning: Calling "strncpy" with a maximum size argument of 100 bytes on destination array "tar_hdr->linkname" of size 100 bytes might leave the destination string unterminated.
#  174|   	  /* process_copy_out makes sure that c_tar_linkname is shorter
#  175|   	     than TARLINKNAMESIZE.  */
#  176|-> 	  strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
#  177|   		   TARLINKNAMESIZE);
#  178|   	  tar_hdr->typeflag = LNKTYPE;', 'FALSE POSITIVE', 'The destination string `tar_hdr->linkname` is guaranteed to be terminated due to `process_copy_out` ensuring `c_tar_linkname` is shorter than `TARLINKNAMESIZE` (line 174), matching the destination array size (100 bytes), thus mitigating the unterminated string risk.', 'The comment on line 174 explicitly states that `process_copy_out` ensures `c_tar_linkname` is shorter than `TARLINKNAMESIZE`, which is the same size (100 bytes) as the destination array `tar_hdr->linkname`.

The `strncpy` function on line 176 is called with `TARLINKNAMESIZE` as the maximum size argument, which matches the size of the destination array `tar_hdr->linkname` (100 bytes).

Given the guarantee from the preceding comment (line 174), `file_hdr->c_tar_linkname` will always be shorter than or equal to `TARLINKNAMESIZE - 1` (to account for the null terminator), ensuring the destination string will be terminated when copied.

No execution path within the provided code snippet suggests that `c_tar_linkname` could exceed `TARLINKNAMESIZE`, thus mitigating the risk of an unterminated string.

This scenario is analogous to the provided **Example-2**, where the buffer is intentionally filled without null-termination due to format expectations (here, tar format), and preceding guarantees ensure safety.', NULL, 0.0000, '*** Source Code Context ***

code of src/tar.c file:
134| int
135| write_out_tar_header (struct cpio_file_stat *file_hdr, int out_des)
136| {
137|   int name_len;
138|   union tar_record tar_rec;
139|   struct tar_header *tar_hdr = (struct tar_header *) &tar_rec;
140| 
141|   memset (&tar_rec, 0, sizeof tar_rec);
142| 
143|   /* process_copy_out must ensure that file_hdr->c_name is short enough,
144|      or we will lose here.  */
145| 
146|   name_len = strlen (file_hdr->c_name);
147|   if (name_len <= TARNAMESIZE)
148|     {
149|       strncpy (tar_hdr->name, file_hdr->c_name, name_len);
150|     }
151|   else
152|     {
153|       /* Fit as much as we can into `name'', the rest into `prefix''.  */
154|       int prefix_len = split_long_name (file_hdr->c_name, name_len);
155| 
156|       strncpy (tar_hdr->prefix, file_hdr->c_name, prefix_len);
157|       strncpy (tar_hdr->name, file_hdr->c_name + prefix_len + 1,
158| 	       name_len - prefix_len - 1);
159|     }
160| 
161|   /* Ustar standard (POSIX.1-1988) requires the mode to contain only 3 octal
162|      digits */
163|   TO_OCT (file_hdr, c_mode & MODE_ALL, 8, tar_hdr, mode);
164|   TO_OCT (file_hdr, c_uid, 8, tar_hdr, uid);
165|   TO_OCT (file_hdr, c_gid, 8, tar_hdr, gid);
166|   TO_OCT (file_hdr, c_filesize, 12, tar_hdr, size);
167|   TO_OCT (file_hdr, c_mtime, 12, tar_hdr, mtime);
168| 
169|   switch (file_hdr->c_mode & CP_IFMT)
170|     {
171|     case CP_IFREG:
172|       if (file_hdr->c_tar_linkname)
173| 	{
174| 	  /* process_copy_out makes sure that c_tar_linkname is shorter
175| 	     than TARLINKNAMESIZE.  */
176| 	  strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
177| 		   TARLINKNAMESIZE);
178| 	  tar_hdr->typeflag = LNKTYPE;
179| 	  to_ascii (tar_hdr->size, 0, 12, LG_8, true);
180| 	}
181|       else
182| 	tar_hdr->typeflag = REGTYPE;
183|       break;
184|     case CP_IFDIR:
185|       tar_hdr->typeflag = DIRTYPE;
186|       break;
187|     case CP_IFCHR:
188|       tar_hdr->typeflag = CHRTYPE;
189|       break;
190|     case CP_IFBLK:
191|       tar_hdr->typeflag = BLKTYPE;
192|       break;
193| #ifdef CP_IFIFO
194|     case CP_IFIFO:
195|       tar_hdr->typeflag = FIFOTYPE;
196|       break;
197| #endif /* CP_IFIFO */
198| #ifdef CP_IFLNK
199|     case CP_IFLNK:
200|       tar_hdr->typeflag = SYMTYPE;
201|       /* process_copy_out makes sure that c_tar_linkname is shorter
202| 	 than TARLINKNAMESIZE.  */
203|       strncpy (tar_hdr->linkname, file_hdr->c_tar_linkname,
204| 	       TARLINKNAMESIZE);
205|       to_ascii (tar_hdr->size, 0, 12, LG_8, true);
206|       break;
207| #endif /* CP_IFLNK */
208|     }
209| 
210|   if (archive_format == arf_ustar)
211|     {
212|       char *name;
213| 
214|       strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
215|       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
216| 
217|       name = getuser (file_hdr->c_uid);
218|       if (name)
219| 	strcpy (tar_hdr->uname, name);
220|       name = getgroup (file_hdr->c_gid);
221|       if (name)
222| 	strcpy (tar_hdr->gname, name);
223| 
224|       TO_OCT (file_hdr, c_rdev_maj, 8, tar_hdr, devmajor);
225|       TO_OCT (file_hdr, c_rdev_min, 8, tar_hdr, devminor);
226|     }
227| 
228|   to_ascii (tar_hdr->chksum, tar_checksum (tar_hdr), 8, LG_8, true);
229| 
230|   tape_buffered_write ((char *) &tar_rec, out_des, TARRECORDSIZE);
231| 
232|   return 0;
233| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.12/src/tar.c:223: buffer_size: Calling strncpy with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  223|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
(Example-1) Reason Marked as False Positive:
there are exactly 2bytes in tar_hdr->version.  And it''s expected
that such header field might not be terminated.

** Example-2 **
(Example-2) Known False Positive:
Error BUFFER_SIZE (CWE-120):
cpio-2.15/src/tar.c:215: buffer_size: Calling "strncpy" with a source string whose length (2 chars) is greater than or equal to the size argument (2) will fail to null-terminate "tar_hdr->version".
#  213|   
#  214|         strncpy (tar_hdr->magic, TMAGIC, TMAGLEN);
#  215|->       strncpy (tar_hdr->version, TVERSION, TVERSLEN);
#  216|   
#  217|         name = getuser (file_hdr->c_uid);
(Example-2) Reason Marked as False Positive:
tar format counts with that and the tar header was zeroed before (line 141)

', '2025-11-17 21:39:07.068558');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (400, 102, 'def3', 'OVERRUN', 'glibc-2.39/time/tzset.c:395: alias: Assigning: "tz" = ""/etc/localtime"". "tz" now points to byte 0 of ""/etc/localtime"" (which consists of 15 bytes).
glibc-2.39/time/tzset.c:405: overrun-buffer-val: Overrunning buffer pointed to by "tz" of 15 bytes by passing it to a function which accesses it at byte offset 18.
#  403|   
#  404|     /* Try to read a data file.  */
#  405|->   __tzfile_read (tz, 0, NULL);
#  406|     if (__use_tzfile)
#  407|       return;', 'TRUE POSITIVE', 'Assignment at `tzset.c:395` and subsequent call to `__tzfile_read` at `tzset.c:405` with no evident bounds checking, potentially leading to a buffer overrun since `tz` points to a 15-byte buffer (`/etc/localtime`) that may be accessed at offset 18.', 'The CVE report indicates a potential buffer overrun at `tzset.c:405` when calling `__tzfile_read(tz, 0, NULL)` with `tz` pointing to a 15-byte buffer (`/etc/localtime`)

The source code at `tzset.c:395` explicitly assigns `tz` to point to the string `''/etc/localtime''` without any evident bounds checking or validation for its length (15 bytes)

At `tzset.c:405`, `tz` is passed to `__tzfile_read` with an offset of 0 and no explicit length parameter, implying the function may access `tz` based on its internal expectations

The CVE warning suggests `__tzfile_read` accesses `tz` at byte offset 18, which exceeds the reported 15-byte length of `tz`, indicating a potential buffer overrun

There is no explicit evidence within the provided source code that `__tzfile_read` is designed to handle buffers of exactly 15 bytes or that it performs necessary bounds checking to prevent overruns for buffers of this length

Uncertainty about the internal implementation of `__tzfile_read` (not provided in the context) means we cannot conclusively rule out the vulnerability based solely on the given code and CVE description

Given the direct correlation between the code''s behavior and the described vulnerability, and adhering to the guideline that a single potentially vulnerable path is sufficient, this finding leans towards being a true positive', 'Obtain and analyze the implementation of `__tzfile_read` to determine if it performs necessary bounds checking or is designed to handle buffers of exactly 15 bytes

Verify the expected behavior of `__tzfile_read` when passed a buffer of the same length as `/etc/localtime` (15 bytes) to assess if the reported overrun is a genuine vulnerability', 0.0000, '*** Source Code Context ***

code of time/tzset.c file:
366| static void
367| tzset_internal (int always)
368| {
369|   static int is_initialized;
370|   const char *tz;
371| 
372|   if (is_initialized && !always)
373|     return;
374|   is_initialized = 1;
375| 
376|   /* Examine the TZ environment variable.  */
377|   tz = getenv ("TZ");
378|   if (tz && *tz == ''\0'')
379|     /* User specified the empty string; use UTC explicitly.  */
380|     tz = "Universal";
381| 
382|   /* A leading colon means "implementation defined syntax".
383|      We ignore the colon and always use the same algorithm:
384|      try a data file, and if none exists parse the 1003.1 syntax.  */
385|   if (tz && *tz == '':'')
386|     ++tz;
387| 
388|   /* Check whether the value changed since the last run.  */
389|   if (old_tz != NULL && tz != NULL && strcmp (tz, old_tz) == 0)
390|     /* No change, simply return.  */
391|     return;
392| 
393|   if (tz == NULL)
394|     /* No user specification; use the site-wide default.  */
395|     tz = TZDEFAULT;
396| 
397|   tz_rules[0].name = NULL;
398|   tz_rules[1].name = NULL;
399| 
400|   /* Save the value of `tz''.  */
401|   free (old_tz);
402|   old_tz = tz ? __strdup (tz) : NULL;
403| 
404|   /* Try to read a data file.  */
405|   __tzfile_read (tz, 0, NULL);
406|   if (__use_tzfile)
407|     return;
408| 
409|   /* No data file found.  Default to UTC if nothing specified.  */
410| 
411|   if (tz == NULL || *tz == ''\0''
412|       || (TZDEFAULT != NULL && strcmp (tz, TZDEFAULT) == 0))
413|     {
414|       memset (tz_rules, ''\0'', sizeof tz_rules);
415|       tz_rules[0].name = tz_rules[1].name = "UTC";
416|       if (J0 != 0)
417| 	tz_rules[0].type = tz_rules[1].type = J0;
418|       tz_rules[0].change = tz_rules[1].change = -1;
419|       update_vars ();
420|       return;
421|     }
422| 
423|   __tzset_parse_tz (tz);
424| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|-> 		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|   		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values.  The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:462: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  460|   		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|-> 		      || ((trp = rp, match_string (ab_month_name[cnt], trp))
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.118803');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (306, 100, 'def23', 'OVERRUN', 'cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:885: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483647.
cpio-2.15/gnu/nstrftime.c:885: cond_between: Checking "_n < _w" implies that "_n" is between 0 and 2147483646 (inclusive) on the true branch.
cpio-2.15/gnu/nstrftime.c:885: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)(ubuf + 1)" of 1024 bytes by passing it to a function which accesses it at byte offset 2147483646 using argument "_n" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  883|               len = strftime (ubuf, sizeof ubuf, ufmt, tp);
#  884|               if (len != 0)
#  885|->               cpy (len - 1, ubuf + 1);
#  886|             }
#  887|             break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:885: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483647.
cpio-2.15/gnu/nstrftime.c:885: cond_between: Checking "_n < _w" implies that "_n" is between 0 and 2147483646 (inclusive) on the true branch.
cpio-2.15/gnu/nstrftime.c:885: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)(ubuf + 1)" of 1024 bytes by passing it to a function which accesses it at byte offset 2147483646 using argument "_n" (which evaluates to 2147483646).
#  883|               len = strftime (ubuf, sizeof ubuf, ufmt, tp);
#  884|               if (len != 0)
#  885|->               cpy (len - 1, ubuf + 1);
#  886|             }
#  887|             break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:885: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483647.
cpio-2.15/gnu/nstrftime.c:885: cond_between: Checking "_n < _w" implies that "_n" is between 0 and 2147483646 (inclusive) on the true branch.
cpio-2.15/gnu/nstrftime.c:885: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)(ubuf + 1)" of 1024 bytes by passing it to a function which accesses it at byte offset 2147483646 using argument "_n" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  883|               len = strftime (ubuf, sizeof ubuf, ufmt, tp);
#  884|               if (len != 0)
#  885|->               cpy (len - 1, ubuf + 1);
#  886|             }
#  887|             break;
(Example-1) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L153-196

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
cpio-2.15/gnu/nstrftime.c:689: assignment: Assigning: "width" = "2147483647".
cpio-2.15/gnu/nstrftime.c:1009: alias: Assigning: "bufp" = "buf + 23UL". "bufp" now points to byte 23 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1019: ptr_decr: Decrementing "bufp". "bufp" now points to byte 22 of "buf" (which consists of 23 bytes).
cpio-2.15/gnu/nstrftime.c:1048: decr: Decrementing "width". The value of "width" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: assignment: Assigning: "_w" = "(pad == 45 || width < 0) ? 0 : width". The value of "_w" is now 2147483646.
cpio-2.15/gnu/nstrftime.c:1051: cond_at_most: Checking "_n < _w" implies that "_n" may be up to 2147483645 on the true branch.
cpio-2.15/gnu/nstrftime.c:1051: overrun-buffer-arg: Overrunning buffer pointed to by "(void const *)bufp" of 23 bytes by passing it to a function which accesses it at byte offset 2147483666 using argument "_n" (which evaluates to 2147483645). [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1049|                 }
# 1050|   
# 1051|->             cpy (numlen, bufp);
# 1052|             }
# 1053|             break;
(Example-2) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L153-196

', '2025-11-17 21:39:07.068559');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (307, 100, 'def24', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1207: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|->   file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
#     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
#     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
#->   file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
#     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
#     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1207: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|->   file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1206: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1204|   
# 1205|     file_hdr->c_ino = FROM_OCTAL (ascii_header.c_ino);
# 1206|->   file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068559');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (308, 100, 'def25', 'CPPCHECK_WARNING', 'cpio-2.15/gnu/mktime.c:262: error[returnDanglingLifetime]: Returning pointer to local variable ''x'' that will be invalid when returning.
#  260|   {
#  261|     __time64_t x = t;
#  262|->   return convert (&x, tm);
#  263|   }
#  264|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/mktime.c:262: error[returnDanglingLifetime]: Returning pointer to local variable ''x'' that will be invalid when returning.
#  260|   {
#  261|     __time64_t x = t;
#  262|->   return convert (&x, tm);
#  263|   }
#  264|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-562):
cpio-2.15/gnu/mktime.c:262: error[returnDanglingLifetime]: Returning pointer to local variable ''x'' that will be invalid when returning.
#  260|   {
#  261|     __time64_t x = t;
#  262|->   return convert (&x, tm);
#  263|   }
#  264|
(Example-1) Reason Marked as False Positive:
it calls gmtime_r on the value pointed by x

', '2025-11-17 21:39:07.06856');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (309, 100, 'def26', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1216: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|->   read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|   
# 1218|     /* HP/UX cpio creates archives that look just like ordinary archives,', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1216: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|->   read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|   
# 1218|     /* HP/UX cpio creates archives that look just like ordinary archives,', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1216: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_namesize" when calling "from_ascii".
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|     file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|->   read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|   
# 1218|     /* HP/UX cpio creates archives that look just like ordinary archives,
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1215: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1213|   
# 1214|     file_hdr->c_mtime = FROM_OCTAL (ascii_header.c_mtime);
# 1215|->   file_hdr->c_filesize = FROM_OCTAL (ascii_header.c_filesize);
# 1216|     read_name_from_file (file_hdr, in_des, FROM_OCTAL (ascii_header.c_namesize));
# 1217|
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.06856');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (318, 98, 'def2', 'INTEGER_OVERFLOW', 'audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:739: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr += r" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow: The expression "8970U - io->bufptr" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow_sink: "8970U - io->bufptr", which might have underflowed, is passed to "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  593|   	   data.  */
#  594|   read_more:
#  595|-> 	r = read (io->io.fd,
#  596|   		  io->buffer + io->bufptr,
#  597|   		  MAX_AUDIT_MESSAGE_LENGTH - io->bufptr);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:739: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr += r" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow: The expression "8970U - io->bufptr" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow_sink: "8970U - io->bufptr", which might have underflowed, is passed to "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)".
#  593|   )data.  */
#  594|   read_more:
#  595|-> r = read (io->io.fd,
#  596|   io->buffer + io->bufptr,
#  597|   MAX_AUDIT_MESSAGE_LENGTH - io->bufptr);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:739: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr += r" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow: The expression "8970U - io->bufptr" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow_sink: "8970U - io->bufptr", which might have underflowed, is passed to "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  593|   	   data.  */
#  594|   read_more:
#  595|-> 	r = read (io->io.fd,
#  596|   		  io->buffer + io->bufptr,
#  597|   		  MAX_AUDIT_MESSAGE_LENGTH - io->bufptr);
(Example-1) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:734: overflow: The expression "io->bufptr - i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:734: overflow_sink: "io->bufptr - i", which might have underflowed, is passed to "memmove(io->buffer, io->buffer + i, io->bufptr - i)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  732|   	/* Now copy any remaining bytes to the beginning of the
#  733|   	   buffer.  */
#  734|-> 	memmove(io->buffer, io->buffer + i, io->bufptr - i);
#  735|   	io->bufptr -= i;
#  736|
(Example-2) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again. Thus, memmove() will not receive an underflowed arg.

', '2025-11-17 21:39:07.076106');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (310, 100, 'def27', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1266: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_filesize" when calling "from_ascii".
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|->   file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
# 1268|     file_hdr->c_dev_min = FROM_HEX (ascii_header.c_dev_min);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1265: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|->   file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.06856');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (311, 100, 'def28', 'INTEGER_OVERFLOW', 'cpio-2.15/lib/rtapelib.c:604: tainted_data_return: Called function "get_status(handle)", and a possible return value may be less than zero.
cpio-2.15/lib/rtapelib.c:604: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
cpio-2.15/lib/rtapelib.c:611: overflow: The expression "status - counter" is deemed underflowed because at least one of its arguments has underflowed.
cpio-2.15/lib/rtapelib.c:611: overflow_sink: "status - counter", which might have underflowed, is passed to "safe_read(from_remote[handle][0], buffer, status - counter)".
#  609|     for (counter = 0; counter < status; counter += rlen, buffer += rlen)
#  610|       {
#  611|->       rlen = safe_read (READ_SIDE (handle), buffer, status - counter);
#  612|         if (rlen == SAFE_READ_ERROR || rlen == 0)
#  613|   	{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/lib/rtapelib.c: tainted_data_return: Called function "get_status(handle)", and a possible return value may be less than zero.
cpio-2.15/lib/rtapelib.c: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
cpio-2.15/lib/rtapelib.c: overflow: The expression "status - counter" is deemed underflowed because at least one of its arguments has underflowed.
cpio-2.15/lib/rtapelib.c: overflow_sink: "status - counter", which might have underflowed, is passed to "safe_read(from_remote[handle][0], buffer, status - counter)".
#     for (counter = 0; counter < status; counter += rlen, buffer += rlen)
#       {
#->       rlen = safe_read (READ_SIDE (handle), buffer, status - counter);
#         if (rlen == SAFE_READ_ERROR || rlen == 0)
#   {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
cpio-2.15/lib/rtapelib.c:604: tainted_data_return: Called function "get_status(handle)", and a possible return value may be less than zero.
cpio-2.15/lib/rtapelib.c:604: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
cpio-2.15/lib/rtapelib.c:611: overflow: The expression "status - counter" is deemed underflowed because at least one of its arguments has underflowed.
cpio-2.15/lib/rtapelib.c:611: overflow_sink: "status - counter", which might have underflowed, is passed to "safe_read(from_remote[handle][0], buffer, status - counter)".
#  609|     for (counter = 0; counter < status; counter += rlen, buffer += rlen)
#  610|       {
#  611|->       rlen = safe_read (READ_SIDE (handle), buffer, status - counter);
#  612|         if (rlen == SAFE_READ_ERROR || rlen == 0)
#  613|   	{
(Example-1) Reason Marked as False Positive:
get_status may return values from range <-1; LONG_INT_MAX>. If it returns -1 (that is equal to SAFE_READ_ERROR), then the rmr_read__ function returns on line 607

', '2025-11-17 21:39:07.068561');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (312, 100, 'def29', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1262: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|->   file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
#     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
#     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
#->   file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
#     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
#     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1262: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_uid" when calling "from_ascii".
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|     file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|->   file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1261: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mode" when calling "from_ascii".
# 1259|   
# 1260|     file_hdr->c_ino = FROM_HEX (ascii_header.c_ino);
# 1261|->   file_hdr->c_mode = FROM_HEX (ascii_header.c_mode);
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068561');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (313, 100, 'def30', 'UNINIT', 'cpio-2.15/gnu/parse-datetime.c:1634: var_decl: Declaring variable "yylval" without initializer.
cpio-2.15/gnu/parse-datetime.c:2643: uninit_use: Using uninitialized value "yylval".
# 2641|   
# 2642|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 2643|->   *++yyvsp = yylval;
# 2644|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 2645|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/parse-datetime.c: var_decl: Declaring variable "yylval" without initializer.
cpio-2.15/gnu/parse-datetime.c: uninit_use: Using uninitialized value "yylval".
#     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
#->   *++yyvsp = yylval;
#     YY_IGNORE_MAYBE_UNINITIALIZED_END', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/parse-datetime.c:1634: var_decl: Declaring variable "yylval" without initializer.
cpio-2.15/gnu/parse-datetime.c:2643: uninit_use: Using uninitialized value "yylval".
# 2641|   
# 2642|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 2643|->   *++yyvsp = yylval;
# 2644|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 2645|
(Example-1) Reason Marked as False Positive:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:310: uninit_use: Using uninitialized value "tm_1". Field "tm_1.tm_gmtoff" is uninitialized.
#  308|             if (revert_tz (old_tz) && ok)
#  309|               {
#  310|->               *tm = tm_1;
#  311|                 return t;
#  312|               }
(Example-2) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L220-228

', '2025-11-17 21:39:07.068561');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (319, 98, 'def3', 'INTEGER_OVERFLOW', 'audit-4.0/src/auditd-listen.c:171: tainted_data_return: Called function "write(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:171: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:178: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:171: overflow_sink: "len", which might have overflowed, is passed to "write(sock, buf, len)".
#  169|           while (len > 0) {
#  170|                   do {
#  171|->                         w = write(sock, buf, len);
#  172|                   } while (w < 0 && errno == EINTR);
#  173|                   if (w < 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/auditd-listen.c:171: tainted_data_return: Called function "write(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:171: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:178: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:171: overflow_sink: "len", which might have overflowed, is passed to "write(sock, buf, len)".
#  169|           while (len > 0) {
#  170|                   do {
#  171|->                         w = write(sock, buf, len);
#  172|                   } while (w < 0 && errno == EINTR);
#  173|                   if (w < 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:171: tainted_data_return: Called function "write(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:171: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:178: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:171: overflow_sink: "len", which might have overflowed, is passed to "write(sock, buf, len)".
#  169|           while (len > 0) {
#  170|                   do {
#  171|->                         w = write(sock, buf, len);
#  172|                   } while (w < 0 && errno == EINTR);
#  173|                   if (w < 0)
(Example-1) Reason Marked as False Positive:
If the return value of write() is less than zero, it is handled appropriately, ensuring that it will not be negative if write() is called again

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:190: tainted_data_return: Called function "read(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:190: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:197: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:190: overflow_sink: "len", which might have overflowed, is passed to "read(sock, buf, len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  188|   	while (len > 0) {
#  189|   		do {
#  190|-> 			r = read(sock, buf, len);
#  191|   		} while (r < 0 && errno == EINTR);
#  192|   		if (r < 0)
(Example-2) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again

', '2025-11-17 21:39:07.076106');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (314, 100, 'def31', 'UNINIT', 'cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:306: uninit_use_in_call: Using uninitialized value "tm_1.tm_zone" when calling "save_abbr".
#  304|             bool ok = 0 <= tm_1.tm_yday;
#  305|   #if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME
#  306|->           ok = ok && save_abbr (tz, &tm_1);
#  307|   #endif
#  308|             if (revert_tz (old_tz) && ok)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:306: uninit_use_in_call: Using uninitialized value "tm_1.tm_zone" when calling "save_abbr".
#  304|             bool ok = 0 <= tm_1.tm_yday;
#  305|   #if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME
#  306|->           ok = ok && save_abbr (tz, &tm_1);
#  307|   #endif
#  308|             if (revert_tz (old_tz) && ok)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:306: uninit_use_in_call: Using uninitialized value "tm_1.tm_zone" when calling "save_abbr".
#  304|             bool ok = 0 <= tm_1.tm_yday;
#  305|   #if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME
#  306|->           ok = ok && save_abbr (tz, &tm_1);
#  307|   #endif
#  308|             if (revert_tz (old_tz) && ok)
(Example-1) Reason Marked as False Positive:


** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/gnu/time_rz.c:294: var_decl: Declaring variable "tm_1" without initializer.
cpio-2.15/gnu/time_rz.c:310: uninit_use: Using uninitialized value "tm_1". Field "tm_1.tm_gmtoff" is uninitialized.
#  308|             if (revert_tz (old_tz) && ok)
#  309|               {
#  310|->               *tm = tm_1;
#  311|                 return t;
#  312|               }
(Example-2) Reason Marked as False Positive:
Already reported in findutils: https://gitlab.cee.redhat.com/osh/known-false-positives/-/blob/afb31e8b8cbad27421a5c3aac1f9c2da81a8af2c/findutils/ignore.err#L220-228

', '2025-11-17 21:39:07.068562');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (315, 100, 'def32', 'UNINIT', 'cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1208: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|->   file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1208: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|->   file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1208: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_gid" when calling "from_ascii".
# 1206|     file_hdr->c_mode = FROM_OCTAL (ascii_header.c_mode);
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|->   file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|     file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1196: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1209: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1207|     file_hdr->c_uid = FROM_OCTAL (ascii_header.c_uid);
# 1208|     file_hdr->c_gid = FROM_OCTAL (ascii_header.c_gid);
# 1209|->   file_hdr->c_nlink = FROM_OCTAL (ascii_header.c_nlink);
# 1210|     dev = FROM_OCTAL (ascii_header.c_rdev);
# 1211|     file_hdr->c_rdev_maj = major (dev);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068562');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (316, 100, 'def33', 'UNINIT', 'cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1264: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|->   file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1264: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|->   file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1264: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_nlink" when calling "from_ascii".
# 1262|     file_hdr->c_uid = FROM_HEX (ascii_header.c_uid);
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|->   file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|     file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
(Example-1) Reason Marked as False Positive:
initialized by the "tape_buffered read"

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
cpio-2.15/src/copyin.c:1255: var_decl: Declaring variable "ascii_header" without initializer.
cpio-2.15/src/copyin.c:1265: uninit_use_in_call: Using uninitialized element of array "ascii_header.c_mtime" when calling "from_ascii".
# 1263|     file_hdr->c_gid = FROM_HEX (ascii_header.c_gid);
# 1264|     file_hdr->c_nlink = FROM_HEX (ascii_header.c_nlink);
# 1265|->   file_hdr->c_mtime = FROM_HEX (ascii_header.c_mtime);
# 1266|     file_hdr->c_filesize = FROM_HEX (ascii_header.c_filesize);
# 1267|     file_hdr->c_dev_maj = FROM_HEX (ascii_header.c_dev_maj);
(Example-2) Reason Marked as False Positive:
initialized by the "tape_buffered read"

', '2025-11-17 21:39:07.068562');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (317, 98, 'def1', 'OVERRUN', 'audit-4.0/auparse/auparse.c:514: strlen_assign: Setting variable "len" to the return value of strlen called with argument "buf".
audit-4.0/auparse/auparse.c:515: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  513|   				goto bad_exit;
#  514|   			len = strlen(buf);
#  515|-> 			if (databuf_init(&au->databuf, len,
#  516|   					 DATABUF_FLAG_PRESERVE_HEAD) < 0)
#  517|   				goto bad_exit;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/auparse/auparse.c:514: strlen_assign: Setting variable "len" to the return value of strlen called with argument "buf".
audit-4.0/auparse/auparse.c:515: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  513|   .goto bad_exit;
#  514|    len = strlen(buf);
#  515|->  if (databuf_init(&au->databuf, len,
#  516|    DATABUF_FLAG_PRESERVE_HEAD) < 0)
#  517|   .goto bad_exit;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/auparse/auparse.c:514: strlen_assign: Setting variable "len" to the return value of strlen called with argument "buf".
audit-4.0/auparse/auparse.c:515: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  513|   				goto bad_exit;
#  514|   			len = strlen(buf);
#  515|-> 			if (databuf_init(&au->databuf, len,
#  516|   					 DATABUF_FLAG_PRESERVE_HEAD) < 0)
#  517|   				goto bad_exit;
(Example-1) Reason Marked as False Positive:
Data inside databuf does not need to be null-terminated because the length is tracked internally, memory copy/move operations are performed based on the actual length.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/tools/aulast/aulast.c:286: alias: Assigning: "term" = ""?"". "term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:350: alias: Assigning: "n.term" = "term". "n.term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:357: overrun-buffer-val: Overrunning buffer pointed to by "n.term" of 2 bytes by passing it to a function which accesses it at byte offset 4.
#  355|   		n.user_login_proof = auparse_get_serial(au);
#  356|   		n.user_end_proof = 0;
#  357|-> 		report_session(&n); 
#  358|   	} else if (debug)
#  359|   		printf("Session not found or updated
");
(Example-2) Reason Marked as False Positive:
If n.term has a length of 2 bytes, it will not be accessed at byte offset 4. The strncmp function will not compare beyond 2 bytes even if the third argument is set to 5.

', '2025-11-17 21:39:07.076104');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (341, 105, 'def11', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "w" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);', 'FALSE POSITIVE', 'The `memcpy` call at line 5798 with a large index is deemed safe since `m` (of type `mpd_size_t`, an unsigned type) is intentionally calculated as an unsigned value (`m = (la+1)/2;` at line 5765), making the large index an expected behavior rather than a sign of buffer overrun due to signed-unsigned interpretation.', 'The reported issue revolves around the large index value (25769803784) in the `memcpy` call at line 5798, suggesting a potential buffer overrun due to a negative parameter being interpreted as unsigned.

However, the code explicitly defines `m` as an unsigned value (`mpd_size_t m;`) at line 5742, which is a common type for sizes and indices in C, implying that large values are expected and handled appropriately.

The assignment of `m` at line 5765 (`m = (la+1)/2;`) is also explicitly unsigned, as both `la` and the literal `1` are unsigned, ensuring that `m` will always be a non-negative value.

The condition at line 5747 (`if (la <= 3*(MPD_MAXTRANSFORM_2N/2))`) and its implication on `la`''s value do not directly influence the signedness or the potential for overflow of `m` in the context of the `memcpy` call at line 5798.

Given that `m` is unsigned and its large value is a result of intentional unsigned arithmetic, the suspicion of a negative parameter being interpreted as unsigned is unfounded in this context.

The provided examples (Example-1 and Example-2) further support this conclusion, as they were marked as FALSE POSITIVE for the same reason: the numbers in question are unsigned, making the large values expected behavior.', NULL, 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5738| static int
5739| _karatsuba_rec_fnt(mpd_uint_t *c, const mpd_uint_t *a, const mpd_uint_t *b,
5740|                    mpd_uint_t *w, mpd_size_t la, mpd_size_t lb)
5741| {
5742|     mpd_size_t m, lt;
5743| 
5744|     assert(la >= lb && lb > 0);
5745|     assert(la <= 3*(MPD_MAXTRANSFORM_2N/2) || w != NULL);
5746| 
5747|     if (la <= 3*(MPD_MAXTRANSFORM_2N/2)) {
5748| 
5749|         if (lb <= 192) {
5750|             _mpd_basemul(c, b, a, lb, la);
5751|         }
5752|         else {
5753|             mpd_uint_t *result;
5754|             mpd_size_t dummy;
5755| 
5756|             if ((result = _mpd_fntmul(a, b, la, lb, &dummy)) == NULL) {
5757|                 return 0;
5758|             }
5759|             memcpy(c, result, (la+lb) * (sizeof *result));
5760|             mpd_free(result);
5761|         }
5762|         return 1;
5763|     }
5764| 
5765|     m = (la+1)/2;  /* ceil(la/2) */
5766| 
5767|     /* lb <= m < la */
5768|     if (lb <= m) {
5769| 
5770|         /* lb can now be larger than la-m */
5771|         if (lb > la-m) {
5772|             lt = lb + lb + 1;       /* space needed for result array */
5773|             mpd_uint_zero(w, lt);   /* clear result array */
5774|             if (!_karatsuba_rec_fnt(w, b, a+m, w+lt, lb, la-m)) { /* b*ah */
5775|                 return 0; /* GCOV_UNLIKELY */
5776|             }
5777|         }
5778|         else {
5779|             lt = (la-m) + (la-m) + 1;  /* space needed for result array */
5780|             mpd_uint_zero(w, lt);      /* clear result array */
5781|             if (!_karatsuba_rec_fnt(w, a+m, b, w+lt, la-m, lb)) { /* ah*b */
5782|                 return 0; /* GCOV_UNLIKELY */
5783|             }
5784|         }
5785|         _mpd_baseaddto(c+m, w, (la-m)+lb); /* add ah*b*B**m */
5786| 
5787|         lt = m + m + 1;         /* space needed for the result array */
5788|         mpd_uint_zero(w, lt);   /* clear result array */
5789|         if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
5790|             return 0; /* GCOV_UNLIKELY */
5791|         }
5792|         _mpd_baseaddto(c, w, m+lb);       /* add al*b */
5793| 
5794|         return 1;
5795|     }
5796| 
5797|     /* la >= lb > m */
5798|     memcpy(w, a, m * sizeof *w);
5799|     w[m] = 0;
5800|     _mpd_baseaddto(w, a+m, la-m);
5801| 
5802|     memcpy(w+(m+1), b, m * sizeof *w);
5803|     w[m+1+m] = 0;
5804|     _mpd_baseaddto(w+(m+1), b+m, lb-m);
5805| 
5806|     if (!_karatsuba_rec_fnt(c+m, w, w+(m+1), w+2*(m+1), m+1, m+1)) {
5807|         return 0; /* GCOV_UNLIKELY */
5808|     }
5809| 
5810|     lt = (la-m) + (la-m) + 1;
5811|     mpd_uint_zero(w, lt);
5812| 
5813|     if (!_karatsuba_rec_fnt(w, a+m, b+m, w+lt, la-m, lb-m)) {
5814|         return 0; /* GCOV_UNLIKELY */
5815|     }
5816| 
5817|     _mpd_baseaddto(c+2*m, w, (la-m) + (lb-m));
5818|     _mpd_basesubfrom(c+m, w, (la-m) + (lb-m));
5819| 
5820|     lt = m + m + 1;
5821|     mpd_uint_zero(w, lt);
5822| 
5823|     if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
5824|         return 0; /* GCOV_UNLIKELY */
5825|     }
5826|     _mpd_baseaddto(c, w, m+m);
5827|     _mpd_basesubfrom(c+m, w, m+m);
5828| 
5829|     return 1;
5830| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "w" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "a" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082775');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (320, 98, 'def4', 'INTEGER_OVERFLOW', 'audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:971: overflow: The expression "count" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: overflow_sink: "(unsigned int)count", which might have overflowed, is passed to "write(o, &loginuid[offset], (unsigned int)count)".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {', 'TRUE POSITIVE', 'Potential integer overflow in `count` variable (lines 955, 961, 971) due to casting to `(unsigned int)` and loop arithmetic, with no explicit handling for overflow scenarios, directly correlating with CWE-190 (Integer Overflow) vulnerability.', '1. **Potential Negative Return Value**: The CVE report highlights a ''tainted_data_return'' at line 961, indicating the `write` function may return a value less than zero. The code indeed checks for this condition at line 963 (`if (block < 0)`), but this alone doesn''t negate the vulnerability; it merely handles one symptom (error handling) rather than the root cause (potential overflow leading to incorrect `write` behavior).

2. **Cast Overflow Risk**: The ''cast_overflow'' warning at line 961 suggests that casting `count` to an `(unsigned int)` might trigger an overflow. Given that `count` is initially set based on the return value of `snprintf` (line 955), which can theoretically return a value equal to or greater than the buffer size (though unlikely in this specific `uid` to string conversion context), the cast could potentially mask a signed overflow if `count` were negative (e.g., due to an error in `snprintf`).

3. **Overflow Concern for ''count''**: The warning at line 971 about ''overflow'' for the expression ''count'' indicates that the loop''s decrement operation (`count -= block;`) might overflow if `block` is larger than `count`, or if `count` is at its minimum value (though the latter is practically impossible given its initial assignment). This could lead to an infinite loop or unexpected behavior, depending on the system''s integer overflow behavior.

4. **Uncertainty Regarding ''count'' Overflow Handling**: While the code checks for errors and handles negative return values from `write`, there''s no explicit handling for the scenario where `count` overflows during the loop, leading to uncertainty about the code''s behavior in such an edge case.

5. **Direct Correlation to CWE-190 (Integer Overflow)**: The described vulnerabilities directly correlate with CWE-190, which involves integer overflows, underflows, or wrap-arounds. Given the potential for `count` to overflow (either through the cast or the loop''s arithmetic operations), this aligns with the CWE''s definition.', 'Verify the maximum possible value returned by ''snprintf'' in the context of converting a ''uid'' to a string and its implications on ''count''s initial value.

Analyze the system''s behavior in case of integer overflow to understand the potential impact on the loop''s decrement operation (''count -= block;'').

Examine the declaration and assignment of ''offset'' to ensure it cannot overflow or go out of bounds for the ''loginuid'' array, given its usage in ''loginuid[offset]''.

Evaluate the error handling for ''snprintf'' to ensure that any potential errors leading to an unexpectedly large or negative ''count'' are properly managed.', 0.0000, '*** Source Code Context ***

code of lib/libaudit.c file:
949| int audit_setloginuid(uid_t uid)
950| {
951| 	char loginuid[16];
952| 	int o, count, rc = 0;
953| 
954| 	errno = 0;
955| 	count = snprintf(loginuid, sizeof(loginuid), "%u", uid);
956| 	o = open("/proc/self/loginuid", O_NOFOLLOW|O_WRONLY|O_TRUNC|O_CLOEXEC);
957| 	if (o >= 0) {
958| 		int block, offset = 0;
959| 
960| 		while (count > 0) {
961| 			block = write(o, &loginuid[offset], (unsigned)count);
962| 
963| 			if (block < 0) {
964| 				if (errno == EINTR)
965| 					continue;
966| 				audit_msg(LOG_ERR, "Error writing loginuid");
967| 				close(o);
968| 				return 1;
969| 			}
970| 			offset += block;
971| 			count -= block;
972| 		}
973| 		close(o);
974| 	} else {
975| 		audit_msg(LOG_ERR, "Error opening /proc/self/loginuid");
976| 		rc = 1;
977| 	}
978| 	return rc;
979| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:971: overflow: The expression "count" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: overflow_sink: "(unsigned int)count", which might have overflowed, is passed to "write(o, &loginuid[offset], (unsigned int)count)".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {
(Example-1) Reason Marked as False Positive:
By converting an unsigned integer and storing it in a char[16] array, the resulting string will always fit within 16 characters due to the maximum size of an unsigned integer.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:970: overflow: The expression "offset" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: deref_overflow: "offset", which might have overflowed, is used in a pointer index in "loginuid[offset]".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {
(Example-2) Reason Marked as False Positive:
By converting an unsigned integer and storing it in a char[16] array, the resulting string will always fit within 16 characters due to the maximum size of an unsigned integer.

', '2025-11-17 21:39:07.076106');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (321, 98, 'def5', 'USE_AFTER_FREE', 'audit-4.0/src/auditd-event.c:1487: alias: Equality between "oconf->plugin_dir" and "nconf->plugin_dir" implies that they are aliases.
audit-4.0/src/auditd-event.c:1490: freed_arg: "free" frees "oconf->plugin_dir".
audit-4.0/src/auditd-event.c:1491: use_after_free: Using freed pointer "nconf->plugin_dir".
# 1489|                   strcmp(oconf->plugin_dir, nconf->plugin_dir) != 0)) {
# 1490|                   free(oconf->plugin_dir);
# 1491|->                 oconf->plugin_dir = nconf->plugin_dir;
# 1492|           }
# 1493|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/auditd-event.c: alias: Equality between "oconf->plugin_dir" and "nconf->plugin_dir" implies that they are aliases.
audit-4.0/src/auditd-event.c: freed_arg: "free" frees "oconf->plugin_dir".
audit-4.0/src/auditd-event.c: use_after_free: Using freed pointer "nconf->plugin_dir".
#                   strcmp(oconf->plugin_dir, nconf->plugin_dir) != 0)) {
#                   free(oconf->plugin_dir);
#->                 oconf->plugin_dir = nconf->plugin_dir;
#           }
#           ', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
audit-4.0/src/auditd-event.c:1487: alias: Equality between "oconf->plugin_dir" and "nconf->plugin_dir" implies that they are aliases.
audit-4.0/src/auditd-event.c:1490: freed_arg: "free" frees "oconf->plugin_dir".
audit-4.0/src/auditd-event.c:1491: use_after_free: Using freed pointer "nconf->plugin_dir".
# 1489|                   strcmp(oconf->plugin_dir, nconf->plugin_dir) != 0)) {
# 1490|                   free(oconf->plugin_dir);
# 1491|->                 oconf->plugin_dir = nconf->plugin_dir;
# 1492|           }
# 1493|
(Example-1) Reason Marked as False Positive:
oconf->plugin_dir and nconf->plugin_dir are never aliases. Both are malloced and initialized at the beginning of their lifetime.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
audit-4.0/auparse/lru.c:120: freed_arg: "dequeue" frees "queue->end".
audit-4.0/auparse/lru.c:120: deref_arg: Calling "dequeue" dereferences freed pointer "queue->end".
#  118|   
#  119|           while (queue->count)
#  120|->                 dequeue(queue);
#  121|   
#  122|           free(queue);
(Example-2) Reason Marked as False Positive:
The dequeue function will not dereference a freed pointer. We loop while queue->count is greater than 0, removing the end node from the queue in each iteration. Additionally, there is an extra check to verify that the queue is not empty.

', '2025-11-17 21:39:07.076107');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (322, 98, 'def6', 'CPPCHECK_WARNING', 'audit-4.0/src/ausearch-parse.c:1737: error[memleak]: Memory leak: sn.str
# 1735|   							strdup(un->sun_path+1);
# 1736|   						else
# 1737|-> 							return 6;
# 1738|   
# 1739|   						sn.key = NULL;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/ausearch-parse.c: error[memleak]: Memory leak: sn.str
    strdup(un->sun_path+1);
    else
->                          return 6;
   
    sn.key = NULL;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-401):
audit-4.0/src/ausearch-parse.c:1737: error[memleak]: Memory leak: sn.str
# 1735|   							strdup(un->sun_path+1);
# 1736|   						else
# 1737|-> 							return 6;
# 1738|   
# 1739|   						sn.key = NULL;
(Example-1) Reason Marked as False Positive:
There is malloc called for sn.str at all, thus no memory to free.

** Example-2 **
(Example-2) Known False Positive:
Error CPPCHECK_WARNING (CWE-401):
audit-4.0/auparse/ellist.c:316: error[memleak]: Memory leak: n.name
#  314|                                                                            == 0)
#  315|                                                                   free(buf);
#  316|->                                                         return -1;
#  317|                                                   }
#  318|                                                   if (tmpctx[0]) {
(Example-2) Reason Marked as False Positive:
No memory is allocated for .name variable, thuse we don''t need to free anything here.

', '2025-11-17 21:39:07.076107');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (323, 98, 'def7', 'INTEGER_OVERFLOW', 'audit-4.0/src/auditd-listen.c:190: tainted_data_return: Called function "read(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:190: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:197: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:190: overflow_sink: "len", which might have overflowed, is passed to "read(sock, buf, len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  188|   	while (len > 0) {
#  189|   		do {
#  190|-> 			r = read(sock, buf, len);
#  191|   		} while (r < 0 && errno == EINTR);
#  192|   		if (r < 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/auditd-listen.c:190: tainted_data_return: Called function "read(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:190: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:197: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:190: overflow_sink: "len", which might have overflowed, is passed to "read(sock, buf, len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  188|    while (len > 0) {
#  189|       do {
#  190|->           r = read(sock, buf, len);
#  191|       } while (r < 0 && errno == EINTR);
#  192|       if (r < 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:190: tainted_data_return: Called function "read(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:190: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:197: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:190: overflow_sink: "len", which might have overflowed, is passed to "read(sock, buf, len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  188|   	while (len > 0) {
#  189|   		do {
#  190|-> 			r = read(sock, buf, len);
#  191|   		} while (r < 0 && errno == EINTR);
#  192|   		if (r < 0)
(Example-1) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:171: tainted_data_return: Called function "write(sock, buf, len)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:171: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:178: overflow: The expression "len" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:171: overflow_sink: "len", which might have overflowed, is passed to "write(sock, buf, len)".
#  169|           while (len > 0) {
#  170|                   do {
#  171|->                         w = write(sock, buf, len);
#  172|                   } while (w < 0 && errno == EINTR);
#  173|                   if (w < 0)
(Example-2) Reason Marked as False Positive:
If the return value of write() is less than zero, it is handled appropriately, ensuring that it will not be negative if write() is called again

', '2025-11-17 21:39:07.076107');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (324, 98, 'def8', 'OVERRUN', 'audit-4.0/tools/aulast/aulast.c:286: alias: Assigning: "term" = ""?"". "term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:350: alias: Assigning: "n.term" = "term". "n.term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:357: overrun-buffer-val: Overrunning buffer pointed to by "n.term" of 2 bytes by passing it to a function which accesses it at byte offset 4.
#  355|   		n.user_login_proof = auparse_get_serial(au);
#  356|   		n.user_end_proof = 0;
#  357|-> 		report_session(&n); 
#  358|   	} else if (debug)
#  359|   		printf("Session not found or updated\n");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/tools/aulast/aulast.c:286: alias: Assigning: "term" = ""?"". "term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:350: alias: Assigning: "n.term" = "term". "n.term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:357: overrun-buffer-val: Overrunning buffer pointed to by "n.term" of 2 bytes by passing it to a function which accesses it at byte offset 4.
#  355|    n.user_login_proof = auparse_get_serial(au);
#  356|    n.user_end_proof = 0;
#  357|-> report_session(&n);
#  358|   } else if (debug)
#  359|    printf("Session not found or updated\n");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/tools/aulast/aulast.c:286: alias: Assigning: "term" = ""?"". "term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:350: alias: Assigning: "n.term" = "term". "n.term" now points to byte 0 of ""?"" (which consists of 2 bytes).
audit-4.0/tools/aulast/aulast.c:357: overrun-buffer-val: Overrunning buffer pointed to by "n.term" of 2 bytes by passing it to a function which accesses it at byte offset 4.
#  355|   		n.user_login_proof = auparse_get_serial(au);
#  356|   		n.user_end_proof = 0;
#  357|-> 		report_session(&n); 
#  358|   	} else if (debug)
#  359|   		printf("Session not found or updated
");
(Example-1) Reason Marked as False Positive:
If n.term has a length of 2 bytes, it will not be accessed at byte offset 4. The strncmp function will not compare beyond 2 bytes even if the third argument is set to 5.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
audit-4.0/auparse/auparse.c:514: strlen_assign: Setting variable "len" to the return value of strlen called with argument "buf".
audit-4.0/auparse/auparse.c:515: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  513|   				goto bad_exit;
#  514|   			len = strlen(buf);
#  515|-> 			if (databuf_init(&au->databuf, len,
#  516|   					 DATABUF_FLAG_PRESERVE_HEAD) < 0)
#  517|   				goto bad_exit;
(Example-2) Reason Marked as False Positive:
Data inside databuf does not need to be null-terminated because the length is tracked internally, memory copy/move operations are performed based on the actual length.

', '2025-11-17 21:39:07.076108');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (325, 98, 'def9', 'INTEGER_OVERFLOW', 'audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:970: overflow: The expression "offset" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: deref_overflow: "offset", which might have overflowed, is used in a pointer index in "loginuid[offset]".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:970: overflow: The expression "offset" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: deref_overflow: "offset", which might have overflowed, is used in a pointer index in "loginuid[offset]".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-125):
audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:970: overflow: The expression "offset" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: deref_overflow: "offset", which might have overflowed, is used in a pointer index in "loginuid[offset]".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {
(Example-1) Reason Marked as False Positive:
By converting an unsigned integer and storing it in a char[16] array, the resulting string will always fit within 16 characters due to the maximum size of an unsigned integer.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/lib/libaudit.c:961: tainted_data_return: Called function "write(o, &loginuid[offset], (unsigned int)count)", and a possible return value may be less than zero.
audit-4.0/lib/libaudit.c:961: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/lib/libaudit.c:971: overflow: The expression "count" is considered to have possibly overflowed.
audit-4.0/lib/libaudit.c:961: overflow_sink: "(unsigned int)count", which might have overflowed, is passed to "write(o, &loginuid[offset], (unsigned int)count)".
#  959|   
#  960|                   while (count > 0) {
#  961|->                         block = write(o, &loginuid[offset], (unsigned)count);
#  962|   
#  963|                           if (block < 0) {
(Example-2) Reason Marked as False Positive:
By converting an unsigned integer and storing it in a char[16] array, the resulting string will always fit within 16 characters due to the maximum size of an unsigned integer.

', '2025-11-17 21:39:07.076108');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (326, 98, 'def10', 'INTEGER_OVERFLOW', 'audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:734: overflow: The expression "io->bufptr - i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:734: overflow_sink: "io->bufptr - i", which might have underflowed, is passed to "memmove(io->buffer, io->buffer + i, io->bufptr - i)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  732|   	/* Now copy any remaining bytes to the beginning of the
#  733|   	   buffer.  */
#  734|-> 	memmove(io->buffer, io->buffer + i, io->bufptr - i);
#  735|   	io->bufptr -= i;
#  736|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:734: overflow: The expression "io->bufptr - i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:734: overflow_sink: "io->bufptr - i", which might have underflowed, is passed to "memmove(io->buffer, io->buffer + i, io->bufptr - i)".
#  732|    /* Now copy any remaining bytes to the beginning of the
#  733|    buffer.  */
#  734|->  memmove(io->buffer, io->buffer + i, io->bufptr - i);
#  735|    io->bufptr -= i;
#  736|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:734: overflow: The expression "io->bufptr - i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:734: overflow_sink: "io->bufptr - i", which might have underflowed, is passed to "memmove(io->buffer, io->buffer + i, io->bufptr - i)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  732|   	/* Now copy any remaining bytes to the beginning of the
#  733|   	   buffer.  */
#  734|-> 	memmove(io->buffer, io->buffer + i, io->bufptr - i);
#  735|   	io->bufptr -= i;
#  736|
(Example-1) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again. Thus, memmove() will not receive an underflowed arg.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
audit-4.0/src/auditd-listen.c:595: tainted_data_return: Called function "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)", and a possible return value may be less than zero.
audit-4.0/src/auditd-listen.c:595: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr" is considered to have possibly overflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed overflowed because at least one of its arguments has overflowed.
audit-4.0/src/auditd-listen.c:739: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
audit-4.0/src/auditd-listen.c:637: overflow: The expression "io->bufptr += r" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:735: overflow: The expression "io->bufptr -= i" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow: The expression "8970U - io->bufptr" is deemed underflowed because at least one of its arguments has underflowed.
audit-4.0/src/auditd-listen.c:595: overflow_sink: "8970U - io->bufptr", which might have underflowed, is passed to "read(io->io.fd, io->buffer + io->bufptr, 8970U - io->bufptr)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  593|   	   data.  */
#  594|   read_more:
#  595|-> 	r = read (io->io.fd,
#  596|   		  io->buffer + io->bufptr,
#  597|   		  MAX_AUDIT_MESSAGE_LENGTH - io->bufptr);
(Example-2) Reason Marked as False Positive:
If the return value of read() is less than zero, it is handled appropriately, ensuring that it will not be negative if read() is called again

', '2025-11-17 21:39:07.076108');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (327, 98, 'def11', 'USE_AFTER_FREE', 'audit-4.0/auparse/lru.c:120: freed_arg: "dequeue" frees "queue->end".
audit-4.0/auparse/lru.c:120: deref_arg: Calling "dequeue" dereferences freed pointer "queue->end".
#  118|   
#  119|           while (queue->count)
#  120|->                 dequeue(queue);
#  121|   
#  122|           free(queue);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/auparse/lru.c:120: freed_arg: "dequeue" frees "queue->end".
audit-4.0/auparse/lru.c:120: deref_arg: Calling "dequeue" dereferences freed pointer "queue->end".
#  118|   
#  119|           while (queue->count)
#  120|->                 dequeue(queue);
#  121|   
#  122|           free(queue);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
audit-4.0/auparse/lru.c:120: freed_arg: "dequeue" frees "queue->end".
audit-4.0/auparse/lru.c:120: deref_arg: Calling "dequeue" dereferences freed pointer "queue->end".
#  118|   
#  119|           while (queue->count)
#  120|->                 dequeue(queue);
#  121|   
#  122|           free(queue);
(Example-1) Reason Marked as False Positive:
The dequeue function will not dereference a freed pointer. We loop while queue->count is greater than 0, removing the end node from the queue in each iteration. Additionally, there is an extra check to verify that the queue is not empty.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
audit-4.0/src/auditd-event.c:1487: alias: Equality between "oconf->plugin_dir" and "nconf->plugin_dir" implies that they are aliases.
audit-4.0/src/auditd-event.c:1490: freed_arg: "free" frees "oconf->plugin_dir".
audit-4.0/src/auditd-event.c:1491: use_after_free: Using freed pointer "nconf->plugin_dir".
# 1489|                   strcmp(oconf->plugin_dir, nconf->plugin_dir) != 0)) {
# 1490|                   free(oconf->plugin_dir);
# 1491|->                 oconf->plugin_dir = nconf->plugin_dir;
# 1492|           }
# 1493|
(Example-2) Reason Marked as False Positive:
oconf->plugin_dir and nconf->plugin_dir are never aliases. Both are malloced and initialized at the beginning of their lifetime.

', '2025-11-17 21:39:07.076109');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (328, 98, 'def12', 'CPPCHECK_WARNING', 'audit-4.0/auparse/ellist.c:316: error[memleak]: Memory leak: n.name
#  314|                                                                            == 0)
#  315|                                                                   free(buf);
#  316|->                                                         return -1;
#  317|                                                   }
#  318|                                                   if (tmpctx[0]) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: audit-4.0/auparse/ellist.c: error[memleak]: Memory leak: n.name
#                                                                            == 0)
#                                                                   free(buf);
#->                                                         return -1;
#                                                   }
#                                                   if (tmpctx[0]) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-401):
audit-4.0/auparse/ellist.c:316: error[memleak]: Memory leak: n.name
#  314|                                                                            == 0)
#  315|                                                                   free(buf);
#  316|->                                                         return -1;
#  317|                                                   }
#  318|                                                   if (tmpctx[0]) {
(Example-1) Reason Marked as False Positive:
No memory is allocated for .name variable, thuse we don''t need to free anything here.

** Example-2 **
(Example-2) Known False Positive:
Error CPPCHECK_WARNING (CWE-401):
audit-4.0/src/ausearch-parse.c:1737: error[memleak]: Memory leak: sn.str
# 1735|   							strdup(un->sun_path+1);
# 1736|   						else
# 1737|-> 							return 6;
# 1738|   
# 1739|   						sn.key = NULL;
(Example-2) Reason Marked as False Positive:
There is malloc called for sn.str at all, thus no memory to free.

', '2025-11-17 21:39:07.076109');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (332, 105, 'def2', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082771');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (333, 105, 'def3', 'UNINIT', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:846: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:866: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  864|               len = _mpd_real_size(result->data, len);
#  865|               /* resize to fewer words cannot fail */
#  866|->             mpd_qresize(result, len, &dummy);
#  867|               result->len = len;
#  868|               mpd_setdigits(result);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:846: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:866: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  864|               len = _mpd_real_size(result->data, len);
#  865|               /* resize to fewer words cannot fail */
#  866|->             mpd_qresize(result, len, &dummy);
#  867|               result->len = len;
#  868|               mpd_setdigits(result);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:846: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:866: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  864|               len = _mpd_real_size(result->data, len);
#  865|               /* resize to fewer words cannot fail */
#  866|->             mpd_qresize(result, len, &dummy);
#  867|               result->len = len;
#  868|               mpd_setdigits(result);
(Example-1) Reason Marked as False Positive:
The variable dummy is not used

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:817: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:830: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  828|           len = _mpd_real_size(result->data, len);
#  829|           /* resize to fewer words cannot fail */
#  830|->         mpd_qresize(result, len, &dummy);
#  831|           result->len = len;
#  832|           mpd_setdigits(result);
(Example-2) Reason Marked as False Positive:
The variable dummy is not used

', '2025-11-17 21:39:07.082772');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (334, 105, 'def4', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|', 'FALSE POSITIVE', 'The reported issue is deemed a FALSE POSITIVE because the large indices (e.g., `6442450946`) are explicitly unsigned, and the code''s logic (e.g., line 5765''s assignment) and function calls (e.g., `_mpd_baseaddto` at line 5826) are designed to handle such values within the unsigned integer range, without introducing a buffer overrun vulnerability.', '1. **Unsigned Integer Context**: The values in question (e.g., `6442450944ULL`, `3221225473`, and `6442450946`) are explicitly unsigned (denoted by `ULL` and `UL` suffixes), indicating that large values are expected and handled appropriately within the unsigned integer range.

2. **Assignment Logic**: At line `5765`, `m` is assigned the value of `(la + 1UL) / 2UL`. Given `la`''s context as an unsigned value, the division by 2 ( effectively a right shift for unsigned integers) does not introduce a vulnerability but rather a logical calculation, ensuring `m` remains within the bounds of unsigned integer representation.

3. **Buffer Argument Context**: The call to `_mpd_baseaddto` at line `5826` with `m + m` as an argument, while flagged for a potentially large index, does not inherently indicate a buffer overrun vulnerability. The provided code does not explicitly define the bounds of `w` or `c`, but the use of unsigned integers for indexing suggests that the function is designed to handle large, unsigned indices.

4. **Lack of Explicit Vulnerability**: Within the provided code snippet, there is no explicit evidence that the large unsigned indices would lead to a buffer overrun or that the function `_mpd_baseaddto` is not designed to handle such indices. The assertion at line `5744` (`assert(la >= lb && lb > 0);`) and the conditional logic surrounding the flagged line do not introduce a clear vulnerability path based on the information given.

5. **Comparison with Provided Examples**: The scenario closely matches the provided **Example-1** and **Example-2**, both of which are marked as FALSE POSITIVE due to the expected handling of large unsigned integers, further supporting this classification.', NULL, 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5738| static int
5739| _karatsuba_rec_fnt(mpd_uint_t *c, const mpd_uint_t *a, const mpd_uint_t *b,
5740|                    mpd_uint_t *w, mpd_size_t la, mpd_size_t lb)
5741| {
5742|     mpd_size_t m, lt;
5743| 
5744|     assert(la >= lb && lb > 0);
5745|     assert(la <= 3*(MPD_MAXTRANSFORM_2N/2) || w != NULL);
5746| 
5747|     if (la <= 3*(MPD_MAXTRANSFORM_2N/2)) {
5748| 
5749|         if (lb <= 192) {
5750|             _mpd_basemul(c, b, a, lb, la);
5751|         }
5752|         else {
5753|             mpd_uint_t *result;
5754|             mpd_size_t dummy;
5755| 
5756|             if ((result = _mpd_fntmul(a, b, la, lb, &dummy)) == NULL) {
5757|                 return 0;
5758|             }
5759|             memcpy(c, result, (la+lb) * (sizeof *result));
5760|             mpd_free(result);
5761|         }
5762|         return 1;
5763|     }
5764| 
5765|     m = (la+1)/2;  /* ceil(la/2) */
5766| 
5767|     /* lb <= m < la */
5768|     if (lb <= m) {
5769| 
5770|         /* lb can now be larger than la-m */
5771|         if (lb > la-m) {
5772|             lt = lb + lb + 1;       /* space needed for result array */
5773|             mpd_uint_zero(w, lt);   /* clear result array */
5774|             if (!_karatsuba_rec_fnt(w, b, a+m, w+lt, lb, la-m)) { /* b*ah */
5775|                 return 0; /* GCOV_UNLIKELY */
5776|             }
5777|         }
5778|         else {
5779|             lt = (la-m) + (la-m) + 1;  /* space needed for result array */
5780|             mpd_uint_zero(w, lt);      /* clear result array */
5781|             if (!_karatsuba_rec_fnt(w, a+m, b, w+lt, la-m, lb)) { /* ah*b */
5782|                 return 0; /* GCOV_UNLIKELY */
5783|             }
5784|         }
5785|         _mpd_baseaddto(c+m, w, (la-m)+lb); /* add ah*b*B**m */
5786| 
5787|         lt = m + m + 1;         /* space needed for the result array */
5788|         mpd_uint_zero(w, lt);   /* clear result array */
5789|         if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
5790|             return 0; /* GCOV_UNLIKELY */
5791|         }
5792|         _mpd_baseaddto(c, w, m+lb);       /* add al*b */
5793| 
5794|         return 1;
5795|     }
5796| 
5797|     /* la >= lb > m */
5798|     memcpy(w, a, m * sizeof *w);
5799|     w[m] = 0;
5800|     _mpd_baseaddto(w, a+m, la-m);
5801| 
5802|     memcpy(w+(m+1), b, m * sizeof *w);
5803|     w[m+1+m] = 0;
5804|     _mpd_baseaddto(w+(m+1), b+m, lb-m);
5805| 
5806|     if (!_karatsuba_rec_fnt(c+m, w, w+(m+1), w+2*(m+1), m+1, m+1)) {
5807|         return 0; /* GCOV_UNLIKELY */
5808|     }
5809| 
5810|     lt = (la-m) + (la-m) + 1;
5811|     mpd_uint_zero(w, lt);
5812| 
5813|     if (!_karatsuba_rec_fnt(w, a+m, b+m, w+lt, la-m, lb-m)) {
5814|         return 0; /* GCOV_UNLIKELY */
5815|     }
5816| 
5817|     _mpd_baseaddto(c+2*m, w, (la-m) + (lb-m));
5818|     _mpd_basesubfrom(c+m, w, (la-m) + (lb-m));
5819| 
5820|     lt = m + m + 1;
5821|     mpd_uint_zero(w, lt);
5822| 
5823|     if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
5824|         return 0; /* GCOV_UNLIKELY */
5825|     }
5826|     _mpd_baseaddto(c, w, m+m);
5827|     _mpd_basesubfrom(c+m, w, m+m);
5828| 
5829|     return 1;
5830| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "c" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082772');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (335, 105, 'def5', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "c" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|', 'FALSE POSITIVE', 'The reported issue is deemed a FALSE POSITIVE because the large indices (e.g., `6442450946`) are explicitly unsigned, and the code''s logic (e.g., line 5765''s assignment) and function calls (e.g., `_mpd_baseaddto` at line 5826) are designed to handle such values within the unsigned integer range, without introducing a buffer overrun vulnerability.', '1. **Unsigned Integer Context**: The values in question (e.g., `6442450944ULL`, `3221225473`, and `6442450946`) are explicitly unsigned (denoted by `ULL` and `UL` suffixes), indicating that large values are expected and handled appropriately within the unsigned integer range.

2. **Assignment Logic**: At line `5765`, `m` is assigned the value of `(la + 1UL) / 2UL`. Given `la`''s context as an unsigned value, the division by 2 ( effectively a right shift for unsigned integers) does not introduce a vulnerability but rather a logical calculation, ensuring `m` remains within the bounds of unsigned integer representation.

3. **Buffer Argument Context**: The call to `_mpd_baseaddto` at line `5826` with `m + m` as an argument, while flagged for a potentially large index, does not inherently indicate a buffer overrun vulnerability. The provided code does not explicitly define the bounds of `c` or `w`, but the use of unsigned integers for indexing suggests that the function is designed to handle large, unsigned indices.

4. **Lack of Explicit Vulnerability**: Within the provided code snippet, there is no explicit evidence that the large unsigned indices would lead to a buffer overrun or that the function `_mpd_baseaddto` is not designed to handle such indices. The assertion at line `5744` (`assert(la >= lb && lb > 0);`) and the conditional logic surrounding the flagged line do not introduce a clear vulnerability path based on the information given.

5. **Comparison with Provided Examples**: The scenario closely matches the provided **Example-1** and **Example-2**, both of which are marked as FALSE POSITIVE due to the expected handling of large unsigned integers, further supporting this classification.', NULL, 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5738| static int
5739| _karatsuba_rec_fnt(mpd_uint_t *c, const mpd_uint_t *a, const mpd_uint_t *b,
5740|                    mpd_uint_t *w, mpd_size_t la, mpd_size_t lb)
5741| {
5742|     mpd_size_t m, lt;
5743| 
5744|     assert(la >= lb && lb > 0);
5745|     assert(la <= 3*(MPD_MAXTRANSFORM_2N/2) || w != NULL);
5746| 
5747|     if (la <= 3*(MPD_MAXTRANSFORM_2N/2)) {
5748| 
5749|         if (lb <= 192) {
5750|             _mpd_basemul(c, b, a, lb, la);
5751|         }
5752|         else {
5753|             mpd_uint_t *result;
5754|             mpd_size_t dummy;
5755| 
5756|             if ((result = _mpd_fntmul(a, b, la, lb, &dummy)) == NULL) {
5757|                 return 0;
5758|             }
5759|             memcpy(c, result, (la+lb) * (sizeof *result));
5760|             mpd_free(result);
5761|         }
5762|         return 1;
5763|     }
5764| 
5765|     m = (la+1)/2;  /* ceil(la/2) */
5766| 
5767|     /* lb <= m < la */
5768|     if (lb <= m) {
5769| 
5770|         /* lb can now be larger than la-m */
5771|         if (lb > la-m) {
5772|             lt = lb + lb + 1;       /* space needed for result array */
5773|             mpd_uint_zero(w, lt);   /* clear result array */
5774|             if (!_karatsuba_rec_fnt(w, b, a+m, w+lt, lb, la-m)) { /* b*ah */
5775|                 return 0; /* GCOV_UNLIKELY */
5776|             }
5777|         }
5778|         else {
5779|             lt = (la-m) + (la-m) + 1;  /* space needed for result array */
5780|             mpd_uint_zero(w, lt);      /* clear result array */
5781|             if (!_karatsuba_rec_fnt(w, a+m, b, w+lt, la-m, lb)) { /* ah*b */
5782|                 return 0; /* GCOV_UNLIKELY */
5783|             }
5784|         }
5785|         _mpd_baseaddto(c+m, w, (la-m)+lb); /* add ah*b*B**m */
5786| 
5787|         lt = m + m + 1;         /* space needed for the result array */
5788|         mpd_uint_zero(w, lt);   /* clear result array */
5789|         if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
5790|             return 0; /* GCOV_UNLIKELY */
5791|         }
5792|         _mpd_baseaddto(c, w, m+lb);       /* add al*b */
5793| 
5794|         return 1;
5795|     }
5796| 
5797|     /* la >= lb > m */
5798|     memcpy(w, a, m * sizeof *w);
5799|     w[m] = 0;
5800|     _mpd_baseaddto(w, a+m, la-m);
5801| 
5802|     memcpy(w+(m+1), b, m * sizeof *w);
5803|     w[m+1+m] = 0;
5804|     _mpd_baseaddto(w+(m+1), b+m, lb-m);
5805| 
5806|     if (!_karatsuba_rec_fnt(c+m, w, w+(m+1), w+2*(m+1), m+1, m+1)) {
5807|         return 0; /* GCOV_UNLIKELY */
5808|     }
5809| 
5810|     lt = (la-m) + (la-m) + 1;
5811|     mpd_uint_zero(w, lt);
5812| 
5813|     if (!_karatsuba_rec_fnt(w, a+m, b+m, w+lt, la-m, lb-m)) {
5814|         return 0; /* GCOV_UNLIKELY */
5815|     }
5816| 
5817|     _mpd_baseaddto(c+2*m, w, (la-m) + (lb-m));
5818|     _mpd_basesubfrom(c+m, w, (la-m) + (lb-m));
5819| 
5820|     lt = m + m + 1;
5821|     mpd_uint_zero(w, lt);
5822| 
5823|     if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
5824|         return 0; /* GCOV_UNLIKELY */
5825|     }
5826|     _mpd_baseaddto(c, w, m+m);
5827|     _mpd_basesubfrom(c+m, w, m+m);
5828| 
5829|     return 1;
5830| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "c" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5826: overrun-buffer-arg: Calling "_mpd_baseaddto" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5824|           return 0; /* GCOV_UNLIKELY */
# 5825|       }
# 5826|->     _mpd_baseaddto(c, w, m+m);
# 5827|       _mpd_basesubfrom(c+m, w, m+m);
# 5828|
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082772');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (336, 105, 'def6', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082773');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (337, 105, 'def7', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "w + (m + 1UL)" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "w + (m + 1UL)" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "w + (m + 1UL)" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "b" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082773');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (338, 105, 'def8', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5787: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5788: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5786|   
# 5787|           lt = m + m + 1;         /* space needed for the result array */
# 5788|->         mpd_uint_zero(w, lt);   /* clear result array */
# 5789|           if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
# 5790|               return 0; /* GCOV_UNLIKELY */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
#           lt = m + m + 1;         /* space needed for the result array */
#->         mpd_uint_zero(w, lt);   /* clear result array */
#           if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
#               return 0; /* GCOV_UNLIKELY */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5787: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5788: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5786|   
# 5787|           lt = m + m + 1;         /* space needed for the result array */
# 5788|->         mpd_uint_zero(w, lt);   /* clear result array */
# 5789|           if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
# 5790|               return 0; /* GCOV_UNLIKELY */
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5820: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5821: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5819|   
# 5820|       lt = m + m + 1;
# 5821|->     mpd_uint_zero(w, lt);
# 5822|   
# 5823|       if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082773');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (339, 105, 'def9', 'COPY_PASTE_ERROR', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:7626: original: "_mpd_qadd_exact(qq, qq, &minus_one, &workctx, &workctx.status)" looks like the original copy.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:7635: copy_paste_error: "_mpd_qadd_exact" in "_mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status)" looks like a copy-paste error.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:7635: remediation: Should it say "_mpd_qsub_exact" instead?
# 7633|           else {
# 7634|               _mpd_qsub_exact(rr, rr, &bb, &workctx, &workctx.status);
# 7635|->             _mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status);
# 7636|           }
# 7637|       }', 'FALSE POSITIVE', 'The `_mpd_qadd_exact` at line 7635 is not a copy-paste error, but a deliberate increment of the quotient (`qq`) by 1, logically following the remainder''s adjustment at line 7634, aligning with the division correction loop''s purpose (lines 7633-7637).', 'The reported issue suggests a copy-paste error, implying `_mpd_qadd_exact` should be `_mpd_qsub_exact` at line 7635 for consistency with the preceding line''s subtraction operation.

However, examining the context (lines 7633-7637), the logic is within a correction loop for division, where `qq` represents the quotient and `rr` the remainder.

At line 7634, `_mpd_qsub_exact(rr, rr, &bb, &workctx, &workctx.status)` adjusts the remainder (`rr`) by subtracting `bb` (the divisor) when the remainder is greater than or equal to the divisor.

Immediately after, at line 7635, `_mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status)` increments the quotient (`qq`) by 1, which is a logical step following the adjustment of the remainder. This action correctly updates the quotient based on the division algorithm''s logic.

The operation at line 7635 is not a copy-paste error but a deliberate increment of the quotient in response to the remainder''s adjustment, aligning with the division correction loop''s purpose.

No evidence within the provided code snippet suggests that the described vulnerability (copy-paste error leading to incorrect operation) actually occurs or that the code''s behavior deviates from its intended division algorithm logic.', NULL, 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
7544| static void
7545| _mpd_base_ndivmod(mpd_t *q, mpd_t *r, const mpd_t *a, const mpd_t *b,
7546|                   uint32_t *status)
7547| {
7548|     mpd_context_t workctx;
7549|     mpd_t *qq = q, *rr = r;
7550|     mpd_t aa, bb;
7551|     int k;
7552| 
7553|     _mpd_copy_shared(&aa, a);
7554|     _mpd_copy_shared(&bb, b);
7555| 
7556|     mpd_set_positive(&aa);
7557|     mpd_set_positive(&bb);
7558|     aa.exp = 0;
7559|     bb.exp = 0;
7560| 
7561|     if (q == a || q == b) {
7562|         if ((qq = mpd_qnew()) == NULL) {
7563|             *status |= MPD_Malloc_error;
7564|             goto nanresult;
7565|         }
7566|     }
7567|     if (r == a || r == b) {
7568|         if ((rr = mpd_qnew()) == NULL) {
7569|             *status |= MPD_Malloc_error;
7570|             goto nanresult;
7571|         }
7572|     }
7573| 
7574|     mpd_maxcontext(&workctx);
7575| 
7576|     /* Let prec := adigits - bdigits + 4 */
7577|     workctx.prec = a->digits - b->digits + 1 + 3;
7578|     if (a->digits > MPD_MAX_PREC || workctx.prec > MPD_MAX_PREC) {
7579|         *status |= MPD_Division_impossible;
7580|         goto nanresult;
7581|     }
7582| 
7583|     /* Let x := _mpd_qreciprocal(b, prec)
7584|      * Then x is bounded by:
7585|      *    1) 1/b - 10**(-prec - bdigits) < x < 1/b + 10**(-prec - bdigits)
7586|      *    2) 1/b - 10**(-adigits - 4) < x < 1/b + 10**(-adigits - 4)
7587|      */
7588|     _mpd_qreciprocal(rr, &bb, &workctx, &workctx.status);
7589| 
7590|     /* Get an estimate for the quotient. Let q := a * x
7591|      * Then q is bounded by:
7592|      *    3) a/b - 10**-4 < q < a/b + 10**-4
7593|      */
7594|     _mpd_qmul(qq, &aa, rr, &workctx, &workctx.status);
7595|     /* Truncate q to an integer:
7596|      *    4) a/b - 2 < trunc(q) < a/b + 1
7597|      */
7598|     mpd_qtrunc(qq, qq, &workctx, &workctx.status);
7599| 
7600|     workctx.prec = aa.digits + 3;
7601|     workctx.emax = MPD_MAX_EMAX + 3;
7602|     workctx.emin = MPD_MIN_EMIN - 3;
7603|     /* Multiply the estimate for q by b:
7604|      *    5) a - 2 * b < trunc(q) * b < a + b
7605|      */
7606|     _mpd_qmul(rr, &bb, qq, &workctx, &workctx.status);
7607|     /* Get the estimate for r such that a = q * b + r. */
7608|     _mpd_qsub_exact(rr, &aa, rr, &workctx, &workctx.status);
7609| 
7610|     /* Fix the result. At this point -b < r < 2*b, so the correction loop
7611|        takes at most one iteration. */
7612|     for (k = 0;; k++) {
7613|         if (mpd_isspecial(qq) || mpd_isspecial(rr)) {
7614|             *status |= (workctx.status&MPD_Errors);
7615|             goto nanresult;
7616|         }
7617|         if (k > 2) { /* Allow two iterations despite the proof. */
7618|             mpd_err_warn("libmpdec: internal error in "       /* GCOV_NOT_REACHED */
7619|                          "_mpd_base_ndivmod: please report"); /* GCOV_NOT_REACHED */
7620|             *status |= MPD_Invalid_operation;                 /* GCOV_NOT_REACHED */
7621|             goto nanresult;                                   /* GCOV_NOT_REACHED */
7622|         }
7623|         /* r < 0 */
7624|         else if (_mpd_cmp(&zero, rr) == 1) {
7625|             _mpd_qadd_exact(rr, rr, &bb, &workctx, &workctx.status);
7626|             _mpd_qadd_exact(qq, qq, &minus_one, &workctx, &workctx.status);
7627|         }
7628|         /* 0 <= r < b */
7629|         else if (_mpd_cmp(rr, &bb) == -1) {
7630|             break;
7631|         }
7632|         /* r >= b */
7633|         else {
7634|             _mpd_qsub_exact(rr, rr, &bb, &workctx, &workctx.status);
7635|             _mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status);
7636|         }
7637|     }
7638| 
7639|     if (qq != q) {
7640|         if (!mpd_qcopy(q, qq, status)) {
7641|             goto nanresult; /* GCOV_UNLIKELY */
7642|         }
7643|         mpd_del(qq);
7644|     }
7645|     if (rr != r) {
7646|         if (!mpd_qcopy(r, rr, status)) {
7647|             goto nanresult; /* GCOV_UNLIKELY */
7648|         }
7649|         mpd_del(rr);
7650|     }
7651| 
7652|     *status |= (workctx.status&MPD_Errors);
7653|     return;
7654| 
7655| 
7656| nanresult:
7657|     if (qq && qq != q) mpd_del(qq);
7658|     if (rr && rr != r) mpd_del(rr);
7659|     mpd_setspecial(q, MPD_POS, MPD_NAN);
7660|     mpd_setspecial(r, MPD_POS, MPD_NAN);
7661| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:7626: original: "_mpd_qadd_exact(qq, qq, &minus_one, &workctx, &workctx.status)" looks like the original copy.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:7635: copy_paste_error: "_mpd_qadd_exact" in "_mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status)" looks like a copy-paste error.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:7635: remediation: Should it say "_mpd_qsub_exact" instead?
# 7633|           else {
# 7634|               _mpd_qsub_exact(rr, rr, &bb, &workctx, &workctx.status);
# 7635|->             _mpd_qadd_exact(qq, qq, &one, &workctx, &workctx.status);
# 7636|           }
# 7637|       }
(Example-1) Reason Marked as False Positive:
The code is correct

', '2025-11-17 21:39:07.082774');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (340, 105, 'def10', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5696: overrun-buffer-arg: Calling "fnt_convolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5694|   
# 5695|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5696|->         if (!fnt_convolute(c1, vtmp, n, P1)) {
# 5697|               mpd_free(vtmp);
# 5698|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082774');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (342, 105, 'def12', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "c3" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;', 'TRUE POSITIVE', 'Lack of explicit overflow check in `_mpd_get_transform_len(*rsize)` and unclear behavior of this function, combined with potential for buffer overrun in subsequent memory operations (e.g., `memcpy` and `mpd_uint_zero`), directly correlate with CWE-119 (Buffer Overrun) without sufficient evidence for a FALSE POSITIVE.', '1. **Lack of Explicit Overflow Check in Provided Code**: There is no explicit evidence within the provided source code (libmpdec/mpdecimal.c, specifically around lines 5651-5732) that the function `_mpd_get_transform_len(*rsize)` checks for integer overflows that could result in a very large index (6442450944) being returned and assigned to `n` (line 5665).

2. **Unclear Behavior of `_mpd_get_transform_len`**: The implementation of `_mpd_get_transform_len` is not provided in the context. Without its explicit behavior, we cannot assume it handles overflows or large returns safely, leaving uncertainty about the safety of the assignment to `n`.

3. **Potential for Buffer Overrun**: With `n` potentially being a very large value (6442450944), the subsequent operations, particularly `memcpy` (line 5708) and `mpd_uint_zero` (line 5709), could lead to a buffer overrun when accessing `vtmp` with indices derived from `n`. This is especially concerning given the warning about a suspicious very large index at line 5710 when calling `fnt_convolute`.

4. **Insufficient Evidence for False Positive**: Unlike the provided examples (Example-1 and Example-2) marked as FALSE POSITIVE, where the function allocating memory (`mpd_sh_alloc`) explicitly checks for integer overflows, no such explicit safeguard is evident in the provided code for the operations involving `n` after its assignment from `_mpd_get_transform_len(*rsize)`. Without direct evidence of overflow protection or safe handling of large indices, we cannot conclusively mark this as a FALSE POSITIVE.

5. **Direct Correlation to CWE-119 (Buffer Overrun)**: The scenario described directly correlates with CWE-119, as the potentially large, unchecked value of `n` is used in memory operations, posing a risk of buffer overrun, aligning with the vulnerability described in the CVE report.', 'Review the implementation of memory allocation functions used for `vtmp` (e.g., `mpd_sh_alloc` or similar) to confirm the presence or absence of integer overflow checks.

Examine the `fnt_convolute` function to determine if it internally checks for or mitigates large index values that could lead to buffer overruns.

Verify if any other parts of the `mpdecimal` library (e.g., input validation, configuration options) could prevent or mitigate the potential buffer overrun vulnerability.', 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5651| static mpd_uint_t *
5652| _mpd_fntmul(const mpd_uint_t *u, const mpd_uint_t *v,
5653|             mpd_size_t ulen, mpd_size_t vlen,
5654|             mpd_size_t *rsize)
5655| {
5656|     mpd_uint_t *c1 = NULL, *c2 = NULL, *c3 = NULL, *vtmp = NULL;
5657|     mpd_size_t n;
5658| 
5659| #ifdef PPRO
5660|     unsigned int cw;
5661|     cw = mpd_set_fenv();
5662| #endif
5663| 
5664|     *rsize = add_size_t(ulen, vlen);
5665|     if ((n = _mpd_get_transform_len(*rsize)) == MPD_SIZE_MAX) {
5666|         goto malloc_error;
5667|     }
5668| 
5669|     if ((c1 = mpd_calloc(n, sizeof *c1)) == NULL) {
5670|         goto malloc_error;
5671|     }
5672|     if ((c2 = mpd_calloc(n, sizeof *c2)) == NULL) {
5673|         goto malloc_error;
5674|     }
5675|     if ((c3 = mpd_calloc(n, sizeof *c3)) == NULL) {
5676|         goto malloc_error;
5677|     }
5678| 
5679|     memcpy(c1, u, ulen * (sizeof *c1));
5680|     memcpy(c2, u, ulen * (sizeof *c2));
5681|     memcpy(c3, u, ulen * (sizeof *c3));
5682| 
5683|     if (u == v) {
5684|         if (!fnt_autoconvolute(c1, n, P1) ||
5685|             !fnt_autoconvolute(c2, n, P2) ||
5686|             !fnt_autoconvolute(c3, n, P3)) {
5687|             goto malloc_error;
5688|         }
5689|     }
5690|     else {
5691|         if ((vtmp = mpd_calloc(n, sizeof *vtmp)) == NULL) {
5692|             goto malloc_error;
5693|         }
5694| 
5695|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5696|         if (!fnt_convolute(c1, vtmp, n, P1)) {
5697|             mpd_free(vtmp);
5698|             goto malloc_error;
5699|         }
5700| 
5701|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5702|         mpd_uint_zero(vtmp+vlen, n-vlen);
5703|         if (!fnt_convolute(c2, vtmp, n, P2)) {
5704|             mpd_free(vtmp);
5705|             goto malloc_error;
5706|         }
5707| 
5708|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5709|         mpd_uint_zero(vtmp+vlen, n-vlen);
5710|         if (!fnt_convolute(c3, vtmp, n, P3)) {
5711|             mpd_free(vtmp);
5712|             goto malloc_error;
5713|         }
5714| 
5715|         mpd_free(vtmp);
5716|     }
5717| 
5718|     crt3(c1, c2, c3, *rsize);
5719| 
5720| out:
5721| #ifdef PPRO
5722|     mpd_restore_fenv(cw);
5723| #endif
5724|     if (c2) mpd_free(c2);
5725|     if (c3) mpd_free(c3);
5726|     return c1;
5727| 
5728| malloc_error:
5729|     if (c1) mpd_free(c1);
5730|     c1 = NULL;
5731|     goto out;
5732| }

code of /shared-data/source/mpdecimal-2.5.1/libmpdec/convolute.h file:
0| #endif /* LIBMPDEC_CONVOLUTE_H_ */

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "c3" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082775');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (343, 105, 'def13', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "c + m" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082775');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (344, 105, 'def14', 'INTEGER_OVERFLOW', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: tainted_data_return: Called function "mpd_arith_sign(b)", and a possible return value may be less than zero.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: overflow: The expression "a->exp + (int64_t)n * mpd_arith_sign(b)" is considered to have possibly overflowed.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: assign: Assigning: "exp" = "a->exp + (int64_t)n * mpd_arith_sign(b)".
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3080: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3100: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3102: overflow_sink: "result->exp", which might have overflowed, is passed to "mpd_qfinalize(result, ctx, status)".
# 3100|       result->exp = (mpd_ssize_t)exp;
# 3101|   
# 3102|->     mpd_qfinalize(result, ctx, status);
# 3103|   }
# 3104|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c: tainted_data_return: Called function "mpd_arith_sign(b)", and a possible return value may be less than zero.
mpdecimal-2.5.1/libmpdec/mpdecimal.c: overflow: The expression "a->exp + (int64_t)n * mpd_arith_sign(b)" is considered to have possibly overflowed.
mpdecimal-2.5.1/libmpdec/mpdecimal.c: assign: Assigning: "exp" = "a->exp + (int64_t)n * mpd_arith_sign(b)".
mpdecimal-2.5.1/libmpdec/mpdecimal.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c: overflow_sink: "result->exp", which might have overflowed, is passed to "mpd_qfinalize(result, ctx, status)".
#       result->exp = (mpd_ssize_t)exp;
#       mpd_qfinalize(result, ctx, status);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: tainted_data_return: Called function "mpd_arith_sign(b)", and a possible return value may be less than zero.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: overflow: The expression "a->exp + (int64_t)n * mpd_arith_sign(b)" is considered to have possibly overflowed.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3078: assign: Assigning: "exp" = "a->exp + (int64_t)n * mpd_arith_sign(b)".
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3080: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3100: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:3102: overflow_sink: "result->exp", which might have overflowed, is passed to "mpd_qfinalize(result, ctx, status)".
# 3100|       result->exp = (mpd_ssize_t)exp;
# 3101|   
# 3102|->     mpd_qfinalize(result, ctx, status);
# 3103|   }
# 3104|
(Example-1) Reason Marked as False Positive:
We cast the unsigned n variable to a signed type (int64_t) so it cannot overflow.

', '2025-11-17 21:39:07.082775');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (345, 105, 'def15', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "c + m" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "c + m" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "c + m" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5827: overrun-buffer-arg: Calling "_mpd_basesubfrom" with "w" and "m + m" is suspicious because of the very large index, 6442450946. The index may be due to a negative parameter being interpreted as unsigned.
# 5825|       }
# 5826|       _mpd_baseaddto(c, w, m+m);
# 5827|->     _mpd_basesubfrom(c+m, w, m+m);
# 5828|   
# 5829|       return 1;
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082776');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (346, 105, 'def16', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:1005: assignment: Assigning: "n" = "mpd_word_digits(word)". The value of "n" is now between 1 and 20 (inclusive).
mpdecimal-2.5.1/libmpdec/mpdecimal.c:1006: overrun-local: Overrunning array "mpd_pow10" of 20 8-byte elements at element index 20 (byte offset 167) using index "n" (which evaluates to 20).
# 1004|   
# 1005|       n = mpd_word_digits(word);
# 1006|->     if (word == mpd_pow10[n]-1) {
# 1007|           return 1;
# 1008|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:1005: assignment: Assigning: "n" = "mpd_word_digits(word)". The value of "n" is now between 1 and 20 (inclusive).
mpdecimal-2.5.1/libmpdec/mpdecimal.c:1006: overrun-local: Overrunning array "mpd_pow10" of 20 8-byte elements at element index 20 (byte offset 167) using index "n" (which evaluates to 20).
# 1004|   
# 1005|       n = mpd_word_digits(word);
# 1006|->     if (word == mpd_pow10[n]-1) {
# 1007|           return 1;
# 1008|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:1005: assignment: Assigning: ""n"" = ""mpd_word_digits(word)"". The value of ""n"" is now between 1 and 20 (inclusive).
mpdecimal-2.5.1/libmpdec/mpdecimal.c:1006: overrun-local: Overrunning array ""mpd_pow10"" of 20 8-byte elements at element index 20 (byte offset 167) using index ""n"" (which evaluates to 20).
# 1004|   
# 1005|       n = mpd_word_digits(word);
# 1006|->     if (word == mpd_pow10[n]-1) {
# 1007|           return 1;
# 1008|       }
(Example-1) Reason Marked as False Positive:
All arithmetic for the 64-bit build is modulo 10**19, so the maximum number of digits per word is 19.
mpd_word_isallnine() is a static function that is only called on well formed decimals, so all invariants are met.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5820: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5821: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5819|   
# 5820|       lt = m + m + 1;
# 5821|->     mpd_uint_zero(w, lt);
# 5822|   
# 5823|       if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082776');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (347, 105, 'def17', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "a" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);', 'FALSE POSITIVE', 'The large index value in `memcpy` at line 5798 is expected due to the unsigned nature of `m` (defined as `mpd_size_t` at line 5742) and its calculation `m = (la+1)/2;` (line 5765), ruling out a negative-to-unsigned misinterpretation buffer overrun risk.', 'The reported issue revolves around the large index value (25769803784) in the `memcpy` function at line 5798, suggesting a potential buffer overrun due to a negative parameter being interpreted as unsigned.

However, the code explicitly defines `m` as an unsigned value (`mpd_size_t m;`) at line 5742, which is a type that typically represents an unsigned integer (e.g., `size_t` in standard C libraries).

The assignment of `m` at line 5765, `m = (la+1)/2;`, where `la` is also unsigned (`mpd_size_t la;`), ensures that `m` will always be an unsigned, non-negative value.

Given that both `m` and the index calculation `m * sizeof *w` are unsigned, the large index value (25769803784) is expected and not indicative of a negative value being misinterpreted as unsigned.

The provided examples (Example-1 and Example-2) further support this conclusion, marking similar scenarios as FALSE POSITIVE due to the unsigned nature of the variables involved.

There is no evidence within the provided code to suggest that the `memcpy` operation at line 5798 would exceed the bounds of the buffer `w`, assuming `w` is properly allocated to accommodate the calculated size `m * sizeof *w`.', NULL, 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5738| static int
5739| _karatsuba_rec_fnt(mpd_uint_t *c, const mpd_uint_t *a, const mpd_uint_t *b,
5740|                    mpd_uint_t *w, mpd_size_t la, mpd_size_t lb)
5741| {
5742|     mpd_size_t m, lt;
5743| 
5744|     assert(la >= lb && lb > 0);
5745|     assert(la <= 3*(MPD_MAXTRANSFORM_2N/2) || w != NULL);
5746| 
5747|     if (la <= 3*(MPD_MAXTRANSFORM_2N/2)) {
5748| 
5749|         if (lb <= 192) {
5750|             _mpd_basemul(c, b, a, lb, la);
5751|         }
5752|         else {
5753|             mpd_uint_t *result;
5754|             mpd_size_t dummy;
5755| 
5756|             if ((result = _mpd_fntmul(a, b, la, lb, &dummy)) == NULL) {
5757|                 return 0;
5758|             }
5759|             memcpy(c, result, (la+lb) * (sizeof *result));
5760|             mpd_free(result);
5761|         }
5762|         return 1;
5763|     }
5764| 
5765|     m = (la+1)/2;  /* ceil(la/2) */
5766| 
5767|     /* lb <= m < la */
5768|     if (lb <= m) {
5769| 
5770|         /* lb can now be larger than la-m */
5771|         if (lb > la-m) {
5772|             lt = lb + lb + 1;       /* space needed for result array */
5773|             mpd_uint_zero(w, lt);   /* clear result array */
5774|             if (!_karatsuba_rec_fnt(w, b, a+m, w+lt, lb, la-m)) { /* b*ah */
5775|                 return 0; /* GCOV_UNLIKELY */
5776|             }
5777|         }
5778|         else {
5779|             lt = (la-m) + (la-m) + 1;  /* space needed for result array */
5780|             mpd_uint_zero(w, lt);      /* clear result array */
5781|             if (!_karatsuba_rec_fnt(w, a+m, b, w+lt, la-m, lb)) { /* ah*b */
5782|                 return 0; /* GCOV_UNLIKELY */
5783|             }
5784|         }
5785|         _mpd_baseaddto(c+m, w, (la-m)+lb); /* add ah*b*B**m */
5786| 
5787|         lt = m + m + 1;         /* space needed for the result array */
5788|         mpd_uint_zero(w, lt);   /* clear result array */
5789|         if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
5790|             return 0; /* GCOV_UNLIKELY */
5791|         }
5792|         _mpd_baseaddto(c, w, m+lb);       /* add al*b */
5793| 
5794|         return 1;
5795|     }
5796| 
5797|     /* la >= lb > m */
5798|     memcpy(w, a, m * sizeof *w);
5799|     w[m] = 0;
5800|     _mpd_baseaddto(w, a+m, la-m);
5801| 
5802|     memcpy(w+(m+1), b, m * sizeof *w);
5803|     w[m+1+m] = 0;
5804|     _mpd_baseaddto(w+(m+1), b+m, lb-m);
5805| 
5806|     if (!_karatsuba_rec_fnt(c+m, w, w+(m+1), w+2*(m+1), m+1, m+1)) {
5807|         return 0; /* GCOV_UNLIKELY */
5808|     }
5809| 
5810|     lt = (la-m) + (la-m) + 1;
5811|     mpd_uint_zero(w, lt);
5812| 
5813|     if (!_karatsuba_rec_fnt(w, a+m, b+m, w+lt, la-m, lb-m)) {
5814|         return 0; /* GCOV_UNLIKELY */
5815|     }
5816| 
5817|     _mpd_baseaddto(c+2*m, w, (la-m) + (lb-m));
5818|     _mpd_basesubfrom(c+m, w, (la-m) + (lb-m));
5819| 
5820|     lt = m + m + 1;
5821|     mpd_uint_zero(w, lt);
5822| 
5823|     if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
5824|         return 0; /* GCOV_UNLIKELY */
5825|     }
5826|     _mpd_baseaddto(c, w, m+m);
5827|     _mpd_basesubfrom(c+m, w, m+m);
5828| 
5829|     return 1;
5830| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "a" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5798: overrun-buffer-arg: Calling "memcpy" with "w" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5796|   
# 5797|       /* la >= lb > m */
# 5798|->     memcpy(w, a, m * sizeof *w);
# 5799|       w[m] = 0;
# 5800|       _mpd_baseaddto(w, a+m, la-m);
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082776');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (348, 105, 'def18', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {', 'TRUE POSITIVE', 'No explicit overflow checks are performed on `n` (assigned from `_mpd_get_transform_len(*rsize)` at line 5665) before using it for memory allocation (lines 5669-5677) and `fnt_autoconvolute` calls (lines 5684-5686), potentially leading to buffer overruns or memory allocation issues.', 'The CVE report indicates a potential buffer overrun due to a very large index (6442450944) being passed to `fnt_autoconvolute` functions (lines 5684-5686).

The large index value (6442450944) is assigned to variable `n` from the return value of `_mpd_get_transform_len(*rsize)` at line 5665.

There is no explicit check in the provided code snippet (lines 5651-5732) that prevents the assignment of a very large value to `n` or validates the return value of `_mpd_get_transform_len(*rsize)` against potential overflows.

The code at lines 5669-5677 allocates memory for `c1`, `c2`, and `c3` using `mpd_calloc` with the potentially large size `n`. If `n` is indeed excessively large, this could lead to memory allocation issues or, more critically, buffer overruns when these buffers are accessed with index `n` in the `fnt_autoconvolute` calls.

Unlike the provided examples (Example-1 and Example-2) marked as FALSE POSITIVE, which mention that the function allocating memory checks for integer overflows, the provided code snippet does not show such checks for the allocation of `c1`, `c2`, `c3`, or the usage of `n` in `fnt_autoconvolute` calls.

Given the lack of explicit overflow checks for `n` before its use in memory allocation and function calls, and adhering to the guideline that a single vulnerable path is sufficient for a TRUE POSITIVE finding, the reported issue cannot be conclusively dismissed as a FALSE POSITIVE based on the provided code.', 'Verify the implementation of `_mpd_get_transform_len(*rsize)` to understand how the large value (6442450944) is generated and if it''s within expected bounds.

Inspect the `mpd_calloc` function to determine if it internally checks for integer overflows or excessively large allocation sizes that could lead to memory allocation issues.

Analyze the `fnt_autoconvolute` function to confirm if it handles large index values securely, without causing buffer overruns, regardless of the input size `n`.', 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5651| static mpd_uint_t *
5652| _mpd_fntmul(const mpd_uint_t *u, const mpd_uint_t *v,
5653|             mpd_size_t ulen, mpd_size_t vlen,
5654|             mpd_size_t *rsize)
5655| {
5656|     mpd_uint_t *c1 = NULL, *c2 = NULL, *c3 = NULL, *vtmp = NULL;
5657|     mpd_size_t n;
5658| 
5659| #ifdef PPRO
5660|     unsigned int cw;
5661|     cw = mpd_set_fenv();
5662| #endif
5663| 
5664|     *rsize = add_size_t(ulen, vlen);
5665|     if ((n = _mpd_get_transform_len(*rsize)) == MPD_SIZE_MAX) {
5666|         goto malloc_error;
5667|     }
5668| 
5669|     if ((c1 = mpd_calloc(n, sizeof *c1)) == NULL) {
5670|         goto malloc_error;
5671|     }
5672|     if ((c2 = mpd_calloc(n, sizeof *c2)) == NULL) {
5673|         goto malloc_error;
5674|     }
5675|     if ((c3 = mpd_calloc(n, sizeof *c3)) == NULL) {
5676|         goto malloc_error;
5677|     }
5678| 
5679|     memcpy(c1, u, ulen * (sizeof *c1));
5680|     memcpy(c2, u, ulen * (sizeof *c2));
5681|     memcpy(c3, u, ulen * (sizeof *c3));
5682| 
5683|     if (u == v) {
5684|         if (!fnt_autoconvolute(c1, n, P1) ||
5685|             !fnt_autoconvolute(c2, n, P2) ||
5686|             !fnt_autoconvolute(c3, n, P3)) {
5687|             goto malloc_error;
5688|         }
5689|     }
5690|     else {
5691|         if ((vtmp = mpd_calloc(n, sizeof *vtmp)) == NULL) {
5692|             goto malloc_error;
5693|         }
5694| 
5695|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5696|         if (!fnt_convolute(c1, vtmp, n, P1)) {
5697|             mpd_free(vtmp);
5698|             goto malloc_error;
5699|         }
5700| 
5701|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5702|         mpd_uint_zero(vtmp+vlen, n-vlen);
5703|         if (!fnt_convolute(c2, vtmp, n, P2)) {
5704|             mpd_free(vtmp);
5705|             goto malloc_error;
5706|         }
5707| 
5708|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5709|         mpd_uint_zero(vtmp+vlen, n-vlen);
5710|         if (!fnt_convolute(c3, vtmp, n, P3)) {
5711|             mpd_free(vtmp);
5712|             goto malloc_error;
5713|         }
5714| 
5715|         mpd_free(vtmp);
5716|     }
5717| 
5718|     crt3(c1, c2, c3, *rsize);
5719| 
5720| out:
5721| #ifdef PPRO
5722|     mpd_restore_fenv(cw);
5723| #endif
5724|     if (c2) mpd_free(c2);
5725|     if (c3) mpd_free(c3);
5726|     return c1;
5727| 
5728| malloc_error:
5729|     if (c1) mpd_free(c1);
5730|     c1 = NULL;
5731|     goto out;
5732| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082777');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (349, 105, 'def19', 'UNINIT', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:817: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:830: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  828|           len = _mpd_real_size(result->data, len);
#  829|           /* resize to fewer words cannot fail */
#  830|->         mpd_qresize(result, len, &dummy);
#  831|           result->len = len;
#  832|           mpd_setdigits(result);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:817: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:830: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  828|           len = _mpd_real_size(result->data, len);
#  829|           /* resize to fewer words cannot fail */
#  830|->         mpd_qresize(result, len, &dummy);
#  831|           result->len = len;
#  832|           mpd_setdigits(result);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:817: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:830: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  828|           len = _mpd_real_size(result->data, len);
#  829|           /* resize to fewer words cannot fail */
#  830|->         mpd_qresize(result, len, &dummy);
#  831|           result->len = len;
#  832|           mpd_setdigits(result);
(Example-1) Reason Marked as False Positive:
The variable dummy is not used

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:846: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:866: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  864|               len = _mpd_real_size(result->data, len);
#  865|               /* resize to fewer words cannot fail */
#  866|->             mpd_qresize(result, len, &dummy);
#  867|               result->len = len;
#  868|               mpd_setdigits(result);
(Example-2) Reason Marked as False Positive:
The variable dummy is not used

', '2025-11-17 21:39:07.082777');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (350, 105, 'def20', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;', 'TRUE POSITIVE', 'Large index value (6442450944) from `_mpd_get_transform_len(*rsize)` at line 5665 is used without explicit overflow checks in `mpd_uint_zero` (line 5702) and `fnt_convolute` (line 5703), potentially leading to a buffer overrun, with no visible integer overflow protection in the provided code snippet.', 'The CVE report indicates a potential buffer overrun due to a very large index (6442450944) being passed to `fnt_convolute` at line 5703.

This large index value is assigned to `n` from the return value of `_mpd_get_transform_len(*rsize)` at line 5665, with no explicit checks for overflow in the provided code snippet.

The subsequent use of `n` in `mpd_uint_zero(vtmp+vlen, n-vlen)` at line 5702 and as an argument to `fnt_convolute` at line 5703 could indeed lead to a buffer overrun if `n` exceeds the valid bounds of the buffer.

Unlike the provided examples (Example-1 and Example-2) marked as FALSE POSITIVE, which mention that the function allocating memory (`mpd_sh_alloc`) checks for integer overflows, the current analysis does not have evidence of such checks within the provided code snippet for `_mpd_get_transform_len` or its interaction with the allocation of `vtmp`.

Given the direct correlation between the potentially oversized value of `n` and its use in memory operations without explicit overflow protection visible in the provided code, there is a demonstrable link to the vulnerability described in the CVE.

Uncertainty regarding the behavior of `_mpd_get_transform_len` and the allocation of `vtmp` does not provide sufficient grounds to conclude FALSE POSITIVE; instead, it reinforces the potential for a TRUE POSITIVE outcome due to the lack of explicit safety measures in the analyzed code paths.', 'Obtain and analyze the implementation of `_mpd_get_transform_len` to understand its return value bounds and potential for overflow.

Investigate the memory allocation for `vtmp` to determine if it includes checks for integer overflows or if such checks are handled elsewhere in the codebase.

Verify the input validation and bounds checking for `*rsize` to assess its impact on the return value of `_mpd_get_transform_len`.', 0.0000, '*** Source Code Context ***

code of libmpdec/mpdecimal.c file:
5651| static mpd_uint_t *
5652| _mpd_fntmul(const mpd_uint_t *u, const mpd_uint_t *v,
5653|             mpd_size_t ulen, mpd_size_t vlen,
5654|             mpd_size_t *rsize)
5655| {
5656|     mpd_uint_t *c1 = NULL, *c2 = NULL, *c3 = NULL, *vtmp = NULL;
5657|     mpd_size_t n;
5658| 
5659| #ifdef PPRO
5660|     unsigned int cw;
5661|     cw = mpd_set_fenv();
5662| #endif
5663| 
5664|     *rsize = add_size_t(ulen, vlen);
5665|     if ((n = _mpd_get_transform_len(*rsize)) == MPD_SIZE_MAX) {
5666|         goto malloc_error;
5667|     }
5668| 
5669|     if ((c1 = mpd_calloc(n, sizeof *c1)) == NULL) {
5670|         goto malloc_error;
5671|     }
5672|     if ((c2 = mpd_calloc(n, sizeof *c2)) == NULL) {
5673|         goto malloc_error;
5674|     }
5675|     if ((c3 = mpd_calloc(n, sizeof *c3)) == NULL) {
5676|         goto malloc_error;
5677|     }
5678| 
5679|     memcpy(c1, u, ulen * (sizeof *c1));
5680|     memcpy(c2, u, ulen * (sizeof *c2));
5681|     memcpy(c3, u, ulen * (sizeof *c3));
5682| 
5683|     if (u == v) {
5684|         if (!fnt_autoconvolute(c1, n, P1) ||
5685|             !fnt_autoconvolute(c2, n, P2) ||
5686|             !fnt_autoconvolute(c3, n, P3)) {
5687|             goto malloc_error;
5688|         }
5689|     }
5690|     else {
5691|         if ((vtmp = mpd_calloc(n, sizeof *vtmp)) == NULL) {
5692|             goto malloc_error;
5693|         }
5694| 
5695|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5696|         if (!fnt_convolute(c1, vtmp, n, P1)) {
5697|             mpd_free(vtmp);
5698|             goto malloc_error;
5699|         }
5700| 
5701|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5702|         mpd_uint_zero(vtmp+vlen, n-vlen);
5703|         if (!fnt_convolute(c2, vtmp, n, P2)) {
5704|             mpd_free(vtmp);
5705|             goto malloc_error;
5706|         }
5707| 
5708|         memcpy(vtmp, v, vlen * (sizeof *vtmp));
5709|         mpd_uint_zero(vtmp+vlen, n-vlen);
5710|         if (!fnt_convolute(c3, vtmp, n, P3)) {
5711|             mpd_free(vtmp);
5712|             goto malloc_error;
5713|         }
5714| 
5715|         mpd_free(vtmp);
5716|     }
5717| 
5718|     crt3(c1, c2, c3, *rsize);
5719| 
5720| out:
5721| #ifdef PPRO
5722|     mpd_restore_fenv(cw);
5723| #endif
5724|     if (c2) mpd_free(c2);
5725|     if (c3) mpd_free(c3);
5726|     return c1;
5727| 
5728| malloc_error:
5729|     if (c1) mpd_free(c1);
5730|     c1 = NULL;
5731|     goto out;
5732| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5703: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5701|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5702|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5703|->         if (!fnt_convolute(c2, vtmp, n, P2)) {
# 5704|               mpd_free(vtmp);
# 5705|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082777');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (401, 102, 'def4', 'UNINIT', 'glibc-2.39/libio/obprintf.c:82: var_decl: Declaring variable "buf" without initializer.
glibc-2.39/libio/obprintf.c:99: uninit_use: Using uninitialized value "buf.ch".
#   97|     if (buf.base.write_ptr == &buf.ch + 1)
#   98|       /* buf.ch is in use.  Put it into the obstack.  */
#   99|->     obstack_1grow (buf.obstack, buf.ch);
#  100|     else if (buf.base.write_ptr != &buf.ch)
#  101|       /* Shrink the buffer to the space we really currently need.  */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/libio/obprintf.c:82: var_decl: Declaring variable "buf" without initializer.
glibc-2.39/libio/obprintf.c:99: uninit_use: Using uninitialized value "buf.ch".
#   97|     if (buf.base.write_ptr == &buf.ch + 1)
#   98|       /* buf.ch is in use.  Put it into the obstack.  */
#   99|->     obstack_1grow (buf.obstack, buf.ch);
#  100|     else if (buf.base.write_ptr != &buf.ch)
#  101|       /* Shrink the buffer to the space we really currently need.  */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/libio/obprintf.c:82: var_decl: Declaring variable "buf" without initializer.
glibc-2.39/libio/obprintf.c:99: uninit_use: Using uninitialized value "buf.ch".
#   97|     if (buf.base.write_ptr == &buf.ch + 1)
#   98|       /* buf.ch is in use.  Put it into the obstack.  */
#   99|->     obstack_1grow (buf.obstack, buf.ch);
#  100|     else if (buf.base.write_ptr != &buf.ch)
#  101|       /* Shrink the buffer to the space we really currently need.  */
(Example-1) Reason Marked as False Positive:
ch is used as a temporary buffer, set up by __printf_buffer_flush_obstack, and protected by write_base and write_ptr.  It will only be read if it''s been set up as a queue and the queue written to.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/catgets/gencat.c:852: var_decl: Declaring variable "string_pool" without initializer.
glibc-2.39/catgets/gencat.c:974: assign: Assigning: "__o" = "&string_pool", which points to uninitialized data.
glibc-2.39/catgets/gencat.c:974: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
#  972|   	  /* Add current string to the continuous space containing all
#  973|   	     strings.  */
#  974|-> 	  obstack_grow0 (&string_pool, message_run->message,
#  975|   			 strlen (message_run->message));
#  976|
(Example-2) Reason Marked as False Positive:
call to obstack_init in line 950 makes the data initialized.

', '2025-11-17 21:39:07.118803');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (351, 105, 'def21', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c1" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5684: overrun-buffer-arg: Calling "fnt_autoconvolute" with "c2" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5682|   
# 5683|       if (u == v) {
# 5684|->         if (!fnt_autoconvolute(c1, n, P1) ||
# 5685|               !fnt_autoconvolute(c2, n, P2) ||
# 5686|               !fnt_autoconvolute(c3, n, P3)) {
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082778');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (352, 105, 'def22', 'UNINIT', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:2594: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:2614: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
# 2612|           size = mpd_digits_to_size(result->digits);
# 2613|           /* reducing the size cannot fail */
# 2614|->         mpd_qresize(result, size, &dummy);
# 2615|           result->len = size;
# 2616|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:2594: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:2614: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
# 2612|           size = mpd_digits_to_size(result->digits);
# 2613|           /* reducing the size cannot fail */
# 2614|->         mpd_qresize(result, size, &dummy);
# 2615|           result->len = size;
# 2616|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:2594: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:2614: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
# 2612|           size = mpd_digits_to_size(result->digits);
# 2613|           /* reducing the size cannot fail */
# 2614|->         mpd_qresize(result, size, &dummy);
# 2615|           result->len = size;
# 2616|       }
(Example-1) Reason Marked as False Positive:
The variable dummy is not used

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:846: var_decl: Declaring variable "dummy" without initializer.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:866: uninit_use_in_call: Using uninitialized value "dummy" when calling "mpd_qresize".
#  864|               len = _mpd_real_size(result->data, len);
#  865|               /* resize to fewer words cannot fail */
#  866|->             mpd_qresize(result, len, &dummy);
#  867|               result->len = len;
#  868|               mpd_setdigits(result);
(Example-2) Reason Marked as False Positive:
The variable dummy is not used

', '2025-11-17 21:39:07.082778');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (353, 105, 'def23', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5820: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5821: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5819|   
# 5820|       lt = m + m + 1;
# 5821|->     mpd_uint_zero(w, lt);
# 5822|   
# 5823|       if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5820: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5821: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5819|   
# 5820|       lt = m + m + 1;
# 5821|->     mpd_uint_zero(w, lt);
# 5822|   
# 5823|       if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5820: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5821: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5819|   
# 5820|       lt = m + m + 1;
# 5821|->     mpd_uint_zero(w, lt);
# 5822|   
# 5823|       if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, m)) {
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5787: assignment: Assigning: "lt" = "m + m + 1UL". The value of "lt" is now at least 6442450947.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5788: overrun-buffer-arg: Calling "mpd_uint_zero" with "w" and "lt" is suspicious because of the very large index, 6442450947. The index may be due to a negative parameter being interpreted as unsigned.
# 5786|   
# 5787|           lt = m + m + 1;         /* space needed for the result array */
# 5788|->         mpd_uint_zero(w, lt);   /* clear result array */
# 5789|           if (!_karatsuba_rec_fnt(w, a, b, w+lt, m, lb)) {  /* al*b */
# 5790|               return 0; /* GCOV_UNLIKELY */
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082778');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (354, 105, 'def24', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "vtmp" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;
(Example-1) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: return_constant: Function call "_mpd_get_transform_len(*rsize)" may return 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5665: assignment: Assigning: "n" = "_mpd_get_transform_len(*rsize)". The value of "n" is now 6442450944.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5710: overrun-buffer-arg: Calling "fnt_convolute" with "c3" and "n" is suspicious because of the very large index, 6442450944. The index may be due to a negative parameter being interpreted as unsigned.
# 5708|           memcpy(vtmp, v, vlen * (sizeof *vtmp));
# 5709|           mpd_uint_zero(vtmp+vlen, n-vlen);
# 5710|->         if (!fnt_convolute(c3, vtmp, n, P3)) {
# 5711|               mpd_free(vtmp);
# 5712|               goto malloc_error;
(Example-2) Reason Marked as False Positive:
The function that allocates memory (mpd_sh_alloc) checks for integer overflows.

', '2025-11-17 21:39:07.082779');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (396, 108, 'def2', 'STRING_SIZE', 'rpcbind-1.2.6/src/rpcbind.c:149: string_size_argv: "argv" contains strings with unknown size.
rpcbind-1.2.6/src/rpcbind.c:204: string_size: Passing string "argv[0]" of unknown size to "syslog".
#  202|   		nconf = getnetconfigent("unix");
#  203|   	if (nconf == NULL) {
#  204|-> 		syslog(LOG_ERR, "%s: can''t find local transport\n", argv[0]);
#  205|   		exit(1);
#  206|   	}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: rpcbind-1.2.6/src/rpcbind.c:149: string_size_argv: "argv" contains strings with unknown size.
rpcbind-1.2.6/src/rpcbind.c:204: string_size: Passing string "argv[0]" of unknown size to "syslog".
#  202|    conf = getnetconfigent("unix");
#  203|   if (nconf == NULL) {
#  204|->   syslog(LOG_ERR, "%s: can''t find local transport\n", argv[0]);
#  205|    exit(1);
#  206|   }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error STRING_SIZE (CWE-120):
rpcbind-1.2.6/src/rpcbind.c:149: string_size_argv: "argv" contains strings with unknown size.
rpcbind-1.2.6/src/rpcbind.c:204: string_size: Passing string "argv[0]" of unknown size to "syslog".
#  202|   		nconf = getnetconfigent("unix");
#  203|   	if (nconf == NULL) {
#  204|-> 		syslog(LOG_ERR, "%s: can''t find local transport
", argv[0]);
#  205|   		exit(1);
#  206|   	}
(Example-1) Reason Marked as False Positive:
The sizes of argv strings is controled by the shell

', '2025-11-17 21:39:07.107499');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (355, 105, 'def25', 'OVERRUN', 'mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "b" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "b" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "b" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);
(Example-1) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5747: cond_at_least: Checking "la <= 6442450944ULL" implies that "la" is at least 6442450945 on the false branch.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5765: assignment: Assigning: "m" = "(la + 1UL) / 2UL". The value of "m" is now at least 3221225473.
mpdecimal-2.5.1/libmpdec/mpdecimal.c:5802: overrun-buffer-arg: Calling "memcpy" with "w + (m + 1UL)" and "m * 8UL" is suspicious because of the very large index, 25769803784. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 5800|       _mpd_baseaddto(w, a+m, la-m);
# 5801|   
# 5802|->     memcpy(w+(m+1), b, m * sizeof *w);
# 5803|       w[m+1+m] = 0;
# 5804|       _mpd_baseaddto(w+(m+1), b+m, lb-m);
(Example-2) Reason Marked as False Positive:
The number is unsigned, hence the big value is expected there.

', '2025-11-17 21:39:07.082779');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (356, 110, 'def1', 'READLINK', 'sysfsutils-2.1.1/lib/sysfs_utils.c:154: readlink_call: Passing size argument "256UL" implies readlink() can return up to "256UL" bytes.
sysfsutils-2.1.1/lib/sysfs_utils.c:154: readlink_assign: Assigning: "count" = readlink().
sysfsutils-2.1.1/lib/sysfs_utils.c:158: readlink: "linkpath[count]" is essentially buffer[sizeof(buffer)] which is an off-by-one error.
#  156|   		return -1;
#  157|   	else
#  158|-> 		linkpath[count] = ''\0'';
#  159|   	/*
#  160|   	 * Three cases here:', 'TRUE POSITIVE', 'Assignment at line 158 (`linkpath[count] = ''
''`) can write one byte beyond the buffer''s last returned byte by `readlink`, assuming `count` equals `SYSFS_PATH_MAX` (256), constituting an off-by-one error and potential buffer overflow vulnerability.', 'The CVE report highlights a potential off-by-one error at line 158, where `linkpath[count] = ''
'';` is executed.

The `count` variable is assigned the return value of `readlink(path, linkpath, SYSFS_PATH_MAX)` at line 154.

According to the POSIX `readlink` specification, the return value is the number of bytes placed in the buffer, **not including the null terminator**.

Since `SYSFS_PATH_MAX` (implied to be 256 by the CVE report, although not explicitly defined in the provided code snippet) is passed as the size argument to `readlink`, the function can indeed return up to `256` bytes (excluding the null terminator).

At line 158, assigning `''
''` to `linkpath[count]` effectively writes **one byte beyond the last byte returned by `readlink`**, assuming `count` equals `SYSFS_PATH_MAX` (256 in this context).

This scenario aligns with the definition of an off-by-one error, where the buffer''s bounds are exceeded by a single unit, potentially leading to undefined behavior or a buffer overflow vulnerability.

Given the direct correlation between the code''s behavior and the described vulnerability, and without explicit proof that all execution paths are safe (e.g., an implicit guarantee that `readlink` never returns `SYSFS_PATH_MAX` bytes), the finding cannot be conclusively deemed a FALSE POSITIVE.', 'Provide the definition or value of `SYSFS_PATH_MAX` to confirm it matches the implied value of 256.

Verify the implementation or behavior of `readlink` in this specific context to ensure it never returns a value equal to `SYSFS_PATH_MAX`, potentially mitigating the off-by-one error.

Analyze all possible execution paths leading to the `readlink_call` at line 154 to ensure no other conditions could lead to a buffer overflow vulnerability.', 0.0000, '*** Source Code Context ***

code of lib/sysfs_utils.c file:
142| int sysfs_get_link(const char *path, char *target, size_t len)
143| {
144| 	char devdir[SYSFS_PATH_MAX];
145| 	char linkpath[SYSFS_PATH_MAX];
146| 	char *d, *s;
147| 	int count;
148| 
149| 	if (!path || !target || len == 0) {
150| 		errno = EINVAL;
151| 		return -1;
152| 	}
153| 
154| 	count = readlink(path, linkpath, SYSFS_PATH_MAX);
155| 	if (count < 0)
156| 		return -1;
157| 	else
158| 		linkpath[count] = ''\0'';
159| 	/*
160| 	 * Three cases here:
161| 	 * 1. relative path => format ../..
162| 	 * 2. absolute path => format /abcd/efgh
163| 	 * 3. relative path _from_ this dir => format abcd/efgh
164| 	 */
165| 	if (*linkpath == ''/'') {
166| 		/* absolute path - copy as is */
167| 		safestrcpymax(target, linkpath, len);
168| 		return 0;
169| 	}
170| 
171| 	safestrcpy(devdir, path);
172| 	s = strrchr(devdir, ''/'');
173| 	if (s == NULL)
174| 		s = devdir - 1;
175| 	d = linkpath;
176| 	while (*d == ''.'') {
177| 		if (*(d+1) == ''/'') {
178| 			/*
179| 			 * handle the case where link is of type ./abcd/xxx
180| 			 */
181| 			d += 2;
182| 			while (*d == ''/'')
183| 				d++;
184| 			continue;
185| 		} else if (*(d+1) != ''.'' || *(d+2) != ''/'')
186| 			/*
187| 			 * relative path from this directory, starting
188| 			 * with a hidden directory
189| 			 */
190| 			break;
191| 
192| 		/*
193| 		 * relative path, getting rid of leading "../.."; must
194| 		 * be careful here since any path component of devdir
195| 		 * could be a symlink again
196| 		 */
197| 		for (;;) {
198| 			while (s > devdir && *s == ''/'') {
199| 				s--;
200| 				if (*s == ''.''
201| 				    && (s == devdir || *(s-1) == ''/''))
202| 					s--;
203| 			}
204| 			*(s+1) = ''\0'';
205| 			if (*devdir == ''\0'' || sysfs_path_is_link(devdir))
206| 				/*
207| 				 * condition will be true eventually
208| 				 * because we already know that all
209| 				 * but the last component of path
210| 				 * resolve to a directory
211| 				 */
212| 				break;
213| 			if (sysfs_get_link(devdir, devdir, SYSFS_PATH_MAX))
214| 				return -1;
215| 			s = devdir + strlen(devdir) - 1;
216| 		}
217| 		while (s >= devdir) {
218| 			if (*s == ''/'') {
219| 				if (*(s+1) != ''.'' || *(s+2) != ''.''
220| 				    || *(s+3) != ''\0'') {
221| 					d += 3;
222| 					while (*d == ''/'')
223| 						d++;
224| 				} else
225| 					s += 2;
226| 				break;
227| 			}
228| 			s--;
229| 		}
230| 		if (s < devdir || *(s+1) == ''\0'')
231| 			break;
232| 	}
233| 
234| 	/*
235| 	 * appending to devdir a slash and the (possibly shortened)
236| 	 * relative path to the link source
237| 	 */
238| 	s++;
239| 	if (s > devdir && *s == ''\0'')
240| 		*s++ = ''/'';
241| 	*s = ''\0'';
242| 	safestrcpymax(s, d, SYSFS_PATH_MAX-(s-devdir));
243| 	safestrcpymax(target, devdir, len);
244| 	return 0;
245| }


*** Examples ***
', '2025-11-17 21:39:07.091425');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (357, 110, 'def2', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_attr.c:507: alloc_fn: Storage is returned from allocation function "opendir".
sysfsutils-2.1.1/lib/sysfs_attr.c:507: var_assign: Assigning: "dir" = storage returned from "opendir(path)".
sysfsutils-2.1.1/lib/sysfs_attr.c:512: noescape: Resource "dir" is not freed or pointed-to in "readdir".
sysfsutils-2.1.1/lib/sysfs_attr.c:527: leaked_storage: Variable "dir" going out of scope leaks the storage it points to.
#  525|   				if (!dirlist) {
#  526|   					dbg_printf("Error creating list\n");
#  527|-> 					return NULL;
#  528|   				}
#  529|   			}', 'TRUE POSITIVE', 'Resource leak confirmed: `dir` (allocated by `opendir()` at line 507) is not freed in the error path leading to `return NULL` at line 527, despite being freed only upon normal loop completion at line 535.', 'The CVE report indicates a potential resource leak due to unfreed storage allocated by `opendir()` (line 507).

The `dir` variable, assigned the result of `opendir(path)`, is indeed used in `readdir()` (implied by the loop starting at line 512, though the direct call to `readdir()` is not shown, the context suggests its usage within the loop).

Critically, if the execution path reaches the `return NULL` statement at line 527 (due to the `if (!dirlist)` condition at line 525), the function terminates without freeing the `dir` resource.

The loop that uses `dir` (starting at line 512) does eventually lead to a `closedir(dir)` call at line 535, but this only occurs if the loop completes normally, not if the function exits prematurely via the `return NULL` at line 527.

There is no explicit code within the provided snippet that guarantees the `dir` resource is freed in the error path leading to line 527, thus confirming the resource leak concern.

Unlike the provided FALSE POSITIVE examples (Example-1 and Example-2), where the false positive was due to a misunderstanding of the code''s logic (e.g., NULL checks and allocations), this scenario directly shows an execution path where the resource is not freed.', NULL, 0.0000, '*** Source Code Context ***

code of lib/sysfs_attr.c file:
496| struct dlist *read_dir_subdirs(const char *path)
497| {
498| 	DIR *dir = NULL;
499| 	struct dirent *dirent = NULL;
500| 	char file_path[SYSFS_PATH_MAX], *dir_name;
501| 	struct dlist *dirlist = NULL;
502| 
503| 	if (!path) {
504| 		errno = EINVAL;
505| 		return NULL;
506| 	}
507| 	dir = opendir(path);
508| 	if (!dir) {
509| 		dbg_printf("Error opening directory %s
", path);
510| 		return NULL;
511| 	}
512| 	while ((dirent = readdir(dir)) != NULL) {
513| 		if (0 == strcmp(dirent->d_name, "."))
514| 			 continue;
515| 		if (0 == strcmp(dirent->d_name, ".."))
516| 			continue;
517| 		memset(file_path, 0, SYSFS_PATH_MAX);
518| 		safestrcpy(file_path, path);
519| 		safestrcat(file_path, "/");
520| 		safestrcat(file_path, dirent->d_name);
521| 		if (!sysfs_path_is_dir(file_path)) {
522| 			if (!dirlist) {
523| 				dirlist = dlist_new_with_delete
524| 					(SYSFS_NAME_LEN, sysfs_del_name);
525| 				if (!dirlist) {
526| 					dbg_printf("Error creating list
");
527| 					return NULL;
528| 				}
529| 			}
530| 			dir_name = (char *)calloc(1, SYSFS_NAME_LEN);
531| 			safestrcpymax(dir_name, dirent->d_name, SYSFS_NAME_LEN);
532| 			dlist_unshift_sorted(dirlist, dir_name, sort_char);
533| 		}
534| 	}
535| 	closedir(dir);
536| 	return dirlist;
537| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-1) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-2) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

', '2025-11-17 21:39:07.09143');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (358, 110, 'def3', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_device.c:242: alloc_fn: Storage is returned from allocation function "sysfs_read_dir_subdirs".
sysfsutils-2.1.1/lib/sysfs_device.c:242: var_assign: Assigning: "devlist" = storage returned from "sysfs_read_dir_subdirs(path)".
sysfsutils-2.1.1/lib/sysfs_device.c:251: leaked_storage: Variable "devlist" going out of scope leaks the storage it points to.
#  249|   						cur->path);
#  250|   				sysfs_close_device_tree(rootdev);
#  251|-> 				return NULL;
#  252|   			}
#  253|   			if (rootdev->children == NULL)', 'TRUE POSITIVE', 'Memory allocated for `devlist` at line 242 is not explicitly freed before going out of scope at line 251, despite being potentially used only in a non-freening iteration (lines 244-249), aligning with CWE-772 (Resource Leak) description.', 'The variable `devlist` is assigned the storage returned from `sysfs_read_dir_subdirs(path)` at line 242, indicating a memory allocation.

At line 251, the function returns `NULL` without freeing the storage pointed to by `devlist`, which is within the scope of the function.

The only operation performed on `devlist` before the potential leak at line 251 is the iteration over its `children` (lines 244-249). However, there is no evidence within the provided code that this iteration frees or transfers ownership of the `devlist` storage.

The call to `sysfs_close_device_tree(rootdev)` at line 250 does not imply the freeing of `devlist` storage, as `rootdev` and `devlist` are distinct pointers (allocated/initiated at different lines: 236 for `rootdev` and 242 for `devlist`).

There is no explicit deallocation (e.g., `free()`, a custom deallocation function, or a transfer of ownership) of the `devlist` storage within the provided code snippet before it goes out of scope at line 251, aligning with the CWE-772 (Resource Leak) description.

Unlike the provided FALSE POSITIVE examples, there is no null check or function call within the given context that would suggest `devlist`''s storage is handled elsewhere, making the leak apparent based on the explicit code behavior.', NULL, 0.0000, '*** Source Code Context ***

code of lib/sysfs_device.c file:
226| struct sysfs_device *sysfs_open_device_tree(const char *path)
227| {
228| 	struct sysfs_device *rootdev = NULL, *new = NULL;
229| 	struct sysfs_device *cur = NULL;
230| 	struct sysfs_device *devlist;
231| 
232| 	if (path == NULL) {
233| 		errno = EINVAL;
234| 		return NULL;
235| 	}
236| 	rootdev = sysfs_open_device_path(path);
237| 	if (rootdev == NULL) {
238| 		dbg_printf("Error opening root device at %s
", path);
239| 		return NULL;
240| 	}
241| 
242| 	devlist = sysfs_read_dir_subdirs(path);
243|         if (devlist->children) {
244| 		dlist_for_each_data(devlist->children, cur,
245| 				struct sysfs_device) {
246| 			new = sysfs_open_device_tree(cur->path);
247| 			if (new == NULL) {
248| 				dbg_printf("Error opening device tree at %s
",
249| 						cur->path);
250| 				sysfs_close_device_tree(rootdev);
251| 				return NULL;
252| 			}
253| 			if (rootdev->children == NULL)
254| 				rootdev->children = dlist_new_with_delete
255| 					(sizeof(struct sysfs_device),
256| 					sysfs_close_dev_tree);
257| 			dlist_unshift_sorted(rootdev->children, new, sort_list);
258| 		}
259| 	}
260| 
261| 	return rootdev;
262| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-1) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-2) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

', '2025-11-17 21:39:07.09143');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (359, 110, 'def4', 'OVERRUN', 'sysfsutils-2.1.1/lib/sysfs_utils.c:154: identity_transfer: Passing "256UL" as argument 3 to function "readlink", which returns that argument. [Note: The source code implementation of the function has been overridden by a builtin model.]
sysfsutils-2.1.1/lib/sysfs_utils.c:154: assignment: Assigning: "count" = "readlink(path, linkpath, 256UL)". The value of "count" is now 256.
sysfsutils-2.1.1/lib/sysfs_utils.c:158: overrun-local: Overrunning array "linkpath" of 256 bytes at byte offset 256 using index "count" (which evaluates to 256).
#  156|   		return -1;
#  157|   	else
#  158|-> 		linkpath[count] = ''\0'';
#  159|   	/*
#  160|   	 * Three cases here:', 'TRUE POSITIVE', 'Assignment of `count` with `readlink`''s return value (line 154) leads to out-of-bounds access of `linkpath` array (line 158) when `count` equals 256, as the last valid index for a 256-element array is 255, directly correlating with the reported ''overrun-local'' vulnerability.', 'The `readlink` function at line 154 is called with a buffer size of `256UL`, which is then assigned to the variable `count`.

The `count` variable is used as an index to access the `linkpath` array at line 158 (`linkpath[count] = ''
'';`).

Given that `count` is assigned the value `256` (as per the CVE report snippet), this access would indeed be out of bounds for the `linkpath` array, which is declared with a size of `SYSFS_PATH_MAX` (assumed to be 256, as per the context).

Accessing an array at its exact size (e.g., `linkpath[256]` for a 256-element array) is an out-of-bounds access, as arrays in C are 0-indexed, meaning the last valid index is `255`.

This out-of-bounds access matches the description of an ''overrun-local'' vulnerability, as reported in the CVE snippet, specifically at line 158.

**Direct Evidence from Provided Code:** Lines 154 (assignment of `count`) and 158 (use of `count` to index `linkpath`) directly correlate with the reported vulnerability, confirming the issue without relying on inferred behavior.', NULL, 0.0000, '*** Source Code Context ***

code of lib/sysfs_utils.c file:
142| int sysfs_get_link(const char *path, char *target, size_t len)
143| {
144| 	char devdir[SYSFS_PATH_MAX];
145| 	char linkpath[SYSFS_PATH_MAX];
146| 	char *d, *s;
147| 	int count;
148| 
149| 	if (!path || !target || len == 0) {
150| 		errno = EINVAL;
151| 		return -1;
152| 	}
153| 
154| 	count = readlink(path, linkpath, SYSFS_PATH_MAX);
155| 	if (count < 0)
156| 		return -1;
157| 	else
158| 		linkpath[count] = ''\0'';
159| 	/*
160| 	 * Three cases here:
161| 	 * 1. relative path => format ../..
162| 	 * 2. absolute path => format /abcd/efgh
163| 	 * 3. relative path _from_ this dir => format abcd/efgh
164| 	 */
165| 	if (*linkpath == ''/'') {
166| 		/* absolute path - copy as is */
167| 		safestrcpymax(target, linkpath, len);
168| 		return 0;
169| 	}
170| 
171| 	safestrcpy(devdir, path);
172| 	s = strrchr(devdir, ''/'');
173| 	if (s == NULL)
174| 		s = devdir - 1;
175| 	d = linkpath;
176| 	while (*d == ''.'') {
177| 		if (*(d+1) == ''/'') {
178| 			/*
179| 			 * handle the case where link is of type ./abcd/xxx
180| 			 */
181| 			d += 2;
182| 			while (*d == ''/'')
183| 				d++;
184| 			continue;
185| 		} else if (*(d+1) != ''.'' || *(d+2) != ''/'')
186| 			/*
187| 			 * relative path from this directory, starting
188| 			 * with a hidden directory
189| 			 */
190| 			break;
191| 
192| 		/*
193| 		 * relative path, getting rid of leading "../.."; must
194| 		 * be careful here since any path component of devdir
195| 		 * could be a symlink again
196| 		 */
197| 		for (;;) {
198| 			while (s > devdir && *s == ''/'') {
199| 				s--;
200| 				if (*s == ''.''
201| 				    && (s == devdir || *(s-1) == ''/''))
202| 					s--;
203| 			}
204| 			*(s+1) = ''\0'';
205| 			if (*devdir == ''\0'' || sysfs_path_is_link(devdir))
206| 				/*
207| 				 * condition will be true eventually
208| 				 * because we already know that all
209| 				 * but the last component of path
210| 				 * resolve to a directory
211| 				 */
212| 				break;
213| 			if (sysfs_get_link(devdir, devdir, SYSFS_PATH_MAX))
214| 				return -1;
215| 			s = devdir + strlen(devdir) - 1;
216| 		}
217| 		while (s >= devdir) {
218| 			if (*s == ''/'') {
219| 				if (*(s+1) != ''.'' || *(s+2) != ''.''
220| 				    || *(s+3) != ''\0'') {
221| 					d += 3;
222| 					while (*d == ''/'')
223| 						d++;
224| 				} else
225| 					s += 2;
226| 				break;
227| 			}
228| 			s--;
229| 		}
230| 		if (s < devdir || *(s+1) == ''\0'')
231| 			break;
232| 	}
233| 
234| 	/*
235| 	 * appending to devdir a slash and the (possibly shortened)
236| 	 * relative path to the link source
237| 	 */
238| 	s++;
239| 	if (s > devdir && *s == ''\0'')
240| 		*s++ = ''/'';
241| 	*s = ''\0'';
242| 	safestrcpymax(s, d, SYSFS_PATH_MAX-(s-devdir));
243| 	safestrcpymax(target, devdir, len);
244| 	return 0;
245| }


*** Examples ***
', '2025-11-17 21:39:07.091431');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (360, 110, 'def5', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_attr.c:555: alloc_fn: Storage is returned from allocation function "opendir".
sysfsutils-2.1.1/lib/sysfs_attr.c:555: var_assign: Assigning: "dir" = storage returned from "opendir(path)".
sysfsutils-2.1.1/lib/sysfs_attr.c:560: noescape: Resource "dir" is not freed or pointed-to in "readdir".
sysfsutils-2.1.1/lib/sysfs_attr.c:576: leaked_storage: Variable "dir" going out of scope leaks the storage it points to.
#  574|   				if (!alist) {
#  575|   					dbg_printf("Error creating list\n");
#  576|-> 					return NULL;
#  577|   				}
#  578|   			}', 'TRUE POSITIVE', 'Resource leak confirmed as `dir` (allocated by `opendir()` at line 555) is not freed in the error path when `alist` is `NULL` (lines 574-576), unlike the successful path where `closedir(dir)` is called (line 582).', 'The CVE report indicates a potential resource leak due to the allocation of storage via `opendir()` (line 555) not being freed in all execution paths.

The `dir` variable, assigned the storage from `opendir()`, is indeed used in `readdir()` (line 560) but the CVE tool correctly identifies that within the specific execution path leading to line 576, `dir` is not explicitly freed or pointed-to after its last use.

The key execution path leading to the potential leak is when `alist` is `NULL`, triggering an error condition (lines 574-576), where `dbg_printf()` is called, followed by an immediate `return NULL;` (line 576).

Within this error path, there is no call to `closedir(dir)` to free the resource allocated by `opendir()`, unlike the successful execution path where `closedir(dir)` is called (line 582) after the `while` loop.

Since at least one identifiable execution path (the error condition when `alist` is `NULL`) leads to the resource not being freed, this satisfies the condition for a TRUE POSITIVE finding.

Comparison with provided FALSE POSITIVE examples (Example-1 and Example-2) reveals that those cases involved misinterpretation of NULL checks and function calls not present in this specific scenario, reinforcing the conclusion that this case does not align with the reasons for those false positives.', NULL, 0.0000, '*** Source Code Context ***

code of lib/sysfs_attr.c file:
544| struct dlist *get_attributes_list(struct dlist *alist, const char *path)
545| {
546| 	DIR *dir = NULL;
547| 	struct dirent *dirent = NULL;
548| 	char file_path[SYSFS_PATH_MAX];
549| 
550| 	if (!path) {
551| 		errno = EINVAL;
552| 		return NULL;
553| 	}
554| 
555| 	dir = opendir(path);
556| 	if (!dir) {
557| 		dbg_printf("Error opening directory %s
", path);
558| 		return NULL;
559| 	}
560| 	while ((dirent = readdir(dir)) != NULL) {
561| 		if (0 == strcmp(dirent->d_name, "."))
562| 			 continue;
563| 		if (0 == strcmp(dirent->d_name, ".."))
564| 			continue;
565| 		memset(file_path, 0, SYSFS_PATH_MAX);
566| 		safestrcpy(file_path, path);
567| 		safestrcat(file_path, "/");
568| 		safestrcat(file_path, dirent->d_name);
569| 		if (!sysfs_path_is_file(file_path)) {
570| 			if (!alist) {
571| 				alist = dlist_new_with_delete
572| 					(sizeof(struct sysfs_attribute),
573| 							sysfs_del_attribute);
574| 				if (!alist) {
575| 					dbg_printf("Error creating list
");
576| 					return NULL;
577| 				}
578| 			}
579| 			add_attribute_to_list(alist, file_path);
580| 		}
581| 	}
582| 	closedir(dir);
583| 	return alist;
584| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-1) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-2) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

', '2025-11-17 21:39:07.091431');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (361, 110, 'def6', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_attr.c:468: alloc_fn: Storage is returned from allocation function "sysfs_open_device_path".
sysfsutils-2.1.1/lib/sysfs_attr.c:468: var_assign: Assigning: "dev" = storage returned from "sysfs_open_device_path(path)".
sysfsutils-2.1.1/lib/sysfs_attr.c:473: leaked_storage: Variable "dev" going out of scope leaks the storage it points to.
#  471|   	if (!dir) {
#  472|   		dbg_printf("Error opening directory %s\n", path);
#  473|-> 		return NULL;
#  474|   	}
#  475|   	while ((dirent = readdir(dir)) != NULL) {', 'TRUE POSITIVE', 'Memory allocated for `dev` at line 468 is not freed before returning `NULL` at line 473 when `dir` is `NULL`, directly indicating a memory leak in the error handling path, with no evident mitigating memory management in the provided code context.', 'The CVE report indicates a potential resource leak (CWE-772) at line 473 in `sysfs_attr.c` due to the variable `dev` going out of scope without freeing the storage it points to.

At line 468, `dev` is assigned the storage returned from `sysfs_open_device_path(path)`, which implies dynamic memory allocation.

The error handling block (lines 471-473) checks if `dir` is `NULL` and, if so, prints an error message and immediately returns `NULL` without freeing the memory allocated for `dev`.

Specifically, at line 473, the function returns `NULL` without any preceding call to free the memory allocated for `dev`, which is a direct indication of a memory leak for the `dev` variable in this error path.

The provided source code does not show any explicit memory management (e.g., `free()`) for `dev` in the scope of the function, especially in the error handling path leading to line 473.

Unlike the provided false positive examples (Example-1 and Example-2), there is no evident null check or subsequent memory management that would suggest the reported leak is mitigated within the provided code context.

Given the explicit behavior observed in the code and the description in the CVE report, there is a clear, direct correlation between the code''s behavior and the described vulnerability, indicating a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of lib/sysfs_attr.c file:
456| struct sysfs_device *sysfs_read_dir_subdirs(const char *path)
457| {
458| 	DIR *dir = NULL;
459| 	struct dirent *dirent = NULL;
460| 	char file_path[SYSFS_PATH_MAX];
461| 	struct sysfs_device *dev = NULL;
462| 
463| 	if (!path) {
464| 		errno = EINVAL;
465| 		return NULL;
466| 	}
467| 
468| 	dev = sysfs_open_device_path(path);
469| 
470| 	dir = opendir(path);
471| 	if (!dir) {
472| 		dbg_printf("Error opening directory %s
", path);
473| 		return NULL;
474| 	}
475| 	while ((dirent = readdir(dir)) != NULL) {
476| 		if (0 == strcmp(dirent->d_name, "."))
477| 			 continue;
478| 		if (0 == strcmp(dirent->d_name, ".."))
479| 			continue;
480| 		memset(file_path, 0, SYSFS_PATH_MAX);
481| 		safestrcpy(file_path, path);
482| 		safestrcat(file_path, "/");
483| 		safestrcat(file_path, dirent->d_name);
484| 		if (!sysfs_path_is_dir(file_path))
485| 			add_subdirectory(dev, file_path);
486| 	}
487| 	closedir(dir);
488| 	return dev;
489| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-1) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-2) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

', '2025-11-17 21:39:07.091431');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (362, 110, 'def7', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_driver.c:245: alloc_fn: Storage is returned from allocation function "sysfs_open_device".
sysfsutils-2.1.1/lib/sysfs_driver.c:245: var_assign: Assigning: "dev" = storage returned from "sysfs_open_device(drv->bus, ln)".
sysfsutils-2.1.1/lib/sysfs_driver.c:258: leaked_storage: Variable "dev" going out of scope leaks the storage it points to.
#  256|   					dbg_printf("Error creating device list\n");
#  257|   					sysfs_close_list(linklist);
#  258|-> 					return NULL;
#  259|   				}
#  260|   			}', 'TRUE POSITIVE', 'Variable `dev` is allocated at line 245 but not freed before returning `NULL` at line 258 in the error handling block, indicating a potential resource leak, as only `linklist` is closed (line 257) and not `dev`.', 'The variable `dev` is assigned the storage returned from `sysfs_open_device(drv->bus, ln)` at line 245, indicating a resource allocation.

At line 258, the function returns `NULL` without freeing or closing the resource pointed to by `dev`, which is within the scope of the error handling block (lines 255-259).

There is no explicit evidence in the provided code snippet that the storage allocated for `dev` is freed or released before the function returns `NULL` at line 258, specifically in the error path.

The `sysfs_close_list(linklist)` call at line 257 only closes the `linklist` resource, not the `dev` resource, which is a separate allocation.

The lack of a corresponding `sysfs_close_device(dev)` or similar call before returning at line 258 suggests a potential resource leak for the `dev` variable in this error path.

Since at least one execution path (the error path leading to line 258) potentially leads to the resource leak described in the CVE, the finding cannot be conclusively marked as a FALSE POSITIVE based on the provided code.', 'Examine the implementation of `sysfs_open_device` to determine the type of resource it allocates and the expected deallocation method.

Verify if there are any other execution paths in the code that might free the `dev` resource before it goes out of scope.

Investigate the project''s documentation or coding standards for resource management conventions that might apply to `sysfs_open_device` and `dev`.', 0.0000, '*** Source Code Context ***

code of lib/sysfs_driver.c file:
227| struct dlist *sysfs_get_driver_devices(struct sysfs_driver *drv)
228| {
229| 	char *ln = NULL;
230| 	struct dlist *linklist = NULL;
231| 	struct sysfs_device *dev = NULL;
232| 
233| 	if (!drv) {
234| 		errno = EINVAL;
235| 		return NULL;
236| 	}
237| 
238| 	linklist = read_dir_links(drv->path);
239| 	if (linklist) {
240| 		dlist_for_each_data(linklist, ln, char) {
241| 
242| 			if (!strncmp(ln, SYSFS_MODULE_NAME, strlen(ln)))
243| 				continue;
244| 
245| 			dev = sysfs_open_device(drv->bus, ln);
246| 			if (!dev) {
247| 				dbg_printf("Error opening driver''s device
");
248| 				sysfs_close_list(linklist);
249| 				return NULL;
250| 			}
251| 			if (!drv->devices) {
252| 				drv->devices = dlist_new_with_delete
253| 					(sizeof(struct sysfs_device),
254| 					 sysfs_close_driver_device);
255| 				if (!drv->devices) {
256| 					dbg_printf("Error creating device list
");
257| 					sysfs_close_list(linklist);
258| 					return NULL;
259| 				}
260| 			}
261| 			dlist_unshift_sorted(drv->devices, dev, sort_list);
262| 		}
263| 		sysfs_close_list(linklist);
264| 	}
265| 	return drv->devices;
266| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-1) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-2) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

', '2025-11-17 21:39:07.091432');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (363, 110, 'def8', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_device.c:242: alloc_fn: Storage is returned from allocation function "sysfs_read_dir_subdirs".
sysfsutils-2.1.1/lib/sysfs_device.c:242: var_assign: Assigning: "devlist" = storage returned from "sysfs_read_dir_subdirs(path)".
sysfsutils-2.1.1/lib/sysfs_device.c:261: leaked_storage: Variable "devlist" going out of scope leaks the storage it points to.
#  259|   	}
#  260|   
#  261|-> 	return rootdev;
#  262|   }
#  263|', 'TRUE POSITIVE', 'Memory allocated for `devlist` at line 242 is not explicitly freed or transferred before going out of scope at line 261, indicating a potential RESOURCE_LEAK (CWE-772) with no evident null check or external memory handling to refute the leak.', 'The variable `devlist` is assigned the storage returned from `sysfs_read_dir_subdirs(path)` at line 242, indicating a memory allocation.

There is no explicit `free` or deallocation operation performed on `devlist` within the provided code snippet.

At line 261, `devlist` goes out of scope when the function returns `rootdev`, without any evidence of its allocated storage being released.

The absence of a visible `free` or transfer of ownership for `devlist`''s allocated memory within the provided code implies a memory leak, aligning with the CWE-772 (RESOURCE_LEAK) description.

Unlike the provided FALSE POSITIVE examples (Example-1 and Example-2), there is no evident null check or function call within the given code context that would suggest `devlist`''s memory is handled elsewhere, thus no clear indication to refute the leak.

Given the explicit allocation and implicit deallocation (none visible within the scope), at least one execution path (the function''s return at line 261) potentially triggers the described vulnerability, satisfying the criteria for a TRUE POSITIVE finding.', 'Verify the implementation of `sysfs_read_dir_subdirs` to check for any internal memory management that might release the allocated storage for `devlist`.

Inspect the calling functions and the overall program flow to ensure no implicit deallocation or transfer of ownership for `devlist`''s allocated memory occurs outside the provided code snippet.

Check for any project-specific memory management conventions or macros that could affect the allocation and deallocation of `devlist`.', 0.0000, '*** Source Code Context ***

code of lib/sysfs_device.c file:
226| struct sysfs_device *sysfs_open_device_tree(const char *path)
227| {
228| 	struct sysfs_device *rootdev = NULL, *new = NULL;
229| 	struct sysfs_device *cur = NULL;
230| 	struct sysfs_device *devlist;
231| 
232| 	if (path == NULL) {
233| 		errno = EINVAL;
234| 		return NULL;
235| 	}
236| 	rootdev = sysfs_open_device_path(path);
237| 	if (rootdev == NULL) {
238| 		dbg_printf("Error opening root device at %s
", path);
239| 		return NULL;
240| 	}
241| 
242| 	devlist = sysfs_read_dir_subdirs(path);
243|         if (devlist->children) {
244| 		dlist_for_each_data(devlist->children, cur,
245| 				struct sysfs_device) {
246| 			new = sysfs_open_device_tree(cur->path);
247| 			if (new == NULL) {
248| 				dbg_printf("Error opening device tree at %s
",
249| 						cur->path);
250| 				sysfs_close_device_tree(rootdev);
251| 				return NULL;
252| 			}
253| 			if (rootdev->children == NULL)
254| 				rootdev->children = dlist_new_with_delete
255| 					(sizeof(struct sysfs_device),
256| 					sysfs_close_dev_tree);
257| 			dlist_unshift_sorted(rootdev->children, new, sort_list);
258| 		}
259| 	}
260| 
261| 	return rootdev;
262| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-1) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-2) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

', '2025-11-17 21:39:07.091432');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (364, 110, 'def9', 'INTEGER_OVERFLOW', 'sysfsutils-2.1.1/lib/sysfs_attr.c:167: tainted_data_return: Called function "read(fd, fbuf, pgsize)", and a possible return value may be less than zero.
sysfsutils-2.1.1/lib/sysfs_attr.c:167: assign: Assigning: "length" = "read(fd, fbuf, pgsize)".
sysfsutils-2.1.1/lib/sysfs_attr.c:185: overflow: The expression "length + 1L" is considered to have possibly overflowed.
sysfsutils-2.1.1/lib/sysfs_attr.c:185: overflow_sink: "length + 1L", which might have overflowed, is passed to "realloc(fbuf, length + 1L)".
#  183|   	sysattr->len = length;
#  184|   	close(fd);
#  185|-> 	vbuf = (char *)realloc(fbuf, length+1);
#  186|   	if (!vbuf) {
#  187|   		dbg_printf("realloc failed\n");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: sysfsutils-2.1.1/lib/sysfs_attr.c: tainted_data_return: Called function "read(fd, fbuf, pgsize)", and a possible return value may be less than zero.
sysfsutils-2.1.1/lib/sysfs_attr.c: assign: Assigning: "length" = "read(fd, fbuf, pgsize)".
sysfsutils-2.1.1/lib/sysfs_attr.c: overflow: The expression "length + 1L" is considered to have possibly overflowed.
sysfsutils-2.1.1/lib/sysfs_attr.c: overflow_sink: "length + 1L", which might have overflowed, is passed to "realloc(fbuf, length + 1L)".
#    sysattr->len = length;
#    close(fd);
#->  vbuf = (char *)realloc(fbuf, length+1);
#    if (!vbuf) {
#    dbg_printf("realloc failed
");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
sysfsutils-2.1.1/lib/sysfs_attr.c:167: tainted_data_return: Called function "read(fd, fbuf, pgsize)", and a possible return value may be less than zero.
sysfsutils-2.1.1/lib/sysfs_attr.c:167: assign: Assigning: "length" = "read(fd, fbuf, pgsize)".
sysfsutils-2.1.1/lib/sysfs_attr.c:185: overflow: The expression "length + 1L" is considered to have possibly overflowed.
sysfsutils-2.1.1/lib/sysfs_attr.c:185: overflow_sink: "length + 1L", which might have overflowed, is passed to "realloc(fbuf, length + 1L)".
#  183|   	sysattr->len = length;
#  184|   	close(fd);
#  185|-> 	vbuf = (char *)realloc(fbuf, length+1);
#  186|   	if (!vbuf) {
#  187|   		dbg_printf("realloc failed
");
(Example-1) Reason Marked as False Positive:
Line 168 ensures that "length" can''t be less than zero on line 185.

', '2025-11-17 21:39:07.091432');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (365, 110, 'def10', 'RESOURCE_LEAK', 'sysfsutils-2.1.1/lib/sysfs_attr.c:398: alloc_fn: Storage is returned from allocation function "opendir".
sysfsutils-2.1.1/lib/sysfs_attr.c:398: var_assign: Assigning: "dir" = storage returned from "opendir(path)".
sysfsutils-2.1.1/lib/sysfs_attr.c:403: noescape: Resource "dir" is not freed or pointed-to in "readdir".
sysfsutils-2.1.1/lib/sysfs_attr.c:418: leaked_storage: Variable "dir" going out of scope leaks the storage it points to.
#  416|   				if (!linklist) {
#  417|   					dbg_printf("Error creating list\n");
#  418|-> 					return NULL;
#  419|   				}
#  420|   			}', 'TRUE POSITIVE', 'Resource leak confirmed: `dir` (allocated by `opendir()` at line 398) is not freed in the error path where `linklist` is NULL (line 418), as `closedir(dir)` (line 426) is bypassed upon immediate return.', 'The CVE report indicates a potential resource leak due to the allocation of storage via `opendir()` (line 398) not being freed in all execution paths.

The `dir` variable, assigned the storage from `opendir()`, is indeed not freed or pointed-to within the `readdir()` loop (line 403), as reported.

Critically, at line 418, if `linklist` is NULL, the function returns NULL immediately, without freeing the `dir` resource, which was opened at line 398. This creates a leak.

The presence of `closedir(dir)` at line 426 is not executed in the specific error path leading to line 418, as the function returns before reaching this point, thus not mitigating the leak in this scenario.

Unlike the provided FALSE POSITIVE examples (Example-1 and Example-2), where the alleged leaks were proven to be non-issues due to context (e.g., NULL checks ensuring no prior memory to leak), this case lacks such mitigating context for the specific error path leading to line 418.

Given the direct correlation between the code''s behavior and the described vulnerability, and the absence of definitive proof that all execution paths safely handle the resource, the finding cannot be conclusively marked as a FALSE POSITIVE.', 'Conduct a thorough code review to identify any potential implicit or explicit resource cleanup mechanisms that might mitigate the leak in the error path leading to line 418.

Assess the exploitability of the resource leak in the context of the sysfsutils'' typical deployment environments and usage scenarios.

Evaluate the feasibility of a proof-of-concept exploit to conclusively determine the severity of the vulnerability.', 0.0000, '*** Source Code Context ***

code of lib/sysfs_attr.c file:
387| struct dlist *read_dir_links(const char *path)
388| {
389| 	DIR *dir = NULL;
390| 	struct dirent *dirent = NULL;
391| 	char file_path[SYSFS_PATH_MAX], *linkname;
392| 	struct dlist *linklist = NULL;
393| 
394| 	if (!path) {
395| 		errno = EINVAL;
396| 		return NULL;
397| 	}
398| 	dir = opendir(path);
399| 	if (!dir) {
400| 		dbg_printf("Error opening directory %s
", path);
401| 		return NULL;
402| 	}
403| 	while ((dirent = readdir(dir)) != NULL) {
404| 		if (0 == strcmp(dirent->d_name, "."))
405| 			 continue;
406| 		if (0 == strcmp(dirent->d_name, ".."))
407| 			continue;
408| 		memset(file_path, 0, SYSFS_PATH_MAX);
409| 		safestrcpy(file_path, path);
410| 		safestrcat(file_path, "/");
411| 		safestrcat(file_path, dirent->d_name);
412| 		if (!sysfs_path_is_link(file_path)) {
413| 			if (!linklist) {
414| 				linklist = dlist_new_with_delete
415| 					(SYSFS_NAME_LEN, sysfs_del_name);
416| 				if (!linklist) {
417| 					dbg_printf("Error creating list
");
418| 					return NULL;
419| 				}
420| 			}
421| 			linkname = (char *)calloc(1, SYSFS_NAME_LEN);
422| 			safestrcpymax(linkname, dirent->d_name, SYSFS_NAME_LEN);
423| 			dlist_unshift_sorted(linklist, linkname, sort_char);
424| 		}
425| 	}
426| 	closedir(dir);
427| 	return linklist;
428| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/lib/sysfs_attr.c:310: alloc_fn: Storage is returned from allocation function "dlist_new_with_delete".
sysfsutils-2.1.1/lib/sysfs_attr.c:310: var_assign: Assigning: "alist" = storage returned from "dlist_new_with_delete(336UL, sysfs_del_attribute)".
sysfsutils-2.1.1/lib/sysfs_attr.c:313: noescape: Resource "alist" is not freed or pointed-to in "dlist_unshift_sorted".
sysfsutils-2.1.1/lib/sysfs_attr.c:314: leaked_storage: Returning without freeing "alist" leaks the storage that it points to.
#  312|   	}
#  313|   	dlist_unshift_sorted(alist, attr, sort_list);
#  314|-> 	return attr;
#  315|   }
#  316|
(Example-1) Reason Marked as False Positive:
chwhite(def3):  occurs from a NULL check in add_attribute_to_list. Line 309 checks to see if alist is NULL, and if it is a new alist is created. The issue is that the covscan sees
the creation of a new alist and thinks that it is leaking the memory of the old alist even though the original alist is NULL and has no memory to leak. This is a false postive.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
sysfsutils-2.1.1/cmd/systool.c:562: alloc_fn: Storage is returned from allocation function "sysfs_get_module_sections".
sysfsutils-2.1.1/cmd/systool.c:562: var_assign: Assigning: "attributes" = storage returned from "sysfs_get_module_sections(mod)".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "dlist_start".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:570: noescape: Resource "attributes" is not freed or pointed-to in "_dlist_mark_move".
sysfsutils-2.1.1/cmd/systool.c:576: leaked_storage: Variable "attributes" going out of scope leaks the storage it points to.
#  574|   			fprintf(stdout, "
");
#  575|   		}
#  576|-> 	}
#  577|
#  578|   	sysfs_close_module(mod);
(Example-2) Reason Marked as False Positive:
chwhite(def2): sysfs_get_module_sections() makes a call to get_attributes_list()=>add_attribute_to_list(). In def3, we see that add_attribute_to_list() has a null check where
if alist is null, a new list is created. This causes covscan to think that alist has been leaked. As a result, covscan throws false positives for variables initialized by
either sysfs_get_module_parms() or sysfs_get_module_sections().

', '2025-11-17 21:39:07.091433');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (366, 103, 'def1', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2193: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2191|   
# 2192|   	printf("success: magic_free_protection\n");
# 2193|-> 	return true;
# 2194|   }
# 2195|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2193: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2191|   
# 2192|    printf("success: magic_free_protection\n");
# 2193|->  return true;
# 2194|   }
# 2195|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2193: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2191|   
# 2192|   	printf("success: magic_free_protection
");
# 2193|-> 	return true;
# 2194|   }
# 2195|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2172: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2170|   
# 2171|   		/* Never reached. Make compilers happy */
# 2172|-> 		return true;
# 2173|   	}
# 2174|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099315');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (367, 103, 'def2', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2179: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2177|   	if (!WIFEXITED(exit_status)) {
# 2178|   		printf("Child exited through unexpected abnormal means\n");
# 2179|-> 		return false;
# 2180|   	}
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2179: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2177|    if (!WIFEXITED(exit_status)) {
# 2178|       printf("Child exited through unexpected abnormal means\n");
# 2179|->   return false;
# 2180|    }
# 2181|    if (WEXITSTATUS(exit_status) != 42) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2179: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2177|   	if (!WIFEXITED(exit_status)) {
# 2178|   		printf("Child exited through unexpected abnormal means
");
# 2179|-> 		return false;
# 2180|   	}
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2183: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {
# 2182|   		printf("Child exited with wrong exit status
");
# 2183|-> 		return false;
# 2184|   	}
# 2185|   	if (WIFSIGNALED(exit_status)) {
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099316');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (397, 108, 'def3', 'RESOURCE_LEAK', 'rpcbind-1.2.6/src/rpcinfo.c:947: alloc_fn: Storage is returned from allocation function "malloc".
rpcbind-1.2.6/src/rpcinfo.c:947: var_assign: Assigning: "rs" = storage returned from "malloc(40UL)".
rpcbind-1.2.6/src/rpcinfo.c:954: var_assign: Assigning: "rs_head" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:955: var_assign: Assigning: "rs_tail" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:969: noescape: Resource "rs" is not freed or pointed-to in "add_netid".
rpcbind-1.2.6/src/rpcinfo.c:942: var_assign: Assigning: "rs" = "rs_head".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_head" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_tail" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs" going out of scope leaks the storage it points to.
# 1015|     return;
# 1016|   error:fprintf (stderr, "rpcinfo: no memory\n");
# 1017|->   return;
# 1018|   }
# 1019|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: rpcbind-1.2.6/src/rpcinfo.c:947: alloc_fn: Storage is returned from allocation function "malloc".
rpcbind-1.2.6/src/rpcinfo.c:947: var_assign: Assigning: "rs" = storage returned from "malloc(40UL)".
rpcbind-1.2.6/src/rpcinfo.c:954: var_assign: Assigning: "rs_head" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:955: var_assign: Assigning: "rs_tail" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:969: noescape: Resource "rs" is not freed or pointed-to in "add_netid".
rpcbind-1.2.6/src/rpcinfo.c:942: var_assign: Assigning: "rs" = "rs_head".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_head" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_tail" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs" going out of scope leaks the storage it points to.
# 1015|     return;
# 1016|   error:fprintf (stderr, "rpcinfo: no memory\n");
# 1017|->   return;
# 1018|   }
# 1019|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
rpcbind-1.2.6/src/rpcinfo.c:947: alloc_fn: Storage is returned from allocation function "malloc".
rpcbind-1.2.6/src/rpcinfo.c:947: var_assign: Assigning: "rs" = storage returned from "malloc(40UL)".
rpcbind-1.2.6/src/rpcinfo.c:954: var_assign: Assigning: "rs_head" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:955: var_assign: Assigning: "rs_tail" = "rs".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:969: noescape: Resource "rs" is not freed or pointed-to in "add_netid".
rpcbind-1.2.6/src/rpcinfo.c:942: var_assign: Assigning: "rs" = "rs_head".
rpcbind-1.2.6/src/rpcinfo.c:967: noescape: Resource "rs" is not freed or pointed-to in "add_version".
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_head" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs_tail" going out of scope leaks the storage it points to.
rpcbind-1.2.6/src/rpcinfo.c:1017: leaked_storage: Variable "rs" going out of scope leaks the storage it points to.
# 1015|     return;
# 1016|   error:fprintf (stderr, "rpcinfo: no memory
");
# 1017|->   return;
# 1018|   }
# 1019|
(Example-1) Reason Marked as False Positive:
rpcinfo is a command so the memory is freed when it exits.

', '2025-11-17 21:39:07.107499');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (368, 103, 'def3', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1425: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1425: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 128UL, "../../testsuite.c:1425")".
talloc-2.4.2/testsuite.c:1426: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1424|   	/* now we should reclaim the full pool */
# 1425|   	p2_2 = talloc_realloc_size(root, p2, 8 * 16);
# 1426|-> 	torture_assert("pool realloc 8 * 16", p2_2 == p1, "failed: pointer not expected");
# 1427|   	p2 = p2_2;
# 1428|   	memset(p2_2, 0x11, talloc_get_size(p2_2));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1425: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1425: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 128UL, "../../testsuite.c:1425")".
talloc-2.4.2/testsuite.c:1426: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1424|    /* now we should reclaim the full pool */
# 1425|    p2_2 = talloc_realloc_size(root, p2, 8 * 16);
# 1426|->  torture_assert("pool realloc 8 * 16", p2_2 == p1, "failed: pointer not expected");
# 1427|    p2 = p2_2;
# 1428|    memset(p2_2, 0x11, talloc_get_size(p2_2));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1425: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1425: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 128UL, "../../testsuite.c:1425")".
talloc-2.4.2/testsuite.c:1426: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1424|   	/* now we should reclaim the full pool */
# 1425|   	p2_2 = talloc_realloc_size(root, p2, 8 * 16);
# 1426|-> 	torture_assert("pool realloc 8 * 16", p2_2 == p1, "failed: pointer not expected");
# 1427|   	p2 = p2_2;
# 1428|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1416: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1416: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 48UL, "../../testsuite.c:1416")".
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099317');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (369, 103, 'def4', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1409: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1407|   
# 1408|   	p1_2 = talloc_realloc_size(root, p1, 5 * 16);
# 1409|-> 	torture_assert("pool realloc 5 * 16", p1_2 > p2, "failed: pointer not changed");
# 1410|   	memset(p1_2, 0x11, talloc_get_size(p1_2));
# 1411|   	ofs1 = PTR_DIFF(p1_2, p2);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1409: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1407|   
# 1408|    p1_2 = talloc_realloc_size(root, p1, 5 * 16);
# 1409|->  torture_assert("pool realloc 5 * 16", p1_2 > p2, "failed: pointer not changed");
# 1410|    memset(p1_2, 0x11, talloc_get_size(p1_2));
# 1411|    ofs1 = PTR_DIFF(p1_2, p2);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1409: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1407|   
# 1408|   	p1_2 = talloc_realloc_size(root, p1, 5 * 16);
# 1409|-> 	torture_assert("pool realloc 5 * 16", p1_2 > p2, "failed: pointer not changed");
# 1410|   	memset(p1_2, 0x11, talloc_get_size(p1_2));
# 1411|   	ofs1 = PTR_DIFF(p1_2, p2);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1310: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1310: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 21UL, "../../testsuite.c:1310")".
talloc-2.4.2/testsuite.c:1311: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1309|   
# 1310|   	p2_2 = talloc_realloc_size(pool, p2, 20+1);
# 1311|-> 	torture_assert("pool realloc 20+1", p2_2 == p2, "failed: pointer changed");
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099317');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (370, 103, 'def5', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2183: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {
# 2182|   		printf("Child exited with wrong exit status\n");
# 2183|-> 		return false;
# 2184|   	}
# 2185|   	if (WIFSIGNALED(exit_status)) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2183: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2181|    if (WEXITSTATUS(exit_status) != 42) {
# 2182|       printf("Child exited with wrong exit status\n");
# 2183|->     return false;
# 2184|    }
# 2185|    if (WIFSIGNALED(exit_status)) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2183: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {
# 2182|   		printf("Child exited with wrong exit status
");
# 2183|-> 		return false;
# 2184|   	}
# 2185|   	if (WIFSIGNALED(exit_status)) {
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2179: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2177|   	if (!WIFEXITED(exit_status)) {
# 2178|   		printf("Child exited through unexpected abnormal means
");
# 2179|-> 		return false;
# 2180|   	}
# 2181|   	if (WEXITSTATUS(exit_status) != 42) {
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099317');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (371, 103, 'def6', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1826: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1826: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1826")".
talloc-2.4.2/testsuite.c:1827: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1825|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10\n");
# 1826|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1827|-> 	torture_assert("memlimit", l2 == NULL,
# 1828|   			"failed: realloc should fail due to memory limit\n");
# 1829|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1826: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1826: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1826")".
talloc-2.4.2/testsuite.c:1827: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1825|    printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10\n");
# 1826|    l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1827|->  torture_assert("memlimit", l2 == NULL,
# 1828|            "failed: realloc should fail due to memory limit\n");
# 1829|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1826: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1826: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1826")".
talloc-2.4.2/testsuite.c:1827: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1825|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
# 1826|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1827|-> 	torture_assert("memlimit", l2 == NULL,
# 1828|   			"failed: realloc should fail due to memory limit
");
# 1829|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1853: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1853: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")".
talloc-2.4.2/testsuite.c:1854: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)
");
# 1853|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|-> 	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit
");
# 1856|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099318');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (372, 103, 'def7', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1323: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1323: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 400UL, "../../testsuite.c:1323")".
talloc-2.4.2/testsuite.c:1324: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1322|   	/* this should reclaim the memory of p4 and p3 */
# 1323|   	p2_2 = talloc_realloc_size(pool, p2, 400);
# 1324|-> 	torture_assert("pool realloc 400", p2_2 == p2, "failed: pointer changed");
# 1325|   	memset(p2, 0x11, talloc_get_size(p2));
# 1326|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1323: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1323: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 400UL, "../../testsuite.c:1323")".
talloc-2.4.2/testsuite.c:1324: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1322|    /* this should reclaim the memory of p4 and p3 */
# 1323|    p2_2 = talloc_realloc_size(pool, p2, 400);
# 1324|->  torture_assert("pool realloc 400", p2_2 == p2, "failed: pointer changed");
# 1325|    memset(p2, 0x11, talloc_get_size(p2));
# 1326|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1323: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1323: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 400UL, "../../testsuite.c:1323")".
talloc-2.4.2/testsuite.c:1324: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1322|   	/* this should reclaim the memory of p4 and p3 */
# 1323|   	p2_2 = talloc_realloc_size(pool, p2, 400);
# 1324|-> 	torture_assert("pool realloc 400", p2_2 == p2, "failed: pointer changed");
# 1325|   	memset(p2, 0x11, talloc_get_size(p2));
# 1326|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1330: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1330: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 800UL, "../../testsuite.c:1330")".
talloc-2.4.2/testsuite.c:1331: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1329|   	/* this should reclaim the memory of p1 */
# 1330|   	p2_2 = talloc_realloc_size(pool, p2, 800);
# 1331|-> 	torture_assert("pool realloc 800", p2_2 == p1, "failed: pointer not changed");
# 1332|   	p2 = p2_2;
# 1333|   	memset(p2, 0x11, talloc_get_size(p2));
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099318');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (373, 103, 'def8', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1853: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1853: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")".
talloc-2.4.2/testsuite.c:1854: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)\n");
# 1853|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|-> 	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit\n");
# 1856|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1853: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1853: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")".
talloc-2.4.2/testsuite.c:1854: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1852|    printf("==== talloc_realloc_size(NULL, l1, 10*1024)\n");
# 1853|    l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|->  torture_assert("memlimit", l2 == NULL,
# 1855|            "failed: realloc should fail due to memory limit\n");
# 1856|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1853: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1853: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")".
talloc-2.4.2/testsuite.c:1854: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)
");
# 1853|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|-> 	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit
");
# 1856|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1826: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1826: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1826")".
talloc-2.4.2/testsuite.c:1827: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1825|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
# 1826|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1827|-> 	torture_assert("memlimit", l2 == NULL,
# 1828|   			"failed: realloc should fail due to memory limit
");
# 1829|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099319');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (374, 103, 'def9', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1356: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1356: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1356")".
talloc-2.4.2/testsuite.c:1357: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1355|   
# 1356|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1357|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1356: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1356: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1356")".
talloc-2.4.2/testsuite.c:1357: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1355|   
# 1356|    p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1357|->  torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1358|    memset(p2, 0x11, talloc_get_size(p2));
# 1359|    p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1356: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1356: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1356")".
talloc-2.4.2/testsuite.c:1357: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1355|   
# 1356|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1357|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1310: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1310: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 21UL, "../../testsuite.c:1310")".
talloc-2.4.2/testsuite.c:1311: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1309|   
# 1310|   	p2_2 = talloc_realloc_size(pool, p2, 20+1);
# 1311|-> 	torture_assert("pool realloc 20+1", p2_2 == p2, "failed: pointer changed");
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099319');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (375, 103, 'def10', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1414: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1412|   	ofs2 = talloc_get_size(p2) + hdr;
# 1413|   
# 1414|-> 	torture_assert("pool realloc ", ofs1 == ofs2, "failed: pointer offset unexpected");
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1414: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1412|    ofs2 = talloc_get_size(p2) + hdr;
# 1413|   
# 1414|-> torture_assert("pool realloc ", ofs1 == ofs2, "failed: pointer offset unexpected");
# 1415|   
# 1416|    p2_2 = talloc_realloc_size(root, p2, 3 * 16);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1414: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1412|   	ofs2 = talloc_get_size(p2) + hdr;
# 1413|   
# 1414|-> 	torture_assert("pool realloc ", ofs1 == ofs2, "failed: pointer offset unexpected");
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099319');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (376, 103, 'def11', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1359: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1359: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1359")".
talloc-2.4.2/testsuite.c:1360: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1360|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1361|   	memset(p2, 0x11, talloc_get_size(p2));
# 1362|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1359: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1359: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1359")".
talloc-2.4.2/testsuite.c:1360: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1358|    memset(p2, 0x11, talloc_get_size(p2));
# 1359|    p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1360|->  torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1361|    memset(p2, 0x11, talloc_get_size(p2));
# 1362|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1359: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1359: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1359")".
talloc-2.4.2/testsuite.c:1360: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1360|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1361|   	memset(p2, 0x11, talloc_get_size(p2));
# 1362|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1316: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1316: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1316")".
talloc-2.4.2/testsuite.c:1317: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1315|   	memset(p2, 0x11, talloc_get_size(p2));
# 1316|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1317|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1318|   	memset(p2, 0x11, talloc_get_size(p2));
# 1319|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099319');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (377, 103, 'def12', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1310: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1310: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 21UL, "../../testsuite.c:1310")".
talloc-2.4.2/testsuite.c:1311: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1309|   
# 1310|   	p2_2 = talloc_realloc_size(pool, p2, 20+1);
# 1311|-> 	torture_assert("pool realloc 20+1", p2_2 == p2, "failed: pointer changed");
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1310: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1310: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 21UL, "../../testsuite.c:1310")".
talloc-2.4.2/testsuite.c:1311: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1309|   
# 1310|    p2_2 = talloc_realloc_size(pool, p2, 20+1);
# 1311|->  torture_assert("pool realloc 20+1", p2_2 == p2, "failed: pointer changed");
# 1312|    memset(p2, 0x11, talloc_get_size(p2));
# 1313|    p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1310: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1310: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 21UL, "../../testsuite.c:1310")".
talloc-2.4.2/testsuite.c:1311: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1309|   
# 1310|   	p2_2 = talloc_realloc_size(pool, p2, 20+1);
# 1311|-> 	torture_assert("pool realloc 20+1", p2_2 == p2, "failed: pointer changed");
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1356: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1356: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1356")".
talloc-2.4.2/testsuite.c:1357: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1355|   
# 1356|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1357|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.09932');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (378, 103, 'def13', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1815: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1815: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1815")".
talloc-2.4.2/testsuite.c:1816: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1814|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10\n");
# 1815|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1816|-> 	torture_assert("memlimit", l2 == NULL,
# 1817|   			"failed: realloc should fail due to memory limit\n");
# 1818|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1815: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1815: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1815")".
talloc-2.4.2/testsuite.c:1816: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1814|    printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10\n");
# 1815|    l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1816|->  torture_assert("memlimit", l2 == NULL,
# 1817|            "failed: realloc should fail due to memory limit\n");
# 1818|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1815: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1815: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1815")".
talloc-2.4.2/testsuite.c:1816: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1814|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
# 1815|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1816|-> 	torture_assert("memlimit", l2 == NULL,
# 1817|   			"failed: realloc should fail due to memory limit
");
# 1818|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1826: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1826: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1826")".
talloc-2.4.2/testsuite.c:1827: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1825|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
# 1826|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1827|-> 	torture_assert("memlimit", l2 == NULL,
# 1828|   			"failed: realloc should fail due to memory limit
");
# 1829|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.09932');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (379, 103, 'def14', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1374|   	talloc_free(pool);
# 1375|   
# 1376|-> 	return true;
# 1377|   }
# 1378|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1374|    talloc_free(pool);
# 1375|   
# 1376|->  return true;
# 1377|   }
# 1378|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1376: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1374|   	talloc_free(pool);
# 1375|   
# 1376|-> 	return true;
# 1377|   }
# 1378|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1369|   	/* this should reclaim the memory from the pool */
# 1370|   	p3 = talloc_size(pool, 800);
# 1371|-> 	torture_assert("pool alloc 800", p3 == p1, "failed: pointer changed");
# 1372|   	memset(p3, 0x11, talloc_get_size(p3));
# 1373|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.09932');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (380, 103, 'def15', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1313: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1313: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1313")".
talloc-2.4.2/testsuite.c:1314: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1314|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1315|   	memset(p2, 0x11, talloc_get_size(p2));
# 1316|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1313: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1313: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1313")".
talloc-2.4.2/testsuite.c:1314: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1312|    memset(p2, 0x11, talloc_get_size(p2));
# 1313|    p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1314|->  torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1315|    memset(p2, 0x11, talloc_get_size(p2));
# 1316|    p2_2 = talloc_realloc_size(pool, p2, 20-1);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1313: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1313: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1313")".
talloc-2.4.2/testsuite.c:1314: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1312|   	memset(p2, 0x11, talloc_get_size(p2));
# 1313|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1314|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1315|   	memset(p2, 0x11, talloc_get_size(p2));
# 1316|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1359: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1359: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1359")".
talloc-2.4.2/testsuite.c:1360: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1360|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1361|   	memset(p2, 0x11, talloc_get_size(p2));
# 1362|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099321');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (381, 103, 'def16', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1019: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1019: var_assign: Assigning: "a" = storage returned from "_talloc_realloc_array(parent, a, 1UL, 2048U, "char")".
talloc-2.4.2/testsuite.c:1032: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
# 1030|   	talloc_free(parent);
# 1031|   
# 1032|-> 	torture_assert("check destructor realloc_parent_destructor",
# 1033|   		       realloc_parent_destructor_count == 2,
# 1034|   		       "FAILED TO FIRE free_for_exit_destructor\n");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1019: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1019: var_assign: Assigning: "a" = storage returned from "_talloc_realloc_array(parent, a, 1UL, 2048U, "char")".
talloc-2.4.2/testsuite.c:1032: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
# 1030|    talloc_free(parent);
# 1031|   
# 1032|-> torture_assert("check destructor realloc_parent_destructor",
# 1033|               realloc_parent_destructor_count == 2,
# 1034|               "FAILED TO FIRE free_for_exit_destructor\n");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1019: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1019: var_assign: Assigning: "a" = storage returned from "_talloc_realloc_array(parent, a, 1UL, 2048U, "char")".
talloc-2.4.2/testsuite.c:1032: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
# 1030|   	talloc_free(parent);
# 1031|   
# 1032|-> 	torture_assert("check destructor realloc_parent_destructor",
# 1033|   		       realloc_parent_destructor_count == 2,
# 1034|   		       "FAILED TO FIRE free_for_exit_destructor
");
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1714: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1714: var_assign: Assigning: "t" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 600U, "char")".
talloc-2.4.2/testsuite.c:1715: leaked_storage: Variable "t" going out of scope leaks the storage it points to.
# 1713|   	printf("==== talloc_realloc(NULL, l5, char, 600)
");
# 1714|   	t = talloc_realloc(NULL, l5, char, 600);
# 1715|-> 	torture_assert("memlimit", t == NULL,
# 1716|   		"failed: alloc should fail due to memory limit
");
# 1717|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099321');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (382, 103, 'def17', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:580: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:580: leaked_storage: Failing to save or free storage allocated by "_talloc_realloc(NULL, p2, 5UL, "../../testsuite.c:580")" leaks it.
#  578|   
#  579|   	talloc_increase_ref_count(p2);
#  580|-> 	torture_assert("realloc", talloc_realloc_size(NULL, p2, 5) == NULL,
#  581|   		"failed: talloc_realloc() on a referenced pointer should fail\n");
#  582|   	CHECK_BLOCKS("realloc", p1, 4);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:580: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:580: leaked_storage: Failing to save or free storage allocated by "_talloc_realloc(NULL, p2, 5UL, "../../testsuite.c:580")" leaks it.
#  578|   
#  579|    talloc_increase_ref_count(p2);
#  580|->  torture_assert("realloc", talloc_realloc_size(NULL, p2, 5) == NULL,
#  581|    "failed: talloc_realloc() on a referenced pointer should fail\n");
#  582|    CHECK_BLOCKS("realloc", p1, 4);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:580: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:580: leaked_storage: Failing to save or free storage allocated by "_talloc_realloc(NULL, p2, 5UL, "../../testsuite.c:580")" leaks it.
#  578|   
#  579|   	talloc_increase_ref_count(p2);
#  580|-> 	torture_assert("realloc", talloc_realloc_size(NULL, p2, 5) == NULL,
#  581|   		"failed: talloc_realloc() on a referenced pointer should fail
");
#  582|   	CHECK_BLOCKS("realloc", p1, 4);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1416: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1416: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 48UL, "../../testsuite.c:1416")".
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099321');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (383, 103, 'def18', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|    p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|->  torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|    memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1408: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1408: var_assign: Assigning: "p1_2" = storage returned from "_talloc_realloc(root, p1, 80UL, "../../testsuite.c:1408")".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1410: noescape: Resource "p1_2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1414: leaked_storage: Variable "p1_2" going out of scope leaks the storage it points to.
# 1412|   	ofs2 = talloc_get_size(p2) + hdr;
# 1413|   
# 1414|-> 	torture_assert("pool realloc ", ofs1 == ofs2, "failed: pointer offset unexpected");
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099322');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (384, 103, 'def19', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:810: alloc_fn: Storage is returned from allocation function "talloc_realloc_fn".
talloc-2.4.2/testsuite.c:810: var_assign: Assigning: "p1" = storage returned from "talloc_realloc_fn(root, p1, 20UL)".
talloc-2.4.2/testsuite.c:811: leaked_storage: Variable "p1" going out of scope leaks the storage it points to.
#  809|   	CHECK_SIZE("realloc_fn", root, 10);
#  810|   	p1 = talloc_realloc_fn(root, p1, 20);
#  811|-> 	CHECK_BLOCKS("realloc_fn", root, 2);
#  812|   	CHECK_SIZE("realloc_fn", root, 20);
#  813|   	p1 = talloc_realloc_fn(root, p1, 0);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:810: alloc_fn: Storage is returned from allocation function "talloc_realloc_fn".
talloc-2.4.2/testsuite.c:810: var_assign: Assigning: "p1" = storage returned from "talloc_realloc_fn(root, p1, 20UL)".
talloc-2.4.2/testsuite.c:811: leaked_storage: Variable "p1" going out of scope leaks the storage it points to.
#  809|    CHECK_SIZE("realloc_fn", root, 10);
#  810|    p1 = talloc_realloc_fn(root, p1, 20);
#  811|->  CHECK_BLOCKS("realloc_fn", root, 2);
#  812|    CHECK_SIZE("realloc_fn", root, 20);
#  813|    p1 = talloc_realloc_fn(root, p1, 0);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:810: alloc_fn: Storage is returned from allocation function "talloc_realloc_fn".
talloc-2.4.2/testsuite.c:810: var_assign: Assigning: "p1" = storage returned from "talloc_realloc_fn(root, p1, 20UL)".
talloc-2.4.2/testsuite.c:811: leaked_storage: Variable "p1" going out of scope leaks the storage it points to.
#  809|   	CHECK_SIZE("realloc_fn", root, 10);
#  810|   	p1 = talloc_realloc_fn(root, p1, 20);
#  811|-> 	CHECK_BLOCKS("realloc_fn", root, 2);
#  812|   	CHECK_SIZE("realloc_fn", root, 20);
#  813|   	p1 = talloc_realloc_fn(root, p1, 0);
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2172: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2170|   
# 2171|   		/* Never reached. Make compilers happy */
# 2172|-> 		return true;
# 2173|   	}
# 2174|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099322');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (385, 103, 'def20', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1336: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1336: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1336")".
talloc-2.4.2/testsuite.c:1338: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1341|   	/* this should reclaim the memory from the pool */
# 1342|   	p3 = talloc_size(pool, 80);
# 1343|-> 	torture_assert("pool alloc 80", p3 == p1, "failed: pointer changed");
# 1344|   	memset(p3, 0x11, talloc_get_size(p3));
# 1345|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1336: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1336: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1336")".
talloc-2.4.2/testsuite.c:1338: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1341|    /* this should reclaim the memory from the pool */
# 1342|    p3 = talloc_size(pool, 80);
# 1343|->  torture_assert("pool alloc 80", p3 == p1, "failed: pointer changed");
# 1344|    memset(p3, 0x11, talloc_get_size(p3));
# 1345|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1336: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1336: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1336")".
talloc-2.4.2/testsuite.c:1338: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1341|   	/* this should reclaim the memory from the pool */
# 1342|   	p3 = talloc_size(pool, 80);
# 1343|-> 	torture_assert("pool alloc 80", p3 == p1, "failed: pointer changed");
# 1344|   	memset(p3, 0x11, talloc_get_size(p3));
# 1345|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1369|   	/* this should reclaim the memory from the pool */
# 1370|   	p3 = talloc_size(pool, 800);
# 1371|-> 	torture_assert("pool alloc 800", p3 == p1, "failed: pointer changed");
# 1372|   	memset(p3, 0x11, talloc_get_size(p3));
# 1373|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099322');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (386, 103, 'def21', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1721: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1721: var_assign: Assigning: "l5" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 5U, "char")".
talloc-2.4.2/testsuite.c:1741: overwrite_var: Overwriting "l5" in "l5 = talloc_strdup(l4, "level 5")" leaks the storage that "l5" points to.
# 1739|   
# 1740|   	printf("==== talloc_strdup(l4, level 5)\n");
# 1741|-> 	l5 = talloc_strdup(l4, "level 5");
# 1742|   	torture_assert("memlimit", l5 != NULL,
# 1743|   		"failed: alloc should not fail due to memory limit\n");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1721: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1721: var_assign: Assigning: "l5" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 5U, "char")".
talloc-2.4.2/testsuite.c:1741: overwrite_var: Overwriting "l5" in "l5 = talloc_strdup(l4, "level 5")" leaks the storage that "l5" points to.
# 1739|   
# 1740|    printf("==== talloc_strdup(l4, level 5)\n");
# 1741|->  l5 = talloc_strdup(l4, "level 5");
# 1742|    torture_assert("memlimit", l5 != NULL,
# 1743|        "failed: alloc should not fail due to memory limit\n");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1721: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1721: var_assign: Assigning: "l5" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 5U, "char")".
talloc-2.4.2/testsuite.c:1741: overwrite_var: Overwriting "l5" in "l5 = talloc_strdup(l4, "level 5")" leaks the storage that "l5" points to.
# 1739|   
# 1740|   	printf("==== talloc_strdup(l4, level 5)
");
# 1741|-> 	l5 = talloc_strdup(l4, "level 5");
# 1742|   	torture_assert("memlimit", l5 != NULL,
# 1743|   		"failed: alloc should not fail due to memory limit
");
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1714: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1714: var_assign: Assigning: "t" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 600U, "char")".
talloc-2.4.2/testsuite.c:1715: leaked_storage: Variable "t" going out of scope leaks the storage it points to.
# 1713|   	printf("==== talloc_realloc(NULL, l5, char, 600)
");
# 1714|   	t = talloc_realloc(NULL, l5, char, 600);
# 1715|-> 	torture_assert("memlimit", t == NULL,
# 1716|   		"failed: alloc should fail due to memory limit
");
# 1717|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099323');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (387, 103, 'def22', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1714: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1714: var_assign: Assigning: "t" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 600U, "char")".
talloc-2.4.2/testsuite.c:1715: leaked_storage: Variable "t" going out of scope leaks the storage it points to.
# 1713|   	printf("==== talloc_realloc(NULL, l5, char, 600)\n");
# 1714|   	t = talloc_realloc(NULL, l5, char, 600);
# 1715|-> 	torture_assert("memlimit", t == NULL,
# 1716|   		"failed: alloc should fail due to memory limit\n");
# 1717|', 'FALSE POSITIVE', 'Assignment to ''t'' is within a testsuite, explicitly expecting allocation failure due to memory limits (line 1715), and does not indicate a genuine memory leak scenario, aligning with known false positive patterns in test contexts without talloc modeling.', 'The reported issue is within a **testsuite** (talloc-2.4.2/testsuite.c), which, based on provided examples (Example-1 and Example-2), is a known context where the tool may not accurately understand the memory management library (talloc) without additional modeling.

The specific line of code (1714) is part of a test case that **explicitly expects the allocation to fail due to a memory limit** (as indicated by the `torture_assert` statement on line 1715, checking if `t == NULL` with a message implying an expected failure due to memory limits).

The variable `t` is indeed assigned the result of `_talloc_realloc_array` (line 1714), but the subsequent assertion (line 1715) **does not indicate a leak in the context of the test''s purpose**. Instead, it verifies the expected behavior of the memory management system under memory constraints.

There is no evidence within the provided code snippet that the storage pointed to by `t` (if the allocation were to succeed, which is not the case here as per the assertion) would leak. The test''s structure suggests that the outcome (success or failure of allocation) is being validated, not the memory leak scenario in a conventional, non-test context.

Given the test context and the explicit assertion of expected allocation failure, the reported ''leaked_storage'' issue does not align with the apparent intent of the test code, leading to the conclusion that this is a **FALSE POSITIVE** in the context of identifying a genuine memory leak vulnerability.', NULL, 0.0000, '*** Source Code Context ***

code of testsuite.c file:
1594| static bool test_memlimit(void)
1595| {
1596| 	void *root;
1597| 	char *l1, *l2, *l3, *l4, *l5, *t;
1598| 	char *pool;
1599| 	int i;
1600| 
1601| 	printf("test: memlimit
# MEMORY LIMITS
");
1602| 
1603| 	printf("==== talloc_new(NULL)
");
1604| 	root = talloc_new(NULL);
1605| 
1606| 	talloc_report_full(root, stdout);
1607| 
1608| 	printf("==== talloc_size(root, 2048)
");
1609| 	l1 = talloc_size(root, 2048);
1610| 	torture_assert("memlimit", l1 != NULL,
1611| 		"failed: alloc should not fail due to memory limit
");
1612| 
1613| 	talloc_report_full(root, stdout);
1614| 
1615| 	printf("==== talloc_free(l1)
");
1616| 	talloc_free(l1);
1617| 
1618| 	talloc_report_full(root, stdout);
1619| 
1620| 	printf("==== talloc_strdup(root, level 1)
");
1621| 	l1 = talloc_strdup(root, "level 1");
1622| 	torture_assert("memlimit", l1 != NULL,
1623| 		"failed: alloc should not fail due to memory limit
");
1624| 
1625| 	talloc_report_full(root, stdout);
1626| 
1627| 	printf("==== talloc_set_memlimit(l1, 2048)
");
1628| 	torture_assert("memlimit", talloc_set_memlimit(l1, 2048) == 0,
1629| 		"failed: setting memlimit should never fail
");
1630| 
1631| 	talloc_report_full(root, stdout);
1632| 
1633| 	printf("==== talloc_size(root, 2048)
");
1634| 	l2 = talloc_size(l1, 2048);
1635| 	torture_assert("memlimit", l2 == NULL,
1636| 		"failed: alloc should fail due to memory limit
");
1637| 
1638| 	talloc_report_full(root, stdout);
1639| 
1640| 	printf("==== talloc_strdup(l1, level 2)
");
1641| 	l2 = talloc_strdup(l1, "level 2");
1642| 	torture_assert("memlimit", l2 != NULL,
1643| 		"failed: alloc should not fail due to memory limit
");
1644| 
1645| 	talloc_report_full(root, stdout);
1646| 
1647| 	printf("==== talloc_free(l2)
");
1648| 	talloc_free(l2);
1649| 
1650| 	talloc_report_full(root, stdout);
1651| 
1652| 	printf("==== talloc_size(NULL, 2048)
");
1653| 	l2 = talloc_size(NULL, 2048);
1654| 
1655| 	talloc_report_full(root, stdout);
1656| 
1657| 	printf("==== talloc_steal(l1, l2)
");
1658| 	talloc_steal(l1, l2);
1659| 
1660| 	talloc_report_full(root, stdout);
1661| 
1662| 	printf("==== talloc_strdup(l2, level 3)
");
1663| 	l3 = talloc_strdup(l2, "level 3");
1664| 	torture_assert("memlimit", l3 == NULL,
1665| 		"failed: alloc should fail due to memory limit
");
1666| 
1667| 	talloc_report_full(root, stdout);
1668| 
1669| 	printf("==== talloc_free(l2)
");
1670| 	talloc_free(l2);
1671| 
1672| 	talloc_report_full(root, stdout);
1673| 
1674| 	printf("==== talloc_strdup(NULL, level 2)
");
1675| 	l2 = talloc_strdup(NULL, "level 2");
1676| 	talloc_steal(l1, l2);
1677| 
1678| 	talloc_report_full(root, stdout);
1679| 
1680| 	printf("==== talloc_strdup(l2, level 3)
");
1681| 	l3 = talloc_strdup(l2, "level 3");
1682| 	torture_assert("memlimit", l3 != NULL,
1683| 		"failed: alloc should not fail due to memory limit
");
1684| 
1685| 	talloc_report_full(root, stdout);
1686| 
1687| 	printf("==== talloc_set_memlimit(l3, 1024)
");
1688| 	torture_assert("memlimit", talloc_set_memlimit(l3, 1024) == 0,
1689| 		"failed: setting memlimit should never fail
");
1690| 
1691| 	talloc_report_full(root, stdout);
1692| 
1693| 	printf("==== talloc_strdup(l3, level 4)
");
1694| 	l4 = talloc_strdup(l3, "level 4");
1695| 	torture_assert("memlimit", l4 != NULL,
1696| 		"failed: alloc should not fail due to memory limit
");
1697| 
1698| 	talloc_report_full(root, stdout);
1699| 
1700| 	printf("==== talloc_set_memlimit(l4, 512)
");
1701| 	torture_assert("memlimit", talloc_set_memlimit(l4, 512) == 0,
1702| 		"failed: setting memlimit should never fail
");
1703| 
1704| 	talloc_report_full(root, stdout);
1705| 
1706| 	printf("==== talloc_strdup(l4, level 5)
");
1707| 	l5 = talloc_strdup(l4, "level 5");
1708| 	torture_assert("memlimit", l5 != NULL,
1709| 		"failed: alloc should not fail due to memory limit
");
1710| 
1711| 	talloc_report_full(root, stdout);
1712| 
1713| 	printf("==== talloc_realloc(NULL, l5, char, 600)
");
1714| 	t = talloc_realloc(NULL, l5, char, 600);
1715| 	torture_assert("memlimit", t == NULL,
1716| 		"failed: alloc should fail due to memory limit
");
1717| 
1718| 	talloc_report_full(root, stdout);
1719| 
1720| 	printf("==== talloc_realloc(NULL, l5, char, 5)
");
1721| 	l5 = talloc_realloc(NULL, l5, char, 5);
1722| 	torture_assert("memlimit", l5 != NULL,
1723| 		"failed: alloc should not fail due to memory limit
");
1724| 
1725| 	talloc_report_full(root, stdout);
1726| 
1727| 	printf("==== talloc_strdup(l3, level 4)
");
1728| 	l4 = talloc_strdup(l3, "level 4");
1729| 	torture_assert("memlimit", l4 != NULL,
1730| 		"failed: alloc should not fail due to memory limit
");
1731| 
1732| 	talloc_report_full(root, stdout);
1733| 
1734| 	printf("==== talloc_set_memlimit(l4, 512)
");
1735| 	torture_assert("memlimit", talloc_set_memlimit(l4, 512) == 0,
1736| 		"failed: setting memlimit should never fail
");
1737| 
1738| 	talloc_report_full(root, stdout);
1739| 
1740| 	printf("==== talloc_strdup(l4, level 5)
");
1741| 	l5 = talloc_strdup(l4, "level 5");
1742| 	torture_assert("memlimit", l5 != NULL,
1743| 		"failed: alloc should not fail due to memory limit
");
1744| 
1745| 	talloc_report_full(root, stdout);
1746| 
1747| 	printf("==== Make new temp context and steal l5
");
1748| 	t = talloc_new(root);
1749| 	talloc_steal(t, l5);
1750| 
1751| 	talloc_report_full(root, stdout);
1752| 
1753| 	printf("==== talloc_size(t, 2048)
");
1754| 	l1 = talloc_size(t, 2048);
1755| 	torture_assert("memlimit", l1 != NULL,
1756| 		"failed: alloc should not fail due to memory limit
");
1757| 
1758| 	talloc_report_full(root, stdout);
1759| 	talloc_free(root);
1760| 
1761| 	/* Test memlimits with pools. */
1762| 	printf("==== talloc_pool(NULL, 10*1024)
");
1763| 	pool = talloc_pool(NULL, 10*1024);
1764| 	torture_assert("memlimit", pool != NULL,
1765| 		"failed: alloc should not fail due to memory limit
");
1766| 
1767| 	printf("==== talloc_set_memlimit(pool, 10*1024)
");
1768| 	talloc_set_memlimit(pool, 10*1024);
1769| 	for (i = 0; i < 9; i++) {
1770| 		printf("==== talloc_size(pool, 1024) %i/10
", i + 1);
1771| 		l1 = talloc_size(pool, 1024);
1772| 		torture_assert("memlimit", l1 != NULL,
1773| 			"failed: alloc should not fail due to memory limit
");
1774| 		talloc_report_full(pool, stdout);
1775| 	}
1776| 	/* The next alloc should fail. */
1777| 	printf("==== talloc_size(pool, 1024) 10/10
");
1778| 	l2 = talloc_size(pool, 1024);
1779| 	torture_assert("memlimit", l2 == NULL,
1780| 			"failed: alloc should fail due to memory limit
");
1781| 
1782| 	talloc_report_full(pool, stdout);
1783| 
1784| 	/* Moving one of the children shouldn''t change the limit,
1785| 	   as it''s still inside the pool. */
1786| 
1787| 	printf("==== talloc_new(NULL)
");
1788| 	root = talloc_new(NULL);
1789| 
1790| 	printf("==== talloc_steal(root, l1)
");
1791| 	talloc_steal(root, l1);
1792| 
1793| 	printf("==== talloc_size(pool, 1024)
");
1794| 	l2 = talloc_size(pool, 1024);
1795| 	torture_assert("memlimit", l2 == NULL,
1796| 			"failed: alloc should fail due to memory limit
");
1797| 
1798| 	printf("==== talloc_free_children(pool)
");
1799| 	talloc_free(l1);
1800| 	talloc_free_children(pool);
1801| 
1802| 	printf("==== talloc_size(pool, 1024)
");
1803| 	l1 = talloc_size(pool, 1024);
1804| 
1805| 	/* try reallocs of increasing size */
1806| 	for (i = 1; i < 9; i++) {
1807| 		printf("==== talloc_realloc_size(NULL, l1, %i*1024) %i/10
", i, i + 1);
1808| 		l1 = talloc_realloc_size(NULL, l1, i*1024);
1809| 		torture_assert("memlimit", l1 != NULL,
1810| 			"failed: realloc should not fail due to memory limit
");
1811| 		talloc_report_full(pool, stdout);
1812| 	}
1813| 	/* The next alloc should fail. */
1814| 	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
1815| 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
1816| 	torture_assert("memlimit", l2 == NULL,
1817| 			"failed: realloc should fail due to memory limit
");
1818| 
1819| 	/* Increase the memlimit */
1820| 	printf("==== talloc_set_memlimit(pool, 11*1024)
");
1821| 	talloc_set_memlimit(pool, 11*1024);
1822| 
1823| 	/* The final realloc should still fail
1824| 	   as the entire realloced chunk needs to be moved out of the pool */
1825| 	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
1826| 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
1827| 	torture_assert("memlimit", l2 == NULL,
1828| 			"failed: realloc should fail due to memory limit
");
1829| 
1830| 	talloc_report_full(pool, stdout);
1831| 
1832| 	printf("==== talloc_set_memlimit(pool, 21*1024)
");
1833| 	talloc_set_memlimit(pool, 21*1024);
1834| 
1835| 	/* There''s now sufficient space to move the chunk out of the pool */
1836| 	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
1837| 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
1838| 	torture_assert("memlimit", l2 != NULL,
1839| 			"failed: realloc should not fail due to memory limit
");
1840| 
1841| 	talloc_report_full(pool, stdout);
1842| 
1843| 	/* ...which should mean smaller allocations can now occur within the pool */
1844| 	printf("==== talloc_size(pool, 9*1024)
");
1845| 	l1 = talloc_size(pool, 9*1024);
1846| 	torture_assert("memlimit", l1 != NULL,
1847| 			"failed: new allocations should be allowed in the pool
");
1848| 
1849| 	talloc_report_full(pool, stdout);
1850| 
1851| 	/* But reallocs bigger than the pool will still fail */
1852| 	printf("==== talloc_realloc_size(NULL, l1, 10*1024)
");
1853| 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
1854| 	torture_assert("memlimit", l2 == NULL,
1855| 			"failed: realloc should fail due to memory limit
");
1856| 
1857| 	talloc_report_full(pool, stdout);
1858| 
1859| 	/* ..as well as allocs */
1860| 	printf("==== talloc_size(pool, 1024)
");
1861| 	l1 = talloc_size(pool, 1024);
1862| 	torture_assert("memlimit", l1 == NULL,
1863| 			"failed: alloc should fail due to memory limit
");
1864| 
1865| 	talloc_report_full(pool, stdout);
1866| 
1867| 	printf("==== talloc_free_children(pool)
");
1868| 	talloc_free_children(pool);
1869| 
1870| 	printf("==== talloc_set_memlimit(pool, 1024)
");
1871| 	talloc_set_memlimit(pool, 1024);
1872| 
1873| 	/* We should still be able to allocate up to the pool limit
1874| 	   because the memlimit only applies to new heap allocations */
1875| 	printf("==== talloc_size(pool, 9*1024)
");
1876| 	l1 = talloc_size(pool, 9*1024);
1877| 	torture_assert("memlimit", l1 != NULL,
1878| 			"failed: alloc should not fail due to memory limit
");
1879| 
1880| 	talloc_report_full(pool, stdout);
1881| 
1882| 	l1 = talloc_size(pool, 1024);
1883| 	torture_assert("memlimit", l1 == NULL,
1884| 			"failed: alloc should fail due to memory limit
");
1885| 
1886| 	talloc_report_full(pool, stdout);
1887| 
1888| 	printf("==== talloc_free_children(pool)
");
1889| 	talloc_free_children(pool);
1890| 
1891| 	printf("==== talloc_set_memlimit(pool, 10*1024)
");
1892| 	talloc_set_memlimit(pool, 10*1024);
1893| 
1894| 	printf("==== talloc_size(pool, 1024)
");
1895| 	l1 = talloc_size(pool, 1024);
1896| 	torture_assert("memlimit", l1 != NULL,
1897| 			"failed: alloc should not fail due to memory limit
");
1898| 
1899| 	talloc_report_full(pool, stdout);
1900| 
1901| 	talloc_free(pool);
1902| 	talloc_free(root);
1903| 	printf("success: memlimit
");
1904| 
1905| 	return true;
1906| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1714: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:1714: var_assign: Assigning: "t" = storage returned from "_talloc_realloc_array(NULL, l5, 1UL, 600U, "char")".
talloc-2.4.2/testsuite.c:1715: leaked_storage: Variable "t" going out of scope leaks the storage it points to.
# 1713|   	printf("==== talloc_realloc(NULL, l5, char, 600)
");
# 1714|   	t = talloc_realloc(NULL, l5, char, 600);
# 1715|-> 	torture_assert("memlimit", t == NULL,
# 1716|   		"failed: alloc should fail due to memory limit
");
# 1717|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1815: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1815: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1815")".
talloc-2.4.2/testsuite.c:1816: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1814|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024) 10/10
");
# 1815|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1816|-> 	torture_assert("memlimit", l2 == NULL,
# 1817|   			"failed: realloc should fail due to memory limit
");
# 1818|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099323');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (388, 103, 'def23', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2172: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2170|   
# 2171|   		/* Never reached. Make compilers happy */
# 2172|-> 		return true;
# 2173|   	}
# 2174|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2172: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2170|   
# 2171|    /* Never reached. Make compilers happy */
# 2172|->  return true;
# 2173|   }
# 2174|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2172: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2170|   
# 2171|   		/* Never reached. Make compilers happy */
# 2172|-> 		return true;
# 2173|   	}
# 2174|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:2155: alloc_fn: Storage is returned from allocation function "_talloc_realloc_array".
talloc-2.4.2/testsuite.c:2155: var_assign: Assigning: "p3" = storage returned from "_talloc_realloc_array(pool, p2, 4UL, 2048U, "int")".
talloc-2.4.2/testsuite.c:2193: leaked_storage: Variable "p3" going out of scope leaks the storage it points to.
# 2191|   
# 2192|   	printf("success: magic_free_protection
");
# 2193|-> 	return true;
# 2194|   }
# 2195|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099323');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (389, 103, 'def24', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1369|   	/* this should reclaim the memory from the pool */
# 1370|   	p3 = talloc_size(pool, 800);
# 1371|-> 	torture_assert("pool alloc 800", p3 == p1, "failed: pointer changed");
# 1372|   	memset(p3, 0x11, talloc_get_size(p3));
# 1373|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1369|    /* this should reclaim the memory from the pool */
# 1370|    p3 = talloc_size(pool, 800);
# 1371|->  torture_assert("pool alloc 800", p3 == p1, "failed: pointer changed");
# 1372|    memset(p3, 0x11, talloc_get_size(p3));
# 1373|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1364: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1364: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1364")".
talloc-2.4.2/testsuite.c:1366: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1367: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1371: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1369|   	/* this should reclaim the memory from the pool */
# 1370|   	p3 = talloc_size(pool, 800);
# 1371|-> 	torture_assert("pool alloc 800", p3 == p1, "failed: pointer changed");
# 1372|   	memset(p3, 0x11, talloc_get_size(p3));
# 1373|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1336: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1336: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 1800UL, "../../testsuite.c:1336")".
talloc-2.4.2/testsuite.c:1338: var_assign: Assigning: "p2" = "p2_2".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "talloc_get_size".
talloc-2.4.2/testsuite.c:1339: noescape: Resource "p2" is not freed or pointed-to in "memset". [Note: The source code implementation of the function has been overridden by a builtin model.]
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
talloc-2.4.2/testsuite.c:1343: leaked_storage: Variable "p2" going out of scope leaks the storage it points to.
# 1341|   	/* this should reclaim the memory from the pool */
# 1342|   	p3 = talloc_size(pool, 80);
# 1343|-> 	torture_assert("pool alloc 80", p3 == p1, "failed: pointer changed");
# 1344|   	memset(p3, 0x11, talloc_get_size(p3));
# 1345|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099324');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (390, 103, 'def25', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1316: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1316: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1316")".
talloc-2.4.2/testsuite.c:1317: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1315|   	memset(p2, 0x11, talloc_get_size(p2));
# 1316|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1317|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1318|   	memset(p2, 0x11, talloc_get_size(p2));
# 1319|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1316: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1316: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1316")".
talloc-2.4.2/testsuite.c:1317: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1315|    memset(p2, 0x11, talloc_get_size(p2));
# 1316|    p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1317|->  torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1318|    memset(p2, 0x11, talloc_get_size(p2));
# 1319|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1316: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1316: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1316")".
talloc-2.4.2/testsuite.c:1317: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1315|   	memset(p2, 0x11, talloc_get_size(p2));
# 1316|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1317|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1318|   	memset(p2, 0x11, talloc_get_size(p2));
# 1319|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1359: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1359: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1359")".
talloc-2.4.2/testsuite.c:1360: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1360|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1361|   	memset(p2, 0x11, talloc_get_size(p2));
# 1362|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099324');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (391, 103, 'def26', 'COPY_PASTE_ERROR', 'talloc-2.4.2/talloc.c:2385: original: "tc2->next" looks like the original copy.
talloc-2.4.2/talloc.c:2381: copy_paste_error: "next" in "tc2->next" looks like a copy-paste error.
talloc-2.4.2/talloc.c:2381: remediation: Should it say "child" instead?
# 2379|   		struct talloc_chunk *tc, *tc2;
# 2380|   		tc = talloc_chunk_from_ptr(null_context);
# 2381|-> 		for (tc2 = tc->child; tc2; tc2=tc2->next) {
# 2382|   			if (tc2->parent == tc) tc2->parent = NULL;
# 2383|   			if (tc2->prev == tc) tc2->prev = NULL;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/talloc.c:2385: original: "tc2->next" looks like the original copy.
talloc-2.4.2/talloc.c:2381: copy_paste_error: "next" in "tc2->next" looks like a copy-paste error.
talloc-2.4.2/talloc.c:2381: remediation: Should it say "child" instead?
# 2379|    struct talloc_chunk *tc, *tc2;
# 2380|    tc = talloc_chunk_from_ptr(null_context);
# 2381|->  for (tc2 = tc->child; tc2; tc2=tc2->next) {
# 2382|    if (tc2->parent == tc) tc2->parent = NULL;
# 2383|    if (tc2->prev == tc) tc2->prev = NULL;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
talloc-2.4.2/talloc.c:2385: original: "tc2->next" looks like the original copy.
talloc-2.4.2/talloc.c:2381: copy_paste_error: "next" in "tc2->next" looks like a copy-paste error.
talloc-2.4.2/talloc.c:2381: remediation: Should it say "child" instead?
# 2379|   		struct talloc_chunk *tc, *tc2;
# 2380|   		tc = talloc_chunk_from_ptr(null_context);
# 2381|-> 		for (tc2 = tc->child; tc2; tc2=tc2->next) {
# 2382|   			if (tc2->parent == tc) tc2->parent = NULL;
# 2383|   			if (tc2->prev == tc) tc2->prev = NULL;
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099324');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (392, 103, 'def27', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1416: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1416: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 48UL, "../../testsuite.c:1416")".
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1416: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1416: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 48UL, "../../testsuite.c:1416")".
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|    p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|->  torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|    memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1416: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1416: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(root, p2, 48UL, "../../testsuite.c:1416")".
talloc-2.4.2/testsuite.c:1417: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1415|   
# 1416|   	p2_2 = talloc_realloc_size(root, p2, 3 * 16);
# 1417|-> 	torture_assert("pool realloc 5 * 16", p2_2 == p2, "failed: pointer changed");
# 1418|   	memset(p2_2, 0x11, talloc_get_size(p2_2));
# 1419|
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1356: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1356: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 19UL, "../../testsuite.c:1356")".
talloc-2.4.2/testsuite.c:1357: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1355|   
# 1356|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
# 1357|-> 	torture_assert("pool realloc 20-1", p2_2 == p2, "failed: pointer changed");
# 1358|   	memset(p2, 0x11, talloc_get_size(p2));
# 1359|   	p2_2 = talloc_realloc_size(pool, p2, 20-1);
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099325');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (393, 103, 'def28', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1330: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1330: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 800UL, "../../testsuite.c:1330")".
talloc-2.4.2/testsuite.c:1331: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1329|   	/* this should reclaim the memory of p1 */
# 1330|   	p2_2 = talloc_realloc_size(pool, p2, 800);
# 1331|-> 	torture_assert("pool realloc 800", p2_2 == p1, "failed: pointer not changed");
# 1332|   	p2 = p2_2;
# 1333|   	memset(p2, 0x11, talloc_get_size(p2));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1330: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1330: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 800UL, "../../testsuite.c:1330")".
talloc-2.4.2/testsuite.c:1331: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1329|    /* this should reclaim the memory of p1 */
# 1330|    p2_2 = talloc_realloc_size(pool, p2, 800);
# 1331|->  torture_assert("pool realloc 800", p2_2 == p1, "failed: pointer not changed");
# 1332|    p2 = p2_2;
# 1333|    memset(p2, 0x11, talloc_get_size(p2));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1330: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1330: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 800UL, "../../testsuite.c:1330")".
talloc-2.4.2/testsuite.c:1331: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1329|   	/* this should reclaim the memory of p1 */
# 1330|   	p2_2 = talloc_realloc_size(pool, p2, 800);
# 1331|-> 	torture_assert("pool realloc 800", p2_2 == p1, "failed: pointer not changed");
# 1332|   	p2 = p2_2;
# 1333|   	memset(p2, 0x11, talloc_get_size(p2));
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1323: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1323: var_assign: Assigning: "p2_2" = storage returned from "_talloc_realloc(pool, p2, 400UL, "../../testsuite.c:1323")".
talloc-2.4.2/testsuite.c:1324: leaked_storage: Variable "p2_2" going out of scope leaks the storage it points to.
# 1322|   	/* this should reclaim the memory of p4 and p3 */
# 1323|   	p2_2 = talloc_realloc_size(pool, p2, 400);
# 1324|-> 	torture_assert("pool realloc 400", p2_2 == p2, "failed: pointer changed");
# 1325|   	memset(p2, 0x11, talloc_get_size(p2));
# 1326|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099325');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (394, 103, 'def29', 'RESOURCE_LEAK', 'talloc-2.4.2/testsuite.c:1837: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1837: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1837")".
talloc-2.4.2/testsuite.c:1853: overwrite_var: Overwriting "l2" in "l2 = _talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")" leaks the storage that "l2" points to.
# 1851|   	/* But reallocs bigger than the pool will still fail */
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)\n");
# 1853|-> 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|   	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit\n");', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: talloc-2.4.2/testsuite.c:1837: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1837: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1837")".
talloc-2.4.2/testsuite.c:1853: overwrite_var: Overwriting "l2" in "l2 = _talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")" leaks the storage that "l2" points to.
# 1851|    /* But reallocs bigger than the pool will still fail */
# 1852|    printf("==== talloc_realloc_size(NULL, l1, 10*1024)\n");
# 1853|->  l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|    torture_assert("memlimit", l2 == NULL,
# 1855|            "failed: realloc should fail due to memory limit\n");', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1837: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1837: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1837")".
talloc-2.4.2/testsuite.c:1853: overwrite_var: Overwriting "l2" in "l2 = _talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")" leaks the storage that "l2" points to.
# 1851|   	/* But reallocs bigger than the pool will still fail */
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)
");
# 1853|-> 	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|   	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit
");
(Example-1) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
talloc-2.4.2/testsuite.c:1853: alloc_fn: Storage is returned from allocation function "_talloc_realloc".
talloc-2.4.2/testsuite.c:1853: var_assign: Assigning: "l2" = storage returned from "_talloc_realloc(NULL, l1, 10240UL, "../../testsuite.c:1853")".
talloc-2.4.2/testsuite.c:1854: leaked_storage: Variable "l2" going out of scope leaks the storage it points to.
# 1852|   	printf("==== talloc_realloc_size(NULL, l1, 10*1024)
");
# 1853|   	l2 = talloc_realloc_size(NULL, l1, 10*1024);
# 1854|-> 	torture_assert("memlimit", l2 == NULL,
# 1855|   			"failed: realloc should fail due to memory limit
");
# 1856|
(Example-2) Reason Marked as False Positive:
This is the testsuite and Coverity doesn''t understand talloc without a modelling file.

', '2025-11-17 21:39:07.099325');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (395, 108, 'def1', 'UNINIT', 'rpcbind-1.2.6/src/rpcb_svc_com.c:1177: var_decl: Declaring variable "reply_msg" without initializer.
rpcbind-1.2.6/src/rpcb_svc_com.c:1254: uninit_use: Using uninitialized value "reply_msg.rm_xid".
# 1252|   		free(buffer);
# 1253|   
# 1254|-> 	if (reply_msg.rm_xid == 0) {
# 1255|   #ifdef	SVC_RUN_DEBUG
# 1256|   	if (debugging) {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: rpcbind-1.2.6/src/rpcb_svc_com.c:1177: var_decl: Declaring variable "reply_msg" without initializer.
rpcbind-1.2.6/src/rpcb_svc_com.c:1254: uninit_use: Using uninitialized value "reply_msg.rm_xid".
# 1252|    free(buffer);
# 1253|   
# 1254|-> if (reply_msg.rm_xid == 0) {
# 1255|   #ifdef SVC_RUN_DEBUG
# 1256|    if (debugging) {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
rpcbind-1.2.6/src/rpcb_svc_com.c:1177: var_decl: Declaring variable "reply_msg" without initializer.
rpcbind-1.2.6/src/rpcb_svc_com.c:1254: uninit_use: Using uninitialized value "reply_msg.rm_xid".
# 1252|   		free(buffer);
# 1253|   
# 1254|-> 	if (reply_msg.rm_xid == 0) {
# 1255|   #ifdef	SVC_RUN_DEBUG
# 1256|   	if (debugging) {
(Example-1) Reason Marked as False Positive:
Initalized in xdr_replymsg()

', '2025-11-17 21:39:07.107497');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (402, 102, 'def5', 'INTEGER_OVERFLOW', 'glibc-2.39/debug/pcprofiledump.c:136: tainted_data_return: Called function "read(fd, &pair.bytes[8UL - len], len)", and a possible return value may be less than zero.
glibc-2.39/debug/pcprofiledump.c:136: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/debug/pcprofiledump.c:135: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
glibc-2.39/debug/pcprofiledump.c:138: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/debug/pcprofiledump.c:136: overflow: The expression "8UL - len" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/debug/pcprofiledump.c:136: deref_overflow: "8UL - len", which might have underflowed, is passed to "pair.bytes[8UL - len]".
#  134|   
#  135|   	  while (len > 0
#  136|-> 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
#  137|   						   len))) != 0)
#  138|   	    len -= n;', 'TRUE POSITIVE', 'Unchecked negative return value from `read` allows potential underflow in `len -= n` (lines 136-138), directly correlating with CVE descriptions of `tainted_data_return`, `cast_underflow`, and `overflow`, with no explicit safeguard present.', '1. **Unchecked Negative Return Value**: The `read` function''s return value `n` is checked for `!= 0` (line 136), but a negative value (indicating an error) would also pass this check. Unlike Example-1 and Example-2, where negative return values are implicitly checked (Example-1: line 87, Example-2: `> 0` check), here, a negative `n` would incorrectly decrement `len` (line 138), potentially leading to an underflow.

2. **Potential Underflow in `len -= n`**: As `n` can be negative (see justification 1), subtracting it from `len` (line 138) may indeed cause an underflow, especially since `len` is of type `size_t` (an unsigned type, declared on line 132). This underflow could lead to a very large value in `len`, causing the loop to continue indefinitely or behave erratically.

3. **Direct Correlation with CVE Description**: The issues identified (unchecked negative return value leading to potential underflow in `len -= n` and the underflow in `8UL - len` due to `len` being potentially larger than `8UL` after the underflow) directly correlate with the vulnerability descriptions provided in the CVE report snippet (e.g., `tainted_data_return`, `cast_underflow`, `overflow` in the context of `len -= n` and `8UL - len`).

4. **No Explicit Safe Guard**: Unlike the provided false positive examples, there''s no explicit safeguard in the code snippet (e.g., checking for `> 0` or handling negative values separately) that would prevent the described vulnerabilities from occurring, given the identified execution paths.', 'Perform a thorough code review of `pcprofiledump.c` to identify any implicit safeguards or constraints on `len` and `n` that might mitigate the identified potential vulnerabilities.

Conduct fuzz testing or simulations to determine if the underflow in `len -= n` can be exploited to cause erratic behavior or a security vulnerability.

Verify the calling context of `pcprofiledump.c` to ensure that the `fd` and initial value of `len` cannot be manipulated by an attacker to exploit the potential underflow.', 0.0000, '*** Source Code Context ***

code of debug/pcprofiledump.c file:
79| int
80| main (int argc, char *argv[])
81| {
82|   /* Set locale via LC_ALL.  */
83|   setlocale (LC_ALL, "");
84| 
85|   /* Set the text message domain.  */
86|   textdomain (PACKAGE);
87| 
88|   /* Parse and process arguments.  */
89|   int remaining;
90|   argp_parse (&argp, argc, argv, 0, &remaining, NULL);
91| 
92|   int fd;
93|   if (remaining == argc)
94|     fd = STDIN_FILENO;
95|   else if (remaining + 1 != argc)
96|     {
97|       argp_help (&argp, stdout, ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR,
98| 		 program_invocation_short_name);
99|       exit (1);
100|     }
101|   else
102|     {
103|       /* Open the given file.  */
104|       fd = open (argv[remaining], O_RDONLY);
105| 
106|       if (fd == -1)
107| 	error (EXIT_FAILURE, errno, _("cannot open input file"));
108|     }
109| 
110|   /* Read the first 4-byte word.  It contains the information about
111|      the word size and the endianness.  */
112|   uint32_t word;
113|   if (TEMP_FAILURE_RETRY (read (fd, &word, 4)) != 4)
114|     error (EXIT_FAILURE, errno, _("cannot read header"));
115| 
116|   /* Check whether we have to swap the byte order.  */
117|   int must_swap = (word & 0x0fffffff) == bswap_32 (0xdeb00000);
118|   if (must_swap)
119|     word = bswap_32 (word);
120| 
121|   /* We have two loops, one for 32 bit pointers, one for 64 bit pointers.  */
122|   if (word == 0xdeb00004)
123|     {
124|       union
125|       {
126| 	uint32_t ptrs[2];
127| 	char bytes[8];
128|       } pair;
129| 
130|       while (1)
131| 	{
132| 	  size_t len = sizeof (pair);
133| 	  size_t n;
134| 
135| 	  while (len > 0
136| 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
137| 						   len))) != 0)
138| 	    len -= n;
139| 
140| 	  if (len != 0)
141| 	    /* Nothing to read.  */
142| 	    break;
143| 
144| 	  printf ("this = %#010" PRIx32 ", caller = %#010" PRIx32 "
",
145| 		  must_swap ? bswap_32 (pair.ptrs[0]) : pair.ptrs[0],
146| 		  must_swap ? bswap_32 (pair.ptrs[1]) : pair.ptrs[1]);
147| 	}
148|     }
149|   else if (word == 0xdeb00008)
150|     {
151|       union
152|       {
153| 	uint64_t ptrs[2];
154| 	char bytes[16];
155|       } pair;
156| 
157|       while (1)
158| 	{
159| 	  size_t len = sizeof (pair);
160| 	  size_t n;
161| 
162| 	  while (len > 0
163| 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
164| 						   len))) != 0)
165| 	    len -= n;
166| 
167| 	  if (len != 0)
168| 	    /* Nothing to read.  */
169| 	    break;
170| 
171| 	  printf ("this = %#018" PRIx64 ", caller = %#018" PRIx64 "
",
172| 		  must_swap ? bswap_64 (pair.ptrs[0]) : pair.ptrs[0],
173| 		  must_swap ? bswap_64 (pair.ptrs[1]) : pair.ptrs[1]);
174| 	}
175|     }
176|   else
177|     /* This should not happen.  */
178|     error (EXIT_FAILURE, 0, _("invalid pointer size"));
179| 
180|   /* Clean up.  */
181|   close (fd);
182| 
183|   return 0;
184| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;
(Example-2) Reason Marked as False Positive:
there''s a check for read returning > 0 in the conditional

', '2025-11-17 21:39:07.118803');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (403, 102, 'def6', 'INTEGER_OVERFLOW', 'glibc-2.39/debug/pcprofiledump.c:163: tainted_data_return: Called function "read(fd, &pair.bytes[8UL - len], len)", and a possible return value may be less than zero.
glibc-2.39/debug/pcprofiledump.c:163: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/debug/pcprofiledump.c:162: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
glibc-2.39/debug/pcprofiledump.c:165: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/debug/pcprofiledump.c:163: overflow: The expression "8UL - len" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/debug/pcprofiledump.c:163: deref_overflow: "8UL - len", which might have underflowed, is passed to "pair.bytes[8UL - len]".
#  161|   
#  162|   	  while (len > 0
#  163|-> 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
#  164|   						   len))) != 0)
#  165|   	    len -= n;', 'TRUE POSITIVE', 'Unchecked negative return value from `read` (line 163) can lead to underflow in `len -= n` (line 165) since `len` is an unsigned `size_t`, and there''s no explicit error handling to prevent this scenario, aligning with reported overflow and underflow concerns.', '1. **Unchecked Negative Return Value**: The `read` function''s return value `n` is checked for `!= 0` (line 163), but a negative value (indicating an error) would also pass this check. Unlike Example-1 and Example-2, where the checks explicitly handled or implied handling of negative values, this code does not explicitly handle the case where `n` is negative, potentially leading to an underflow in `len -= n` (line 165).

2. **Potential Underflow in `len -= n`**: If `n` is negative (due to an error from `read`), subtracting it from `len` (line 165) could result in an underflow, especially since `len` is of type `size_t` (an unsigned type, as declared in line 132), leading to a potentially large value being stored in `len`. This scenario aligns with the reported ''overflow'' and ''underflow'' concerns.

3. **Direct Vulnerability Path**: A specific sequence of execution that potentially triggers the vulnerability is identifiable: if `read` returns a negative value (error), and this value is assigned to `n`, then the subsequent subtraction `len -= n` could indeed underflow, given `len`''s unsigned nature.

4. **Lack of Explicit Error Handling for `read`''s Negative Return**: Unlike the provided false positive examples, this code snippet does not demonstrate explicit handling or checks for the negative return values from `read` that would prevent the described underflow/overflow scenarios, necessitating a TRUE POSITIVE classification.', NULL, 0.0000, '*** Source Code Context ***

code of debug/pcprofiledump.c file:
79| int
80| main (int argc, char *argv[])
81| {
82|   /* Set locale via LC_ALL.  */
83|   setlocale (LC_ALL, "");
84| 
85|   /* Set the text message domain.  */
86|   textdomain (PACKAGE);
87| 
88|   /* Parse and process arguments.  */
89|   int remaining;
90|   argp_parse (&argp, argc, argv, 0, &remaining, NULL);
91| 
92|   int fd;
93|   if (remaining == argc)
94|     fd = STDIN_FILENO;
95|   else if (remaining + 1 != argc)
96|     {
97|       argp_help (&argp, stdout, ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR,
98| 		 program_invocation_short_name);
99|       exit (1);
100|     }
101|   else
102|     {
103|       /* Open the given file.  */
104|       fd = open (argv[remaining], O_RDONLY);
105| 
106|       if (fd == -1)
107| 	error (EXIT_FAILURE, errno, _("cannot open input file"));
108|     }
109| 
110|   /* Read the first 4-byte word.  It contains the information about
111|      the word size and the endianness.  */
112|   uint32_t word;
113|   if (TEMP_FAILURE_RETRY (read (fd, &word, 4)) != 4)
114|     error (EXIT_FAILURE, errno, _("cannot read header"));
115| 
116|   /* Check whether we have to swap the byte order.  */
117|   int must_swap = (word & 0x0fffffff) == bswap_32 (0xdeb00000);
118|   if (must_swap)
119|     word = bswap_32 (word);
120| 
121|   /* We have two loops, one for 32 bit pointers, one for 64 bit pointers.  */
122|   if (word == 0xdeb00004)
123|     {
124|       union
125|       {
126| 	uint32_t ptrs[2];
127| 	char bytes[8];
128|       } pair;
129| 
130|       while (1)
131| 	{
132| 	  size_t len = sizeof (pair);
133| 	  size_t n;
134| 
135| 	  while (len > 0
136| 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
137| 						   len))) != 0)
138| 	    len -= n;
139| 
140| 	  if (len != 0)
141| 	    /* Nothing to read.  */
142| 	    break;
143| 
144| 	  printf ("this = %#010" PRIx32 ", caller = %#010" PRIx32 "
",
145| 		  must_swap ? bswap_32 (pair.ptrs[0]) : pair.ptrs[0],
146| 		  must_swap ? bswap_32 (pair.ptrs[1]) : pair.ptrs[1]);
147| 	}
148|     }
149|   else if (word == 0xdeb00008)
150|     {
151|       union
152|       {
153| 	uint64_t ptrs[2];
154| 	char bytes[16];
155|       } pair;
156| 
157|       while (1)
158| 	{
159| 	  size_t len = sizeof (pair);
160| 	  size_t n;
161| 
162| 	  while (len > 0
163| 		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
164| 						   len))) != 0)
165| 	    len -= n;
166| 
167| 	  if (len != 0)
168| 	    /* Nothing to read.  */
169| 	    break;
170| 
171| 	  printf ("this = %#018" PRIx64 ", caller = %#018" PRIx64 "
",
172| 		  must_swap ? bswap_64 (pair.ptrs[0]) : pair.ptrs[0],
173| 		  must_swap ? bswap_64 (pair.ptrs[1]) : pair.ptrs[1]);
174| 	}
175|     }
176|   else
177|     /* This should not happen.  */
178|     error (EXIT_FAILURE, 0, _("invalid pointer size"));
179| 
180|   /* Clean up.  */
181|   close (fd);
182| 
183|   return 0;
184| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;
(Example-2) Reason Marked as False Positive:
there''s a check for read returning > 0 in the conditional

', '2025-11-17 21:39:07.118804');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (404, 102, 'def7', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:498: overflow: The expression "maxlen - actlen" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:498: overflow_sink: "maxlen - actlen", which might have underflowed, is passed to "read(fd, inptr, maxlen - actlen)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  496|     while (actlen < maxlen)
#  497|       {
#  498|->       ssize_t n = read (fd, inptr, maxlen - actlen);
#  499|   
#  500|         if (n == 0)', 'TRUE POSITIVE', 'The expression `maxlen - actlen` (line 498) can underflow if `actlen` exceeds `maxlen`, and this potentially underflowed value is passed to `read()`, aligning with CWE-190, without explicit bounds checking or inherent mitigation in the provided code.', '1. **Tainted Argument**: The CVE report correctly identifies `actlen` as a tainted expression in the check `actlen < maxlen` (line 496). This taint propagates to `maxlen`, making the subsequent subtraction `maxlen - actlen` potentially vulnerable to underflow (as reported in line 498).

2. **Underflow Potential**: The expression `maxlen - actlen` (line 498) can indeed underflow if `actlen` is larger than `maxlen`. Although `actlen` is initially set to 0 (line 494) and incremented by the return value of `read()` (line 512), there''s no explicit check preventing `actlen` from exceeding `maxlen` in all possible execution paths before the subtraction.

3. **Lack of Explicit Bounds Checking**: The code does not explicitly verify that `maxlen - actlen` does not underflow before passing it to `read()`. While the loop condition `actlen < maxlen` (line 496) suggests a safe range, the critical issue is the underflow potential in the subtraction itself, not just the loop''s continuation condition.

4. **Passing Potentially Underflowed Value to `read()`**: The result of `maxlen - actlen`, which might have underflowed, is directly passed to `read(fd, inptr, maxlen - actlen)` (line 498). This could potentially lead to an incorrect (possibly very large) number of bytes being requested for reading, aligning with the CWE-190 (Integer Overflow or Wraparound) vulnerability described.

5. **No Clear Mitigation in Provided Code**: Unlike the provided examples of FALSE POSITIVES (e.g., Examples 1 and 2, where realloc''s size limitations mitigate the underflow risk), the current code snippet does not demonstrate an inherent limitation or check that would prevent the underflow from occurring or being exploited in the context of the `read()` function call.', 'Investigate all execution paths leading to the `maxlen - actlen` subtraction to confirm no implicit checks prevent `actlen` from exceeding `maxlen`.

Examine the `read()` function''s builtin model implementation for any implicit size limitations or checks that could mitigate the underflow risk.', 0.0000, '*** Source Code Context ***

code of iconv/iconv_charmap.c file:
483| static int
484| process_fd (struct convtable *tbl, int fd, FILE *output)
485| {
486|   /* We have a problem with reading from a descriptor since we must not
487|      provide the iconv() function an incomplete character or shift
488|      sequence at the end of the buffer.  Since we have to deal with
489|      arbitrary encodings we must read the whole text in a buffer and
490|      process it in one step.  */
491|   static char *inbuf = NULL;
492|   static size_t maxlen = 0;
493|   char *inptr = inbuf;
494|   size_t actlen = 0;
495| 
496|   while (actlen < maxlen)
497|     {
498|       ssize_t n = read (fd, inptr, maxlen - actlen);
499| 
500|       if (n == 0)
501| 	/* No more text to read.  */
502| 	break;
503| 
504|       if (n == -1)
505| 	{
506| 	  /* Error while reading.  */
507| 	  error (0, errno, _("error while reading the input"));
508| 	  return -1;
509| 	}
510| 
511|       inptr += n;
512|       actlen += n;
513|     }
514| 
515|   if (actlen == maxlen)
516|     while (1)
517|       {
518| 	ssize_t n;
519| 	char *new_inbuf;
520| 
521| 	/* Increase the buffer.  */
522| 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
523| 	if (new_inbuf == NULL)
524| 	  {
525| 	    error (0, errno, _("unable to allocate buffer for input"));
526| 	    return -1;
527| 	  }
528| 	inbuf = new_inbuf;
529| 	maxlen += 32768;
530| 	inptr = inbuf + actlen;
531| 
532| 	do
533| 	  {
534| 	    n = read (fd, inptr, maxlen - actlen);
535| 
536| 	    if (n == 0)
537| 	      /* No more text to read.  */
538| 	      break;
539| 
540| 	    if (n == -1)
541| 	      {
542| 		/* Error while reading.  */
543| 		error (0, errno, _("error while reading the input"));
544| 		return -1;
545| 	      }
546| 
547| 	    inptr += n;
548| 	    actlen += n;
549| 	  }
550| 	while (actlen < maxlen);
551| 
552| 	if (n == 0)
553| 	  /* Break again so we leave both loops.  */
554| 	  break;
555|       }
556| 
557|   /* Now we have all the input in the buffer.  Process it in one run.  */
558|   return process_block (tbl, inbuf, actlen, output);
559| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-1) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-2) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

', '2025-11-17 21:39:07.118804');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (405, 102, 'def8', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_charmap.c:498: tainted_data_return: Called function "read(fd, inptr, maxlen - actlen)", and a possible return value may be less than zero.
glibc-2.39/iconv/iconv_charmap.c:498: assign: Assigning: "n" = "read(fd, inptr, maxlen - actlen)".
glibc-2.39/iconv/iconv_charmap.c:512: overflow: The expression "actlen += n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/iconv/iconv_charmap.c:558: overflow_sink: "actlen", which might be negative, is passed to "process_block(tbl, inbuf, actlen, output)".
#  556|   
#  557|     /* Now we have all the input in the buffer.  Process it in one run.  */
#  558|->   return process_block (tbl, inbuf, actlen, output);
#  559|   }
#  560|', 'TRUE POSITIVE', 'Integer overflow vulnerability (CWE-190) is possible due to the addition of a potentially negative `n` (from `read()` at iconv_charmap.c:498) to unsigned `actlen` at iconv_charmap.c:512, which is then passed to `process_block()` at iconv_charmap.c:558 without underflow correction, leading to potential security issues.', '1. **Negative Return Value from `read()`**: The `read()` function at `iconv_charmap.c:498` can indeed return a value less than zero, indicating an error (e.g., `-1` for errors, with `errno` set accordingly). This is a documented behavior of the `read()` system call.

2. **Assignment to `n`**: The potentially negative return value from `read()` is directly assigned to `n` at `iconv_charmap.c:498`. This means `n` can hold a negative value.

3. **Overflow Risk in `actlen += n`**: At `iconv_charmap.c:512`, `n` (which can be negative) is added to `actlen`. Since `actlen` is a `size_t` (an unsigned type), adding a negative value to it will result in underflow, wrapping around to a very large unsigned value. This is an **integer overflow** condition as described in the CVE, aligning with CWE-190.

4. **Passing Potentially Negative `actlen` to `process_block()`**: Despite being an unsigned type, the potentially underflowed `actlen` is passed to `process_block()` at `iconv_charmap.c:558`. Given that `actlen` might now represent an incorrectly large value due to the underflow, this could lead to unexpected behavior within `process_block()`, including but not limited to, buffer overflows or incorrect processing.

5. **Lack of Explicit Error Handling for Negative `n` in This Context**: While errors from `read()` are checked (e.g., `if (n == -1)` at `iconv_charmap.c:504`), the specific scenario of a negative `n` being added to `actlen` and then passed to `process_block()` without correction or check for underflow in this exact code path, suggests a vulnerability.

6. **Direct Correlation with CWE-190 (Integer Overflow)**: The described behavior directly correlates with an integer overflow vulnerability, where an arithmetic operation (addition) can cause an unsigned integer to wrap around, potentially leading to security issues.', 'Obtain and analyze the implementation of `process_block()` to determine how it handles negative `actlen` values.

Verify if any implicit error handling or checks within `process_block()` or its called functions could mitigate the potential vulnerability.', 0.0000, '*** Source Code Context ***

code of iconv/iconv_charmap.c file:
483| static int
484| process_fd (struct convtable *tbl, int fd, FILE *output)
485| {
486|   /* We have a problem with reading from a descriptor since we must not
487|      provide the iconv() function an incomplete character or shift
488|      sequence at the end of the buffer.  Since we have to deal with
489|      arbitrary encodings we must read the whole text in a buffer and
490|      process it in one step.  */
491|   static char *inbuf = NULL;
492|   static size_t maxlen = 0;
493|   char *inptr = inbuf;
494|   size_t actlen = 0;
495| 
496|   while (actlen < maxlen)
497|     {
498|       ssize_t n = read (fd, inptr, maxlen - actlen);
499| 
500|       if (n == 0)
501| 	/* No more text to read.  */
502| 	break;
503| 
504|       if (n == -1)
505| 	{
506| 	  /* Error while reading.  */
507| 	  error (0, errno, _("error while reading the input"));
508| 	  return -1;
509| 	}
510| 
511|       inptr += n;
512|       actlen += n;
513|     }
514| 
515|   if (actlen == maxlen)
516|     while (1)
517|       {
518| 	ssize_t n;
519| 	char *new_inbuf;
520| 
521| 	/* Increase the buffer.  */
522| 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
523| 	if (new_inbuf == NULL)
524| 	  {
525| 	    error (0, errno, _("unable to allocate buffer for input"));
526| 	    return -1;
527| 	  }
528| 	inbuf = new_inbuf;
529| 	maxlen += 32768;
530| 	inptr = inbuf + actlen;
531| 
532| 	do
533| 	  {
534| 	    n = read (fd, inptr, maxlen - actlen);
535| 
536| 	    if (n == 0)
537| 	      /* No more text to read.  */
538| 	      break;
539| 
540| 	    if (n == -1)
541| 	      {
542| 		/* Error while reading.  */
543| 		error (0, errno, _("error while reading the input"));
544| 		return -1;
545| 	      }
546| 
547| 	    inptr += n;
548| 	    actlen += n;
549| 	  }
550| 	while (actlen < maxlen);
551| 
552| 	if (n == 0)
553| 	  /* Break again so we leave both loops.  */
554| 	  break;
555|       }
556| 
557|   /* Now we have all the input in the buffer.  Process it in one run.  */
558|   return process_block (tbl, inbuf, actlen, output);
559| }

code of /shared-data/source/glibc-2.39/iconv/iconv_charmap.c file:
423| static int
424| process_block (struct convtable *tbl, char *addr, size_t len, FILE *output)
425| {
426|   size_t n = 0;
427| 
428|   while (n < len)
429|     {
430|       struct convtable *cur = tbl;
431|       unsigned char *curp = (unsigned char *) addr;
432|       unsigned int byte = *curp;
433|       int cnt;
434|       struct charseq *out;
435| 
436|       while (! is_term (cur, byte))
437| 	if (cur->val[byte].sub == NULL)
438| 	  {
439| 	    /* This is an invalid sequence.  Skip the first byte if we are
440| 	       ignoring errors.  Otherwise punt.  */
441| 	    if (! omit_invalid)
442| 	      {
443| 		error (0, 0, _("illegal input sequence at position %zd"), n);
444| 		return -1;
445| 	      }
446| 
447| 	    n -= curp - (unsigned char *) addr;
448| 
449| 	    byte = *(curp = (unsigned char *) ++addr);
450| 	    if (++n >= len)
451| 	      /* All converted.  */
452| 	      return 0;
453| 
454| 	    cur = tbl;
455| 	  }
456| 	else
457| 	  {
458| 	    cur = cur->val[byte].sub;
459| 
460| 	    if (++n >= len)
461| 	      {
462| 		error (0, 0, _("\
463| incomplete character or shift sequence at end of buffer"));
464| 		return -1;
465| 	      }
466| 
467| 	    byte = *++curp;
468| 	  }
469| 
470|       /* We found a final byte.  Write the output bytes.  */
471|       out = cur->val[byte].out;
472|       for (cnt = 0; cnt < out->nbytes; ++cnt)
473| 	fputc_unlocked (out->bytes[cnt], output);
474| 
475|       addr = (char *) curp + 1;
476|       ++n;
477|     }
478| 
479|   return 0;
480| }

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-1) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-2) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

', '2025-11-17 21:39:07.118804');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (406, 102, 'def9', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:552: overflow: The expression "maxlen - actlen" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:552: overflow_sink: "maxlen - actlen", which might have underflowed, is passed to "read(fd, inptr, maxlen - actlen)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  550|     while (actlen < maxlen)
#  551|       {
#  552|->       ssize_t n = read (fd, inptr, maxlen - actlen);
#  553|   
#  554|         if (n == 0)', 'TRUE POSITIVE', 'Potential underflow in `maxlen - actlen` (line 552) due to tainted `actlen`, with no explicit bounds checking or validation to prevent manipulation, creating a possible vulnerable execution path for CWE-190: Integer Overflow or Wraparound.', '1. **Explicit Underflow Risk**: The CVE report highlights a potential underflow in the expression `maxlen - actlen` (line 552) due to `actlen` being tainted, which could lead to an incorrect (potentially large) value being passed to `read()`. This is a direct correlation with the described vulnerability (CWE-190: Integer Overflow or Wraparound).

2. **Lack of Explicit Bounds Checking**: Within the provided code snippet, there is no explicit check to prevent `actlen` from exceeding `maxlen` in a way that would cause an underflow when calculating `maxlen - actlen`. The loop condition `while (actlen < maxlen)` (line 550) ensures `actlen` doesn''t exceed `maxlen` in a normal increment scenario, but the tainted nature of `actlen` (as per the CVE) suggests its value could be manipulated.

3. **Uncertainty Regarding ''tainted'' Nature**: The term ''tainted'' implies `actlen`''s value might not be trustworthy. Without explicit code showing how `actlen` is validated or sanitized before the loop, we cannot assume it''s safe from manipulation that could lead to an underflow in `maxlen - actlen`.

4. **Potential for Vulnerable Execution Path**: Given the uncertainty around `actlen`''s value and the lack of explicit underflow protection in the provided code, there exists a potential execution path where the vulnerability described in the CVE could be triggered, specifically if `actlen` is manipulated to cause an underflow in `maxlen - actlen`, leading to an incorrect `read()` operation.

5. **Adherence to Analysis Guidelines**: Given the direct correlation with CWE-190, the lack of explicit safety measures in the code, and the potential for a vulnerable execution path, the analysis leans towards **TRUE POSITIVE** as per the guidelines, which dictate that a single potentially vulnerable path and lack of definitive proof against the vulnerability should lead to this conclusion.', 'Provide the source code or a detailed explanation of how `actlen` is initialized, validated, and potentially manipulated before and within the loop.

Investigate the implementation of the `read()` function to understand its behavior with potentially underflowed size arguments.

Analyze the calling context of `iconv_prog.c` to identify possible input vectors for `actlen` that could lead to an underflow in `maxlen - actlen`.', 0.0000, '*** Source Code Context ***

code of iconv/iconv_prog.c file:
537| static int
538| process_fd (iconv_t cd, int fd, FILE **output, const char *output_file)
539| {
540|   /* we have a problem with reading from a descriptor since we must not
541|      provide the iconv() function an incomplete character or shift
542|      sequence at the end of the buffer.  Since we have to deal with
543|      arbitrary encodings we must read the whole text in a buffer and
544|      process it in one step.  */
545|   static char *inbuf = NULL;
546|   static size_t maxlen = 0;
547|   char *inptr = NULL;
548|   size_t actlen = 0;
549| 
550|   while (actlen < maxlen)
551|     {
552|       ssize_t n = read (fd, inptr, maxlen - actlen);
553| 
554|       if (n == 0)
555| 	/* No more text to read.  */
556| 	break;
557| 
558|       if (n == -1)
559| 	{
560| 	  /* Error while reading.  */
561| 	  error (0, errno, _("error while reading the input"));
562| 	  return -1;
563| 	}
564| 
565|       inptr += n;
566|       actlen += n;
567|     }
568| 
569|   if (actlen == maxlen)
570|     while (1)
571|       {
572| 	ssize_t n;
573| 	char *new_inbuf;
574| 
575| 	/* Increase the buffer.  */
576| 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
577| 	if (new_inbuf == NULL)
578| 	  {
579| 	    error (0, errno, _("unable to allocate buffer for input"));
580| 	    return -1;
581| 	  }
582| 	inbuf = new_inbuf;
583| 	maxlen += 32768;
584| 	inptr = inbuf + actlen;
585| 
586| 	do
587| 	  {
588| 	    n = read (fd, inptr, maxlen - actlen);
589| 
590| 	    if (n == 0)
591| 	      /* No more text to read.  */
592| 	      break;
593| 
594| 	    if (n == -1)
595| 	      {
596| 		/* Error while reading.  */
597| 		error (0, errno, _("error while reading the input"));
598| 		return -1;
599| 	      }
600| 
601| 	    inptr += n;
602| 	    actlen += n;
603| 	  }
604| 	while (actlen < maxlen);
605| 
606| 	if (n == 0)
607| 	  /* Break again so we leave both loops.  */
608| 	  break;
609|       }
610| 
611|   /* Now we have all the input in the buffer.  Process it in one run.  */
612|   return process_block (cd, inbuf, actlen, output, output_file);
613| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-1) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-2) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

', '2025-11-17 21:39:07.118805');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (409, 102, 'def12', 'OVERRUN', 'glibc-2.39/libio/vasprintf.c:53: cond_at_most: Checking "current_pos >= 2147483647UL" implies that "current_pos" may be up to 2147483646 on the false branch.
glibc-2.39/libio/vasprintf.c:75: overrun-buffer-arg: Overrunning array "buf->direct" of 200 bytes by passing it to a function which accesses it at byte offset 2147483645 using argument "current_pos" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#   73|   	  return;
#   74|   	}
#   75|->       memcpy (new_buffer, buf->direct, current_pos);
#   76|       }
#   77|     else', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/libio/vasprintf.c:53: cond_at_most: Checking "current_pos >= 2147483647UL" implies that "current_pos" may be up to 2147483646 on the false branch.
glibc-2.39/libio/vasprintf.c:75: overrun-buffer-arg: Overrunning array "buf->direct" of 200 bytes by passing it to a function which accesses it at byte offset 2147483645 using argument "current_pos" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#   73|     return;
#   74|   }
#   75|->       memcpy (new_buffer, buf->direct, current_pos);
#   76|       }
#   77|     else', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/libio/vasprintf.c:53: cond_at_most: Checking "current_pos >= 2147483647UL" implies that "current_pos" may be up to 2147483646 on the false branch.
glibc-2.39/libio/vasprintf.c:75: overrun-buffer-arg: Overrunning array "buf->direct" of 200 bytes by passing it to a function which accesses it at byte offset 2147483645 using argument "current_pos" (which evaluates to 2147483646). [Note: The source code implementation of the function has been overridden by a builtin model.]
#   73|   	  return;
#   74|   	}
#   75|->       memcpy (new_buffer, buf->direct, current_pos);
#   76|       }
#   77|     else
(Example-1) Reason Marked as False Positive:
The check >= INT_MAX is intended to test for 64-bit pointer math resulting in a size_t that exceeds sizeof(int).  I.e. it''s for systems where the return value of asprintf() would be too large.  It is not related to negative numbers.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118806');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (410, 102, 'def13', 'BUFFER_SIZE', 'glibc-2.39/locale/programs/md5.c:173: overlapping_buffer: The source buffer "&(*ctx).buffer[64]" potentially overlaps with the destination buffer "(*ctx).buffer", which results in undefined behavior for "memcpy".
glibc-2.39/locale/programs/md5.c:173: remediation: Use memmove instead of "memcpy".
#  171|   	  __md5_process_block (ctx->buffer, 64, ctx);
#  172|   	  left_over -= 64;
#  173|-> 	  memcpy (ctx->buffer, &ctx->buffer[64], left_over);
#  174|   	}
#  175|         ctx->buflen = left_over;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.33.9000-984-gddcc612ce9/crypt/md5.c:267: overlapping_buffer: The source buffer "&(*ctx).buffer[64]" potentially overlaps with the destination buffer "(*ctx).buffer", which results in undefined behavior for "memcpy".
glibc-2.33.9000-984-gddcc612ce9/crypt/md5.c:267: remediation: Use memmove instead of "memcpy".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error BUFFER_SIZE (CWE-474):
glibc-2.33.9000-984-gddcc612ce9/crypt/md5.c:267: overlapping_buffer: The source buffer "&(*ctx).buffer[64]" potentially overlaps with the destination buffer "(*ctx).buffer", which results in undefined behavior for "memcpy".
glibc-2.33.9000-984-gddcc612ce9/crypt/md5.c:267: remediation: Use memmove instead of "memcpy".
(Example-1) Reason Marked as False Positive:
left_over is always <= 64.  Last code change was in 2012,
so it''s not worth churning this code just to satisfy coverity.

** Example-2 **
(Example-2) Known False Positive:
Error BUFFER_SIZE (CWE-170):
glibc-2.33.9000-984-gddcc612ce9/login/login.c:114: buffer_size_warning: Calling "strncpy" with a maximum size argument of 32 bytes on destination array "copy.ut_line" of size 32 bytes might leave the destination string unterminated.
(Example-2) Reason Marked as False Positive:
__attribute_nonstring__

', '2025-11-17 21:39:07.118806');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (411, 102, 'def14', 'COPY_PASTE_ERROR', 'glibc-2.39/scripts/glibcpp.py:507: original: "left.line" looks like the original copy.
glibc-2.39/scripts/glibcpp.py:512: copy_paste_error: "left" in "left.line" looks like a copy-paste error.
glibc-2.39/scripts/glibcpp.py:512: remediation: Should it say "right" instead?
#  510|                                     ''in definition of macro {}''.format(md.name))
#  511|                   if type(right) != type(1):
#  512|->                     reporter.error(left.line,
#  513|                           ''right operand of {} is not an integer''.format(op))
#  514|                       reporter.note(md.line,', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/scripts/glibcpp.py:507: original: "left.line" looks like the original copy.
glibc-2.39/scripts/glibcpp.py:512: copy_paste_error: "left" in "left.line" looks like a copy-paste error.
glibc-2.39/scripts/glibcpp.py:512: remediation: Should it say "right" instead?
#  510|                                     ''in definition of macro {}''.format(md.name))
#  511|                   if type(right) != type(1):
#  512|->                     reporter.error(left.line,
#  513|                           ''right operand of {} is not an integer''.format(op))
#  514|                       reporter.note(md.line,', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
glibc-2.39/scripts/glibcpp.py:507: original: "left.line" looks like the original copy.
glibc-2.39/scripts/glibcpp.py:512: copy_paste_error: "left" in "left.line" looks like a copy-paste error.
glibc-2.39/scripts/glibcpp.py:512: remediation: Should it say "right" instead?
#  510|                                     ''in definition of macro {}''.format(md.name))
#  511|                   if type(right) != type(1):
#  512|->                     reporter.error(left.line,
#  513|                           ''right operand of {} is not an integer''.format(op))
#  514|                       reporter.note(md.line,
(Example-1) Reason Marked as False Positive:
it''s reporting the line number of the start of the expression, not the specific term in it.

** Example-2 **
(Example-2) Known False Positive:
Error COPY_PASTE_ERROR (CWE-398):
glibc-2.33.9000-984-gddcc612ce9/sysdeps/ieee754/dbl-64/e_atan2.c:84: original: "y + y" looks like the original copy.
glibc-2.33.9000-984-gddcc612ce9/sysdeps/ieee754/dbl-64/e_atan2.c:76: copy_paste_error: "y" in "x + y" looks like a copy-paste error.
glibc-2.33.9000-984-gddcc612ce9/sysdeps/ieee754/dbl-64/e_atan2.c:76: remediation: Should it say "x" instead?
(Example-2) Reason Marked as False Positive:
False positive.

', '2025-11-17 21:39:07.118806');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (412, 102, 'def15', 'INTEGER_OVERFLOW', 'glibc-2.39/elf/sprof.c:559: tainted_data_argument: The value "*shdr" is considered tainted.
glibc-2.39/elf/sprof.c:564: tainted_data_argument: "shdr[ehdr->e_shstrndx].sh_offset" is considered tainted.
glibc-2.39/elf/sprof.c:564: underflow: The cast of "shdr[ehdr->e_shstrndx].sh_offset" to a signed type could result in a negative number.
#  562|     /* Get the section header string table.  */
#  563|     char *shstrtab = (char *) alloca (shdr[ehdr->e_shstrndx].sh_size);
#  564|->   if (pread (fd, shstrtab, shdr[ehdr->e_shstrndx].sh_size,
#  565|   	     shdr[ehdr->e_shstrndx].sh_offset)
#  566|         != shdr[ehdr->e_shstrndx].sh_size)', 'TRUE POSITIVE', 'Tainted ELF data (`*shdr` and `shdr[ehdr->e_shstrndx].sh_offset`) is used without explicit validation or sanitization, potentially leading to underflow issues when cast to a signed type (line 564), with no clear safeguards in the provided code snippet.', '1. **Tainted Data Usage**: The CVE report highlights that `*shdr` (line 559) and `shdr[ehdr->e_shstrndx].sh_offset` (line 564) are considered tainted. This indicates that the data used comes from an untrusted source (in this case, an ELF file), which is a legitimate concern for security vulnerabilities.

2. **Potential Underflow**: The report warns about a possible underflow when casting `shdr[ehdr->e_shstrndx].sh_offset` to a signed type (line 564). This could lead to unexpected behavior if `sh_offset` is a large value that, when cast, becomes a negative number. **No explicit check or handling for this scenario is shown in the provided code snippet**.

3. **Lack of Input Validation**: The provided code does not demonstrate explicit validation or sanitization of `shdr[ehdr->e_shstrndx].sh_size` or `shdr[ehdr->e_shstrndx].sh_offset` before using them in memory allocation (`alloca`) and file reading operations (`pread`). This lack of validation increases the risk associated with using tainted data.

4. **Direct Correlation to Vulnerability**: The described issues directly correlate with the vulnerability described in the CVE, focusing on the handling of potentially tainted data from ELF files and the absence of explicit safeguards against underflow in the provided code snippet.

5. **No Clear False Positive Evidence**: Based on the provided information, there is no definitive proof that the described vulnerability cannot occur under any circumstances within the analyzed code. Therefore, leaning towards **TRUE POSITIVE** is appropriate given the guidelines.', 'Examine the broader codebase surrounding `sprof.c` to identify any implicit or explicit mitigations for the highlighted issues (tainted data handling, underflow scenarios, and input validation for `shdr[ehdr->e_shstrndx].sh_size` and `shdr[ehdr->e_shstrndx].sh_offset`).

Verify the implementation of `pread` to ensure it properly handles potentially malicious `sh_size` and `sh_offset` values from the ELF file.

Investigate if any higher-level error handling or input validation mechanisms are in place that could mitigate the reported vulnerabilities.', 0.0000, '*** Source Code Context ***

code of elf/sprof.c file:
400| static struct shobj *
401| load_shobj (const char *name)
402| {
403|   struct link_map *map = NULL;
404|   struct shobj *result;
405|   ElfW(Addr) mapstart = ~((ElfW(Addr)) 0);
406|   ElfW(Addr) mapend = 0;
407|   const ElfW(Phdr) *ph;
408|   size_t textsize;
409|   ElfW(Ehdr) *ehdr;
410|   int fd;
411|   ElfW(Shdr) *shdr;
412|   size_t pagesize = getpagesize ();
413| 
414|   /* Since we use dlopen() we must be prepared to work around the sometimes
415|      strange lookup rules for the shared objects.  If we have a file foo.so
416|      in the current directory and the user specifies foo.so on the command
417|      line (without specifying a directory) we should load the file in the
418|      current directory even if a normal dlopen() call would read the other
419|      file.  We do this by adding a directory portion to the name.  */
420|   if (strchr (name, ''/'') == NULL)
421|     {
422|       char *load_name = (char *) alloca (strlen (name) + 3);
423|       stpcpy (stpcpy (load_name, "./"), name);
424| 
425|       map = (struct link_map *) dlopen (load_name, RTLD_LAZY | __RTLD_SPROF);
426|     }
427|   if (map == NULL)
428|     {
429|       map = (struct link_map *) dlopen (name, RTLD_LAZY | __RTLD_SPROF);
430|       if (map == NULL)
431| 	{
432| 	  error (0, errno, _("failed to load shared object `%s''"), name);
433| 	  return NULL;
434| 	}
435|     }
436| 
437|   /* Prepare the result.  */
438|   result = (struct shobj *) calloc (1, sizeof (struct shobj));
439|   if (result == NULL)
440|     {
441|       error (0, errno, _("cannot create internal descriptor"));
442|       dlclose (map);
443|       return NULL;
444|     }
445|   result->name = name;
446|   result->map = map;
447| 
448|   /* Compute the size of the sections which contain program code.
449|      This must match the code in dl-profile.c (_dl_start_profile).  */
450|   for (ph = map->l_phdr; ph < &map->l_phdr[map->l_phnum]; ++ph)
451|     if (ph->p_type == PT_LOAD && (ph->p_flags & PF_X))
452|       {
453| 	ElfW(Addr) start = (ph->p_vaddr & ~(pagesize - 1));
454| 	ElfW(Addr) end = ((ph->p_vaddr + ph->p_memsz + pagesize - 1)
455| 			  & ~(pagesize - 1));
456| 
457| 	if (start < mapstart)
458| 	  mapstart = start;
459| 	if (end > mapend)
460| 	  mapend = end;
461|       }
462| 
463|   result->lowpc = ROUNDDOWN ((uintptr_t) (mapstart + map->l_addr),
464| 			     HISTFRACTION * sizeof (HISTCOUNTER));
465|   result->highpc = ROUNDUP ((uintptr_t) (mapend + map->l_addr),
466| 			    HISTFRACTION * sizeof (HISTCOUNTER));
467|   if (do_test)
468|     printf ("load addr: %0#*" PRIxPTR "
"
469| 	    "lower bound PC: %0#*" PRIxPTR "
"
470| 	    "upper bound PC: %0#*" PRIxPTR "
",
471| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, map->l_addr,
472| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->lowpc,
473| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->highpc);
474| 
475|   textsize = result->highpc - result->lowpc;
476|   result->kcountsize = textsize / HISTFRACTION;
477|   result->hashfraction = HASHFRACTION;
478|   if (do_test)
479|     printf ("hashfraction = %d
divider = %zu
",
480| 	    result->hashfraction,
481| 	    result->hashfraction * sizeof (struct here_fromstruct));
482|   result->tossize = textsize / HASHFRACTION;
483|   result->fromlimit = textsize * ARCDENSITY / 100;
484|   if (result->fromlimit < MINARCS)
485|     result->fromlimit = MINARCS;
486|   if (result->fromlimit > MAXARCS)
487|     result->fromlimit = MAXARCS;
488|   result->fromssize = result->fromlimit * sizeof (struct here_fromstruct);
489| 
490|   result->expected_size = (sizeof (struct gmon_hdr)
491| 			   + 4 + sizeof (struct gmon_hist_hdr)
492| 			   + result->kcountsize
493| 			   + 4 + 4
494| 			   + (result->fromssize
495| 			      * sizeof (struct here_cg_arc_record)));
496| 
497|   if (do_test)
498|     printf ("expected size: %zd
", result->expected_size);
499| 
500| #define SCALE_1_TO_1	0x10000L
501| 
502|   if (result->kcountsize < result->highpc - result->lowpc)
503|     {
504|       size_t range = result->highpc - result->lowpc;
505|       size_t quot = range / result->kcountsize;
506| 
507|       if (quot >= SCALE_1_TO_1)
508| 	result->s_scale = 1;
509|       else if (quot >= SCALE_1_TO_1 / 256)
510| 	result->s_scale = SCALE_1_TO_1 / quot;
511|       else if (range > ULONG_MAX / 256)
512| 	result->s_scale = ((SCALE_1_TO_1 * 256)
513| 			   / (range / (result->kcountsize / 256)));
514|       else
515| 	result->s_scale = ((SCALE_1_TO_1 * 256)
516| 			   / ((range * 256) / result->kcountsize));
517|     }
518|   else
519|     result->s_scale = SCALE_1_TO_1;
520| 
521|   if (do_test)
522|     printf ("s_scale: %d
", result->s_scale);
523| 
524|   /* Determine the dynamic string table.  */
525|   if (map->l_info[DT_STRTAB] == NULL)
526|     result->dynstrtab = NULL;
527|   else
528|     result->dynstrtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
529|   if (do_test)
530|     printf ("string table: %p
", result->dynstrtab);
531| 
532|   /* Determine the soname.  */
533|   if (map->l_info[DT_SONAME] == NULL)
534|     result->soname = NULL;
535|   else
536|     result->soname = result->dynstrtab + map->l_info[DT_SONAME]->d_un.d_val;
537|   if (do_test && result->soname != NULL)
538|     printf ("soname: %s
", result->soname);
539| 
540|   /* Now we have to load the symbol table.
541| 
542|      First load the section header table.  */
543|   ehdr = (ElfW(Ehdr) *) map->l_map_start;
544| 
545|   /* Make sure we are on the right party.  */
546|   if (ehdr->e_shentsize != sizeof (ElfW(Shdr)))
547|     abort ();
548| 
549|   /* And we need the shared object file descriptor again.  */
550|   fd = open (map->l_name, O_RDONLY);
551|   if (fd == -1)
552|     /* Dooh, this really shouldn''t happen.  We know the file is available.  */
553|     error (EXIT_FAILURE, errno, _("Reopening shared object `%s'' failed"),
554| 	   map->l_name);
555| 
556|   /* Map the section header.  */
557|   size_t size = ehdr->e_shnum * sizeof (ElfW(Shdr));
558|   shdr = (ElfW(Shdr) *) alloca (size);
559|   if (pread (fd, shdr, size, ehdr->e_shoff) != size)
560|     error (EXIT_FAILURE, errno, _("reading of section headers failed"));
561| 
562|   /* Get the section header string table.  */
563|   char *shstrtab = (char *) alloca (shdr[ehdr->e_shstrndx].sh_size);
564|   if (pread (fd, shstrtab, shdr[ehdr->e_shstrndx].sh_size,
565| 	     shdr[ehdr->e_shstrndx].sh_offset)
566|       != shdr[ehdr->e_shstrndx].sh_size)
567|     error (EXIT_FAILURE, errno,
568| 	   _("reading of section header string table failed"));
569| 
570|   /* Search for the ".symtab" section.  */
571|   ElfW(Shdr) *symtab_entry = NULL;
572|   ElfW(Shdr) *debuglink_entry = NULL;
573|   for (int idx = 0; idx < ehdr->e_shnum; ++idx)
574|     if (shdr[idx].sh_type == SHT_SYMTAB
575| 	&& strcmp (shstrtab + shdr[idx].sh_name, ".symtab") == 0)
576|       {
577| 	symtab_entry = &shdr[idx];
578| 	break;
579|       }
580|     else if (shdr[idx].sh_type == SHT_PROGBITS
581| 	     && strcmp (shstrtab + shdr[idx].sh_name, ".gnu_debuglink") == 0)
582|       debuglink_entry = &shdr[idx];
583| 
584|   /* Get the file name of the debuginfo file if necessary.  */
585|   int symfd = fd;
586|   if (symtab_entry == NULL && debuglink_entry != NULL)
587|     {
588|       size_t size = debuglink_entry->sh_size;
589|       char *debuginfo_fname = (char *) alloca (size + 1);
590|       debuginfo_fname[size] = ''\0'';
591|       if (pread (fd, debuginfo_fname, size, debuglink_entry->sh_offset)
592| 	  != size)
593| 	{
594| 	  fprintf (stderr, _("*** Cannot read debuginfo file name: %m
"));
595| 	  goto no_debuginfo;
596| 	}
597| 
598|       static const char procpath[] = "/proc/self/fd/%d";
599|       char origprocname[sizeof (procpath) + sizeof (int) * 3];
600|       snprintf (origprocname, sizeof (origprocname), procpath, fd);
601|       char *origlink = (char *) alloca (PATH_MAX);
602|       ssize_t n = readlink (origprocname, origlink, PATH_MAX - 1);
603|       if (n == -1)
604| 	goto no_debuginfo;
605|       origlink[n] = ''\0'';
606| 
607|       /* Try to find the actual file.  There are three places:
608| 	 1. the same directory the DSO is in
609| 	 2. in a subdir named .debug of the directory the DSO is in
610| 	 3. in /usr/lib/debug/PATH-OF-DSO
611|       */
612|       char *realname = canonicalize_file_name (origlink);
613|       char *cp = NULL;
614|       if (realname == NULL || (cp = strrchr (realname, ''/'')) == NULL)
615| 	error (EXIT_FAILURE, errno, _("cannot determine file name"));
616| 
617|       /* Leave the last slash in place.  */
618|       *++cp = ''\0'';
619| 
620|       /* First add the debuginfo file name only.  */
621|       static const char usrlibdebug[]= "/usr/lib/debug/";
622|       char *workbuf = (char *) alloca (sizeof (usrlibdebug)
623| 				       + (cp - realname)
624| 				       + strlen (debuginfo_fname));
625|       strcpy (stpcpy (workbuf, realname), debuginfo_fname);
626| 
627|       int fd2 = open (workbuf, O_RDONLY);
628|       if (fd2 == -1)
629| 	{
630| 	  strcpy (stpcpy (stpcpy (workbuf, realname), ".debug/"),
631| 		  debuginfo_fname);
632| 	  fd2 = open (workbuf, O_RDONLY);
633| 	  if (fd2 == -1)
634| 	    {
635| 	      strcpy (stpcpy (stpcpy (workbuf, usrlibdebug), realname),
636| 		      debuginfo_fname);
637| 	      fd2 = open (workbuf, O_RDONLY);
638| 	    }
639| 	}
640| 
641|       if (fd2 != -1)
642| 	{
643| 	  ElfW(Ehdr) ehdr2;
644| 
645| 	  /* Read the ELF header.  */
646| 	  if (pread (fd2, &ehdr2, sizeof (ehdr2), 0) != sizeof (ehdr2))
647| 	    error (EXIT_FAILURE, errno,
648| 		   _("reading of ELF header failed"));
649| 
650| 	  /* Map the section header.  */
651| 	  size_t size = ehdr2.e_shnum * sizeof (ElfW(Shdr));
652| 	  ElfW(Shdr) *shdr2 = (ElfW(Shdr) *) alloca (size);
653| 	  if (pread (fd2, shdr2, size, ehdr2.e_shoff) != size)
654| 	    error (EXIT_FAILURE, errno,
655| 		   _("reading of section headers failed"));
656| 
657| 	  /* Get the section header string table.  */
658| 	  shstrtab = (char *) alloca (shdr2[ehdr2.e_shstrndx].sh_size);
659| 	  if (pread (fd2, shstrtab, shdr2[ehdr2.e_shstrndx].sh_size,
660| 		     shdr2[ehdr2.e_shstrndx].sh_offset)
661| 	      != shdr2[ehdr2.e_shstrndx].sh_size)
662| 	    error (EXIT_FAILURE, errno,
663| 		   _("reading of section header string table failed"));
664| 
665| 	  /* Search for the ".symtab" section.  */
666| 	  for (int idx = 0; idx < ehdr2.e_shnum; ++idx)
667| 	    if (shdr2[idx].sh_type == SHT_SYMTAB
668| 		&& strcmp (shstrtab + shdr2[idx].sh_name, ".symtab") == 0)
669| 	      {
670| 		symtab_entry = &shdr2[idx];
671| 		shdr = shdr2;
672| 		symfd = fd2;
673| 		break;
674| 	      }
675| 
676| 	  if  (fd2 != symfd)
677| 	    close (fd2);
678| 	}
679|     }
680| 
681|  no_debuginfo:
682|   if (symtab_entry == NULL)
683|     {
684|       fprintf (stderr, _("\
685| *** The file `%s'' is stripped: no detailed analysis possible
"),
686| 	      name);
687|       result->symtab = NULL;
688|       result->strtab = NULL;
689|     }
690|   else
691|     {
692|       ElfW(Off) min_offset, max_offset;
693|       ElfW(Shdr) *strtab_entry;
694| 
695|       strtab_entry = &shdr[symtab_entry->sh_link];
696| 
697|       /* Find the minimum and maximum offsets that include both the symbol
698| 	 table and the string table.  */
699|       if (symtab_entry->sh_offset < strtab_entry->sh_offset)
700| 	{
701| 	  min_offset = symtab_entry->sh_offset & ~(pagesize - 1);
702| 	  max_offset = strtab_entry->sh_offset + strtab_entry->sh_size;
703| 	}
704|       else
705| 	{
706| 	  min_offset = strtab_entry->sh_offset & ~(pagesize - 1);
707| 	  max_offset = symtab_entry->sh_offset + symtab_entry->sh_size;
708| 	}
709| 
710|       result->symbol_map = mmap (NULL, max_offset - min_offset,
711| 				 PROT_READ, MAP_SHARED|MAP_FILE, symfd,
712| 				 min_offset);
713|       if (result->symbol_map == MAP_FAILED)
714| 	error (EXIT_FAILURE, errno, _("failed to load symbol data"));
715| 
716|       result->symtab
717| 	= (const ElfW(Sym) *) ((const char *) result->symbol_map
718| 			       + (symtab_entry->sh_offset - min_offset));
719|       result->symtab_size = symtab_entry->sh_size;
720|       result->strtab = ((const char *) result->symbol_map
721| 			+ (strtab_entry->sh_offset - min_offset));
722|       result->symbol_mapsize = max_offset - min_offset;
723|     }
724| 
725|   /* Free the descriptor for the shared object.  */
726|   close (fd);
727|   if (symfd != fd)
728|     close (symfd);
729| 
730|   return result;
731| }

code of /usr/include/alloca.h file:
35| # define alloca(size)	__builtin_alloca (size)

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/elf/dl-map-segments.h:101: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h:101: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h:106: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h:156: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h:156: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h:163: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h:176: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h:176: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  174|                       return DL_MAP_SEGMENTS_ERROR_MPROTECT;
#  175|                   }
#  176|->               memset ((void *) zero, ''\0'', zeropage - zero);
#  177|                 if (__glibc_unlikely ((c->prot & PROT_WRITE) == 0))
#  178|                   __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),
(Example-2) Reason Marked as False Positive:
The only negative value that can be returned is -1 (MAP_FAILED) and that''s tested for.

', '2025-11-17 21:39:07.118806');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (413, 102, 'def16', 'INTEGER_OVERFLOW', 'glibc-2.39/elf/sprof.c:653: tainted_data_argument: The value "*shdr2" is considered tainted.
glibc-2.39/elf/sprof.c:659: tainted_data_argument: "shdr2[ehdr2.e_shstrndx].sh_offset" is considered tainted.
glibc-2.39/elf/sprof.c:659: underflow: The cast of "shdr2[ehdr2.e_shstrndx].sh_offset" to a signed type could result in a negative number.
#  657|   	  /* Get the section header string table.  */
#  658|   	  shstrtab = (char *) alloca (shdr2[ehdr2.e_shstrndx].sh_size);
#  659|-> 	  if (pread (fd2, shstrtab, shdr2[ehdr2.e_shstrndx].sh_size,
#  660|   		     shdr2[ehdr2.e_shstrndx].sh_offset)
#  661|   	      != shdr2[ehdr2.e_shstrndx].sh_size)', 'TRUE POSITIVE', 'Tainted ELF file data (`*shdr2` and `shdr2[ehdr2.e_shstrndx].sh_offset`) is used without validation in memory allocation (`alloca`, line 658) and file reading (`pread`, line 659), potentially leading to underflow and unexpected behavior, with no explicit input sanitization or proof of safety in the provided code.', '1. **Tainted Data Usage**: The CVE report highlights that `*shdr2` and `shdr2[ehdr2.e_shstrndx].sh_offset` are considered tainted (lines 653 and 659). This indicates that the data is derived from an untrusted source (in this case, an ELF file), which is a legitimate concern for security vulnerabilities.

2. **Potential Underflow**: The report warns about a possible underflow when casting `shdr2[ehdr2.e_shstrndx].sh_offset` to a signed type (line 659). This could lead to unexpected behavior if `sh_offset` exceeds the maximum value for a signed type, causing it to wrap around to a negative number.

3. **Lack of Input Validation**: Upon examining the provided source code, there is no explicit validation or sanitization of `shdr2[ehdr2.e_shstrndx].sh_size` and `shdr2[ehdr2.e_shstrndx].sh_offset` before their use in memory allocation (`alloca`, line 658) and file reading (`pread`, line 659). This lack of validation increases the risk associated with using tainted data.

4. **Direct Vulnerability Path**: A specific sequence of execution that potentially triggers the vulnerability is identifiable: if an ELF file with maliciously crafted `sh_size` or `sh_offset` values is processed, it could lead to memory allocation issues or incorrect file reading, aligning with the described vulnerabilities (tainted data usage and potential underflow).

5. **No Clear False Positive Evidence**: There is no definitive proof within the provided code that the described vulnerabilities cannot occur under any circumstances. The absence of input validation and the direct usage of potentially tainted data in sensitive operations (memory allocation and file I/O) do not provide sufficient evidence to conclude this as a FALSE POSITIVE.', 'Provide a detailed explanation or evidence of how an attacker could control or manipulate `shdr2[ehdr2.e_shstrndx].sh_offset` to exploit the potential underflow or arbitrary file read.

Verify if there are implicit validations, security checks, or error handling mechanisms elsewhere in the code (e.g., in `pread` or in the handling of `shdr2` and `ehdr2`) that could mitigate the identified risks.

Analyze the code''s behavior for all possible values of `shdr2[ehdr2.e_shstrndx].sh_offset`, including edge cases, to assess the actual impact of the underflow.', 0.0000, '*** Source Code Context ***

code of elf/sprof.c file:
400| static struct shobj *
401| load_shobj (const char *name)
402| {
403|   struct link_map *map = NULL;
404|   struct shobj *result;
405|   ElfW(Addr) mapstart = ~((ElfW(Addr)) 0);
406|   ElfW(Addr) mapend = 0;
407|   const ElfW(Phdr) *ph;
408|   size_t textsize;
409|   ElfW(Ehdr) *ehdr;
410|   int fd;
411|   ElfW(Shdr) *shdr;
412|   size_t pagesize = getpagesize ();
413| 
414|   /* Since we use dlopen() we must be prepared to work around the sometimes
415|      strange lookup rules for the shared objects.  If we have a file foo.so
416|      in the current directory and the user specifies foo.so on the command
417|      line (without specifying a directory) we should load the file in the
418|      current directory even if a normal dlopen() call would read the other
419|      file.  We do this by adding a directory portion to the name.  */
420|   if (strchr (name, ''/'') == NULL)
421|     {
422|       char *load_name = (char *) alloca (strlen (name) + 3);
423|       stpcpy (stpcpy (load_name, "./"), name);
424| 
425|       map = (struct link_map *) dlopen (load_name, RTLD_LAZY | __RTLD_SPROF);
426|     }
427|   if (map == NULL)
428|     {
429|       map = (struct link_map *) dlopen (name, RTLD_LAZY | __RTLD_SPROF);
430|       if (map == NULL)
431| 	{
432| 	  error (0, errno, _("failed to load shared object `%s''"), name);
433| 	  return NULL;
434| 	}
435|     }
436| 
437|   /* Prepare the result.  */
438|   result = (struct shobj *) calloc (1, sizeof (struct shobj));
439|   if (result == NULL)
440|     {
441|       error (0, errno, _("cannot create internal descriptor"));
442|       dlclose (map);
443|       return NULL;
444|     }
445|   result->name = name;
446|   result->map = map;
447| 
448|   /* Compute the size of the sections which contain program code.
449|      This must match the code in dl-profile.c (_dl_start_profile).  */
450|   for (ph = map->l_phdr; ph < &map->l_phdr[map->l_phnum]; ++ph)
451|     if (ph->p_type == PT_LOAD && (ph->p_flags & PF_X))
452|       {
453| 	ElfW(Addr) start = (ph->p_vaddr & ~(pagesize - 1));
454| 	ElfW(Addr) end = ((ph->p_vaddr + ph->p_memsz + pagesize - 1)
455| 			  & ~(pagesize - 1));
456| 
457| 	if (start < mapstart)
458| 	  mapstart = start;
459| 	if (end > mapend)
460| 	  mapend = end;
461|       }
462| 
463|   result->lowpc = ROUNDDOWN ((uintptr_t) (mapstart + map->l_addr),
464| 			     HISTFRACTION * sizeof (HISTCOUNTER));
465|   result->highpc = ROUNDUP ((uintptr_t) (mapend + map->l_addr),
466| 			    HISTFRACTION * sizeof (HISTCOUNTER));
467|   if (do_test)
468|     printf ("load addr: %0#*" PRIxPTR "
"
469| 	    "lower bound PC: %0#*" PRIxPTR "
"
470| 	    "upper bound PC: %0#*" PRIxPTR "
",
471| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, map->l_addr,
472| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->lowpc,
473| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->highpc);
474| 
475|   textsize = result->highpc - result->lowpc;
476|   result->kcountsize = textsize / HISTFRACTION;
477|   result->hashfraction = HASHFRACTION;
478|   if (do_test)
479|     printf ("hashfraction = %d
divider = %zu
",
480| 	    result->hashfraction,
481| 	    result->hashfraction * sizeof (struct here_fromstruct));
482|   result->tossize = textsize / HASHFRACTION;
483|   result->fromlimit = textsize * ARCDENSITY / 100;
484|   if (result->fromlimit < MINARCS)
485|     result->fromlimit = MINARCS;
486|   if (result->fromlimit > MAXARCS)
487|     result->fromlimit = MAXARCS;
488|   result->fromssize = result->fromlimit * sizeof (struct here_fromstruct);
489| 
490|   result->expected_size = (sizeof (struct gmon_hdr)
491| 			   + 4 + sizeof (struct gmon_hist_hdr)
492| 			   + result->kcountsize
493| 			   + 4 + 4
494| 			   + (result->fromssize
495| 			      * sizeof (struct here_cg_arc_record)));
496| 
497|   if (do_test)
498|     printf ("expected size: %zd
", result->expected_size);
499| 
500| #define SCALE_1_TO_1	0x10000L
501| 
502|   if (result->kcountsize < result->highpc - result->lowpc)
503|     {
504|       size_t range = result->highpc - result->lowpc;
505|       size_t quot = range / result->kcountsize;
506| 
507|       if (quot >= SCALE_1_TO_1)
508| 	result->s_scale = 1;
509|       else if (quot >= SCALE_1_TO_1 / 256)
510| 	result->s_scale = SCALE_1_TO_1 / quot;
511|       else if (range > ULONG_MAX / 256)
512| 	result->s_scale = ((SCALE_1_TO_1 * 256)
513| 			   / (range / (result->kcountsize / 256)));
514|       else
515| 	result->s_scale = ((SCALE_1_TO_1 * 256)
516| 			   / ((range * 256) / result->kcountsize));
517|     }
518|   else
519|     result->s_scale = SCALE_1_TO_1;
520| 
521|   if (do_test)
522|     printf ("s_scale: %d
", result->s_scale);
523| 
524|   /* Determine the dynamic string table.  */
525|   if (map->l_info[DT_STRTAB] == NULL)
526|     result->dynstrtab = NULL;
527|   else
528|     result->dynstrtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
529|   if (do_test)
530|     printf ("string table: %p
", result->dynstrtab);
531| 
532|   /* Determine the soname.  */
533|   if (map->l_info[DT_SONAME] == NULL)
534|     result->soname = NULL;
535|   else
536|     result->soname = result->dynstrtab + map->l_info[DT_SONAME]->d_un.d_val;
537|   if (do_test && result->soname != NULL)
538|     printf ("soname: %s
", result->soname);
539| 
540|   /* Now we have to load the symbol table.
541| 
542|      First load the section header table.  */
543|   ehdr = (ElfW(Ehdr) *) map->l_map_start;
544| 
545|   /* Make sure we are on the right party.  */
546|   if (ehdr->e_shentsize != sizeof (ElfW(Shdr)))
547|     abort ();
548| 
549|   /* And we need the shared object file descriptor again.  */
550|   fd = open (map->l_name, O_RDONLY);
551|   if (fd == -1)
552|     /* Dooh, this really shouldn''t happen.  We know the file is available.  */
553|     error (EXIT_FAILURE, errno, _("Reopening shared object `%s'' failed"),
554| 	   map->l_name);
555| 
556|   /* Map the section header.  */
557|   size_t size = ehdr->e_shnum * sizeof (ElfW(Shdr));
558|   shdr = (ElfW(Shdr) *) alloca (size);
559|   if (pread (fd, shdr, size, ehdr->e_shoff) != size)
560|     error (EXIT_FAILURE, errno, _("reading of section headers failed"));
561| 
562|   /* Get the section header string table.  */
563|   char *shstrtab = (char *) alloca (shdr[ehdr->e_shstrndx].sh_size);
564|   if (pread (fd, shstrtab, shdr[ehdr->e_shstrndx].sh_size,
565| 	     shdr[ehdr->e_shstrndx].sh_offset)
566|       != shdr[ehdr->e_shstrndx].sh_size)
567|     error (EXIT_FAILURE, errno,
568| 	   _("reading of section header string table failed"));
569| 
570|   /* Search for the ".symtab" section.  */
571|   ElfW(Shdr) *symtab_entry = NULL;
572|   ElfW(Shdr) *debuglink_entry = NULL;
573|   for (int idx = 0; idx < ehdr->e_shnum; ++idx)
574|     if (shdr[idx].sh_type == SHT_SYMTAB
575| 	&& strcmp (shstrtab + shdr[idx].sh_name, ".symtab") == 0)
576|       {
577| 	symtab_entry = &shdr[idx];
578| 	break;
579|       }
580|     else if (shdr[idx].sh_type == SHT_PROGBITS
581| 	     && strcmp (shstrtab + shdr[idx].sh_name, ".gnu_debuglink") == 0)
582|       debuglink_entry = &shdr[idx];
583| 
584|   /* Get the file name of the debuginfo file if necessary.  */
585|   int symfd = fd;
586|   if (symtab_entry == NULL && debuglink_entry != NULL)
587|     {
588|       size_t size = debuglink_entry->sh_size;
589|       char *debuginfo_fname = (char *) alloca (size + 1);
590|       debuginfo_fname[size] = ''\0'';
591|       if (pread (fd, debuginfo_fname, size, debuglink_entry->sh_offset)
592| 	  != size)
593| 	{
594| 	  fprintf (stderr, _("*** Cannot read debuginfo file name: %m
"));
595| 	  goto no_debuginfo;
596| 	}
597| 
598|       static const char procpath[] = "/proc/self/fd/%d";
599|       char origprocname[sizeof (procpath) + sizeof (int) * 3];
600|       snprintf (origprocname, sizeof (origprocname), procpath, fd);
601|       char *origlink = (char *) alloca (PATH_MAX);
602|       ssize_t n = readlink (origprocname, origlink, PATH_MAX - 1);
603|       if (n == -1)
604| 	goto no_debuginfo;
605|       origlink[n] = ''\0'';
606| 
607|       /* Try to find the actual file.  There are three places:
608| 	 1. the same directory the DSO is in
609| 	 2. in a subdir named .debug of the directory the DSO is in
610| 	 3. in /usr/lib/debug/PATH-OF-DSO
611|       */
612|       char *realname = canonicalize_file_name (origlink);
613|       char *cp = NULL;
614|       if (realname == NULL || (cp = strrchr (realname, ''/'')) == NULL)
615| 	error (EXIT_FAILURE, errno, _("cannot determine file name"));
616| 
617|       /* Leave the last slash in place.  */
618|       *++cp = ''\0'';
619| 
620|       /* First add the debuginfo file name only.  */
621|       static const char usrlibdebug[]= "/usr/lib/debug/";
622|       char *workbuf = (char *) alloca (sizeof (usrlibdebug)
623| 				       + (cp - realname)
624| 				       + strlen (debuginfo_fname));
625|       strcpy (stpcpy (workbuf, realname), debuginfo_fname);
626| 
627|       int fd2 = open (workbuf, O_RDONLY);
628|       if (fd2 == -1)
629| 	{
630| 	  strcpy (stpcpy (stpcpy (workbuf, realname), ".debug/"),
631| 		  debuginfo_fname);
632| 	  fd2 = open (workbuf, O_RDONLY);
633| 	  if (fd2 == -1)
634| 	    {
635| 	      strcpy (stpcpy (stpcpy (workbuf, usrlibdebug), realname),
636| 		      debuginfo_fname);
637| 	      fd2 = open (workbuf, O_RDONLY);
638| 	    }
639| 	}
640| 
641|       if (fd2 != -1)
642| 	{
643| 	  ElfW(Ehdr) ehdr2;
644| 
645| 	  /* Read the ELF header.  */
646| 	  if (pread (fd2, &ehdr2, sizeof (ehdr2), 0) != sizeof (ehdr2))
647| 	    error (EXIT_FAILURE, errno,
648| 		   _("reading of ELF header failed"));
649| 
650| 	  /* Map the section header.  */
651| 	  size_t size = ehdr2.e_shnum * sizeof (ElfW(Shdr));
652| 	  ElfW(Shdr) *shdr2 = (ElfW(Shdr) *) alloca (size);
653| 	  if (pread (fd2, shdr2, size, ehdr2.e_shoff) != size)
654| 	    error (EXIT_FAILURE, errno,
655| 		   _("reading of section headers failed"));
656| 
657| 	  /* Get the section header string table.  */
658| 	  shstrtab = (char *) alloca (shdr2[ehdr2.e_shstrndx].sh_size);
659| 	  if (pread (fd2, shstrtab, shdr2[ehdr2.e_shstrndx].sh_size,
660| 		     shdr2[ehdr2.e_shstrndx].sh_offset)
661| 	      != shdr2[ehdr2.e_shstrndx].sh_size)
662| 	    error (EXIT_FAILURE, errno,
663| 		   _("reading of section header string table failed"));
664| 
665| 	  /* Search for the ".symtab" section.  */
666| 	  for (int idx = 0; idx < ehdr2.e_shnum; ++idx)
667| 	    if (shdr2[idx].sh_type == SHT_SYMTAB
668| 		&& strcmp (shstrtab + shdr2[idx].sh_name, ".symtab") == 0)
669| 	      {
670| 		symtab_entry = &shdr2[idx];
671| 		shdr = shdr2;
672| 		symfd = fd2;
673| 		break;
674| 	      }
675| 
676| 	  if  (fd2 != symfd)
677| 	    close (fd2);
678| 	}
679|     }
680| 
681|  no_debuginfo:
682|   if (symtab_entry == NULL)
683|     {
684|       fprintf (stderr, _("\
685| *** The file `%s'' is stripped: no detailed analysis possible
"),
686| 	      name);
687|       result->symtab = NULL;
688|       result->strtab = NULL;
689|     }
690|   else
691|     {
692|       ElfW(Off) min_offset, max_offset;
693|       ElfW(Shdr) *strtab_entry;
694| 
695|       strtab_entry = &shdr[symtab_entry->sh_link];
696| 
697|       /* Find the minimum and maximum offsets that include both the symbol
698| 	 table and the string table.  */
699|       if (symtab_entry->sh_offset < strtab_entry->sh_offset)
700| 	{
701| 	  min_offset = symtab_entry->sh_offset & ~(pagesize - 1);
702| 	  max_offset = strtab_entry->sh_offset + strtab_entry->sh_size;
703| 	}
704|       else
705| 	{
706| 	  min_offset = strtab_entry->sh_offset & ~(pagesize - 1);
707| 	  max_offset = symtab_entry->sh_offset + symtab_entry->sh_size;
708| 	}
709| 
710|       result->symbol_map = mmap (NULL, max_offset - min_offset,
711| 				 PROT_READ, MAP_SHARED|MAP_FILE, symfd,
712| 				 min_offset);
713|       if (result->symbol_map == MAP_FAILED)
714| 	error (EXIT_FAILURE, errno, _("failed to load symbol data"));
715| 
716|       result->symtab
717| 	= (const ElfW(Sym) *) ((const char *) result->symbol_map
718| 			       + (symtab_entry->sh_offset - min_offset));
719|       result->symtab_size = symtab_entry->sh_size;
720|       result->strtab = ((const char *) result->symbol_map
721| 			+ (strtab_entry->sh_offset - min_offset));
722|       result->symbol_mapsize = max_offset - min_offset;
723|     }
724| 
725|   /* Free the descriptor for the shared object.  */
726|   close (fd);
727|   if (symfd != fd)
728|     close (symfd);
729| 
730|   return result;
731| }

code of /usr/include/alloca.h file:
35| # define alloca(size)	__builtin_alloca (size)

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/elf/dl-map-segments.h:101: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h:101: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h:106: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h:156: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h:156: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h:163: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h:176: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h:176: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  174|                       return DL_MAP_SEGMENTS_ERROR_MPROTECT;
#  175|                   }
#  176|->               memset ((void *) zero, ''\0'', zeropage - zero);
#  177|                 if (__glibc_unlikely ((c->prot & PROT_WRITE) == 0))
#  178|                   __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),
(Example-2) Reason Marked as False Positive:
The only negative value that can be returned is -1 (MAP_FAILED) and that''s tested for.

', '2025-11-17 21:39:07.118807');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (414, 102, 'def17', 'UNEXPECTED_CONTROL_FLOW', 'glibc-2.39/iconv/loop.c:374: continue_in_do_while_false: A "continue" statement within a "do ... while (...)" loop only continues execution of the loop body if the loop continuation condition is still true.  Since the condition will never be true in a "do ... while (false)" loop, the "continue"statement has the same effect as a "break" statement.  Did you intend execution to continue at the top of the loop?
glibc-2.39/iconv/loop.c:376: do_while_false_condition: This loop will never continue since the condition "0" is never true.
#  372|     do
#  373|       {
#  374|->       BODY
#  375|       }
#  376|     while (0);', 'FALSE POSITIVE', 'The reported `continue` statement issue is a FALSE POSITIVE since the provided code (lines 372-376) lacks a `continue` statement within the `do ... while (false)` loop, rendering the warning irrelevant to potential security vulnerabilities.', 'The reported issue is about a `continue` statement within a `do ... while (false)` loop, but the provided code snippet (lines 372-376) does not contain a `continue` statement.

The warning at line 374 (`continue_in_do_while_false`) seems to be incorrect as there is no `continue` statement present within the loop body.

The second warning at line 376 (`do_while_false_condition`) is accurate in stating the loop will never continue because the condition is `0` (false), but this does not inherently indicate a vulnerability or issue that needs fixing; it''s a statement of fact about the loop''s behavior.

Given the loop''s condition is explicitly set to `0` (false), and there''s no `continue` statement to potentially misbehave, the loop will simply execute once and then terminate, which might be the intended behavior.

No syntax issue is identified in the provided code snippet that correlates with the described vulnerability, and the warnings do not imply an execution flow that could lead to a security vulnerability as described in typical CVEs.', 'Provide the actual code for the `BODY` section (line 374) to assess potential vulnerabilities or unexpected behavior.

Verify the reporting process to ensure the correct code snippet is associated with the described CVE.

Re-evaluate the CVE description against the provided code snippet to resolve the discrepancy.', 0.0000, '*** Source Code Context ***

code of iconv/loop.c file:
276| 
277| #if MAX_NEEDED_INPUT > 1
278| # define SINGLE(fct) SINGLE2 (fct)
279| # define SINGLE2(fct) fct##_single
280| static inline int
281| __attribute ((always_inline))
282| SINGLE(LOOPFCT) (struct __gconv_step *step,
283| 		 struct __gconv_step_data *step_data,
284| 		 const unsigned char **inptrp, const unsigned char *inend,
285| 		 unsigned char **outptrp, unsigned char *outend,
286| 		 size_t *irreversible EXTRA_LOOP_DECLS)
287| {
288|   mbstate_t *state = step_data->__statep;
289| # ifdef LOOP_NEED_FLAGS
290|   int flags = step_data->__flags;
291| # endif
292| # ifdef LOOP_NEED_DATA
293|   void *data = step->__data;
294| # endif
295|   int result = __GCONV_OK;
296|   unsigned char bytebuf[MAX_NEEDED_INPUT];
297|   const unsigned char *inptr = *inptrp;
298|   unsigned char *outptr = *outptrp;
299|   size_t inlen;
300| 
301| # ifdef INIT_PARAMS
302|   INIT_PARAMS;
303| # endif
304| 
305| # ifdef UNPACK_BYTES
306|   UNPACK_BYTES
307| # else
308|   /* Add the bytes from the state to the input buffer.  */
309|   assert ((state->__count & 7) <= sizeof (state->__value));
310|   for (inlen = 0; inlen < (size_t) (state->__count & 7); ++inlen)
311|     bytebuf[inlen] = state->__value.__wchb[inlen];
312| # endif
313| 
314|   /* Are there enough bytes in the input buffer?  */
315|   if (MIN_NEEDED_INPUT > 1
316|       && __builtin_expect (inptr + (MIN_NEEDED_INPUT - inlen) > inend, 0))
317|     {
318|       *inptrp = inend;
319| # ifdef STORE_REST
320| 
321|       /* Building with -O3 GCC emits a `array subscript is above array
322| 	 bounds'' warning.  GCC BZ #64739 has been opened for this.  */
323|       DIAG_PUSH_NEEDS_COMMENT;
324|       DIAG_IGNORE_NEEDS_COMMENT (4.9, "-Warray-bounds");
325|       while (inptr < inend)
326| 	bytebuf[inlen++] = *inptr++;
327|       DIAG_POP_NEEDS_COMMENT;
328| 
329|       inptr = bytebuf;
330|       inptrp = &inptr;
331|       inend = &bytebuf[inlen];
332| 
333|       STORE_REST
334| # else
335|       /* We don''t have enough input for another complete input
336| 	 character.  */
337|       size_t inlen_after = inlen + (inend - inptr);
338|       assert (inlen_after <= sizeof (state->__value.__wchb));
339|       for (; inlen < inlen_after; inlen++)
340| 	state->__value.__wchb[inlen] = *inptr++;
341| # endif
342| 
343|       return __GCONV_INCOMPLETE_INPUT;
344|     }
345| 
346|   /* Enough space in output buffer.  */
347|   if ((MIN_NEEDED_OUTPUT != 1 && outptr + MIN_NEEDED_OUTPUT > outend)
348|       || (MIN_NEEDED_OUTPUT == 1 && outptr >= outend))
349|     /* Overflow in the output buffer.  */
350|     return __GCONV_FULL_OUTPUT;
351| 
352|   /*  Now add characters from the normal input buffer.  */
353|   if (inlen >= MAX_NEEDED_INPUT || inptr >= inend)
354|     /* Avoid a -Wstringop-overflow= warning when this loop is
355|        unrolled.  The compiler cannot otherwise see that this is
356|        unreachable because it depends on (state->__count & 7) not
357|        being too large after a previous conversion step.
358|        Starting with GCC 12, we also have mark the inptr >= inend
359|        case as unreachable to omit the warning.  Note that this SINGLE
360|        function is only used to implement the mb*towc*() or wc*tomb*()
361|        functions.  Those functions use inptr and inend pointing to a
362|        variable on stack, compute the inend pointer or explicitly check
363|        the arguments which always leads to inptr < inend.  */
364|     __builtin_unreachable ();
365|   do
366|     bytebuf[inlen++] = *inptr++;
367|   while (inlen < MAX_NEEDED_INPUT && inptr < inend);
368| 
369|   inptr = bytebuf;
370|   inend = &bytebuf[inlen];
371| 
372|   do
373|     {
374|       BODY
375|     }
376|   while (0);
377| 
378|   /* Now we either have produced an output character and consumed all the
379|      bytes from the state and at least one more, or the character is still
380|      incomplete, or we have some other error (like illegal input character,
381|      no space in output buffer).  */
382|   if (__glibc_likely (inptr != bytebuf))
383|     {
384|       /* We found a new character.  */
385|       assert (inptr - bytebuf > (state->__count & 7));
386| 
387|       *inptrp += inptr - bytebuf - (state->__count & 7);
388|       *outptrp = outptr;
389| 
390|       result = __GCONV_OK;
391| 
392|       /* Clear the state buffer.  */
393| # ifdef CLEAR_STATE
394|       CLEAR_STATE;
395| # else
396|       state->__count &= ~7;
397| # endif
398|     }
399|   else if (result == __GCONV_INCOMPLETE_INPUT)
400|     {
401|       /* This can only happen if we have less than MAX_NEEDED_INPUT bytes
402| 	 available.  */
403|       assert (inend != &bytebuf[MAX_NEEDED_INPUT]);
404| 
405|       *inptrp += inend - bytebuf - (state->__count & 7);
406| # ifdef STORE_REST
407|       inptrp = &inptr;
408| 
409|       STORE_REST
410| # else
411|       /* We don''t have enough input for another complete input
412| 	 character.  */
413|       assert (inend - inptr > (state->__count & ~7));
414|       assert (inend - inptr <= sizeof (state->__value.__wchb));
415|       state->__count = (state->__count & ~7) | (inend - inptr);
416|       for (inlen = 0; inlen < inend - inptr; inlen++)
417| 	state->__value.__wchb[inlen] = inptr[inlen];
418|       inptr = inend;
419| # endif
420|     }
421| 
422|   return result;
423| }
424| # undef SINGLE
425| # undef SINGLE2
426| 
427| 
428| # ifdef ONEBYTE_BODY
429| /* Define the shortcut function for btowc.  */
430| static wint_t
431| gconv_btowc (struct __gconv_step *step, unsigned char c)
432|   ONEBYTE_BODY
433| #  define FROM_ONEBYTE gconv_btowc
434| # endif
435| 
436| #endif
437| 
438| /* We remove the macro definitions so that we can include this file again
439|    for the definition of another function.  */
440| #undef MIN_NEEDED_INPUT
441| #undef MAX_NEEDED_INPUT
442| #undef MIN_NEEDED_OUTPUT
443| #undef MAX_NEEDED_OUTPUT
444| #undef LOOPFCT
445| #undef BODY
446| #undef LOOPFCT
447| #undef EXTRA_LOOP_DECLS
448| #undef INIT_PARAMS
449| #undef UPDATE_PARAMS
450| #undef REINIT_PARAMS
451| #undef ONEBYTE_BODY
452| #undef UNPACK_BYTES
453| #undef CLEAR_STATE
454| #undef LOOP_NEED_STATE
455| #undef LOOP_NEED_FLAGS
456| #undef LOOP_NEED_DATA

274| }
275| 
276| 
277| #if MAX_NEEDED_INPUT > 1
278| # define SINGLE(fct) SINGLE2 (fct)
279| # define SINGLE2(fct) fct##_single
280| static inline int
281| __attribute ((always_inline))
282| SINGLE(LOOPFCT) (struct __gconv_step *step,
283| 		 struct __gconv_step_data *step_data,
284| 		 const unsigned char **inptrp, const unsigned char *inend,
285| 		 unsigned char **outptrp, unsigned char *outend,
286| 		 size_t *irreversible EXTRA_LOOP_DECLS)
287| {
288|   mbstate_t *state = step_data->__statep;
289| # ifdef LOOP_NEED_FLAGS
290|   int flags = step_data->__flags;
291| # endif
292| # ifdef LOOP_NEED_DATA
293|   void *data = step->__data;
294| # endif
295|   int result = __GCONV_OK;
296|   unsigned char bytebuf[MAX_NEEDED_INPUT];
297|   const unsigned char *inptr = *inptrp;
298|   unsigned char *outptr = *outptrp;
299|   size_t inlen;
300| 
301| # ifdef INIT_PARAMS
302|   INIT_PARAMS;
303| # endif
304| 
305| # ifdef UNPACK_BYTES
306|   UNPACK_BYTES
307| # else
308|   /* Add the bytes from the state to the input buffer.  */
309|   assert ((state->__count & 7) <= sizeof (state->__value));
310|   for (inlen = 0; inlen < (size_t) (state->__count & 7); ++inlen)
311|     bytebuf[inlen] = state->__value.__wchb[inlen];
312| # endif
313| 
314|   /* Are there enough bytes in the input buffer?  */
315|   if (MIN_NEEDED_INPUT > 1
316|       && __builtin_expect (inptr + (MIN_NEEDED_INPUT - inlen) > inend, 0))
317|     {
318|       *inptrp = inend;
319| # ifdef STORE_REST
320| 
321|       /* Building with -O3 GCC emits a `array subscript is above array
322| 	 bounds'' warning.  GCC BZ #64739 has been opened for this.  */
323|       DIAG_PUSH_NEEDS_COMMENT;
324|       DIAG_IGNORE_NEEDS_COMMENT (4.9, "-Warray-bounds");
325|       while (inptr < inend)
326| 	bytebuf[inlen++] = *inptr++;
327|       DIAG_POP_NEEDS_COMMENT;
328| 
329|       inptr = bytebuf;
330|       inptrp = &inptr;
331|       inend = &bytebuf[inlen];
332| 
333|       STORE_REST
334| # else
335|       /* We don''t have enough input for another complete input
336| 	 character.  */
337|       size_t inlen_after = inlen + (inend - inptr);
338|       assert (inlen_after <= sizeof (state->__value.__wchb));
339|       for (; inlen < inlen_after; inlen++)
340| 	state->__value.__wchb[inlen] = *inptr++;
341| # endif
342| 
343|       return __GCONV_INCOMPLETE_INPUT;
344|     }
345| 
346|   /* Enough space in output buffer.  */
347|   if ((MIN_NEEDED_OUTPUT != 1 && outptr + MIN_NEEDED_OUTPUT > outend)
348|       || (MIN_NEEDED_OUTPUT == 1 && outptr >= outend))
349|     /* Overflow in the output buffer.  */
350|     return __GCONV_FULL_OUTPUT;
351| 
352|   /*  Now add characters from the normal input buffer.  */
353|   if (inlen >= MAX_NEEDED_INPUT || inptr >= inend)
354|     /* Avoid a -Wstringop-overflow= warning when this loop is
355|        unrolled.  The compiler cannot otherwise see that this is
356|        unreachable because it depends on (state->__count & 7) not
357|        being too large after a previous conversion step.
358|        Starting with GCC 12, we also have mark the inptr >= inend
359|        case as unreachable to omit the warning.  Note that this SINGLE
360|        function is only used to implement the mb*towc*() or wc*tomb*()
361|        functions.  Those functions use inptr and inend pointing to a
362|        variable on stack, compute the inend pointer or explicitly check
363|        the arguments which always leads to inptr < inend.  */
364|     __builtin_unreachable ();
365|   do
366|     bytebuf[inlen++] = *inptr++;
367|   while (inlen < MAX_NEEDED_INPUT && inptr < inend);
368| 
369|   inptr = bytebuf;
370|   inend = &bytebuf[inlen];
371| 
372|   do
373|     {
374|       BODY
375|     }
376|   while (0);
377| 
378|   /* Now we either have produced an output character and consumed all the
379|      bytes from the state and at least one more, or the character is still
380|      incomplete, or we have some other error (like illegal input character,
381|      no space in output buffer).  */
382|   if (__glibc_likely (inptr != bytebuf))
383|     {
384|       /* We found a new character.  */
385|       assert (inptr - bytebuf > (state->__count & 7));
386| 
387|       *inptrp += inptr - bytebuf - (state->__count & 7);
388|       *outptrp = outptr;
389| 
390|       result = __GCONV_OK;
391| 
392|       /* Clear the state buffer.  */
393| # ifdef CLEAR_STATE
394|       CLEAR_STATE;
395| # else
396|       state->__count &= ~7;
397| # endif
398|     }
399|   else if (result == __GCONV_INCOMPLETE_INPUT)
400|     {
401|       /* This can only happen if we have less than MAX_NEEDED_INPUT bytes
402| 	 available.  */
403|       assert (inend != &bytebuf[MAX_NEEDED_INPUT]);
404| 
405|       *inptrp += inend - bytebuf - (state->__count & 7);
406| # ifdef STORE_REST
407|       inptrp = &inptr;
408| 
409|       STORE_REST
410| # else
411|       /* We don''t have enough input for another complete input
412| 	 character.  */
413|       assert (inend - inptr > (state->__count & ~7));
414|       assert (inend - inptr <= sizeof (state->__value.__wchb));
415|       state->__count = (state->__count & ~7) | (inend - inptr);
416|       for (inlen = 0; inlen < inend - inptr; inlen++)
417| 	state->__value.__wchb[inlen] = inptr[inlen];
418|       inptr = inend;
419| # endif
420|     }
421| 
422|   return result;
423| }
424| # undef SINGLE
425| # undef SINGLE2
426| 
427| 
428| # ifdef ONEBYTE_BODY
429| /* Define the shortcut function for btowc.  */
430| static wint_t
431| gconv_btowc (struct __gconv_step *step, unsigned char c)
432|   ONEBYTE_BODY
433| #  define FROM_ONEBYTE gconv_btowc
434| # endif
435| 
436| #endif
437| 
438| /* We remove the macro definitions so that we can include this file again
439|    for the definition of another function.  */
440| #undef MIN_NEEDED_INPUT
441| #undef MAX_NEEDED_INPUT
442| #undef MIN_NEEDED_OUTPUT
443| #undef MAX_NEEDED_OUTPUT
444| #undef LOOPFCT
445| #undef BODY
446| #undef LOOPFCT
447| #undef EXTRA_LOOP_DECLS
448| #undef INIT_PARAMS
449| #undef UPDATE_PARAMS
450| #undef REINIT_PARAMS
451| #undef ONEBYTE_BODY
452| #undef UNPACK_BYTES
453| #undef CLEAR_STATE
454| #undef LOOP_NEED_STATE
455| #undef LOOP_NEED_FLAGS
456| #undef LOOP_NEED_DATA


*** Examples ***
', '2025-11-17 21:39:07.118807');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (415, 102, 'def18', 'UNINIT', 'glibc-2.39/elf/dl-load.c:2015: skipped_decl: Jumping over declaration of "found_other_class".
glibc-2.39/elf/dl-load.c:2238: uninit_use: Using uninitialized value "found_other_class".
# 2236|   	  return l;
# 2237|   	}
# 2238|->       else if (found_other_class)
# 2239|   	_dl_signal_error (0, name, NULL,
# 2240|   			  ELFW(CLASS) == ELFCLASS32', 'FALSE POSITIVE', 'Variable `found_other_class` is explicitly declared and initialized as `false` on line 2015, within the same scope as its usage on line 2238, with no intervening unconditional modifications, ensuring it is not uninitialized when used.', 'The variable `found_other_class` is declared and initialized on line 2015 as `bool found_other_class = false;`, which is within the same scope as its usage on line 2238.

There are no intervening assignments or modifications to `found_other_class` between its declaration (line 2015) and its usage (line 2238) that are not conditional on `fd` being -1 or other previously checked conditions, which would imply a different execution path.

The `skipped_decl` warning at line 2015 is a red herring in this context, as it merely indicates the analysis tool''s flow analysis might have temporarily ''skipped'' over the declaration, but the declaration is indeed in scope and initializes the variable.

The code''s explicit initialization of `found_other_class` to `false` at declaration ensures it is not uninitialized when used in the `else if` condition on line 2238, regardless of the execution path leading up to that point.

No syntax issues are identified in the reported finding that would necessitate a TRUE POSITIVE conclusion based on that criterion alone.', NULL, 0.0000, '*** Source Code Context ***

code of elf/dl-load.c file:
1945| struct link_map *
1946| _dl_map_object (struct link_map *loader, const char *name,
1947| 		int type, int trace_mode, int mode, Lmid_t nsid)
1948| {
1949|   int fd;
1950|   const char *origname = NULL;
1951|   char *realname;
1952|   char *name_copy;
1953|   struct link_map *l;
1954|   struct filebuf fb;
1955| 
1956|   assert (nsid >= 0);
1957|   assert (nsid < GL(dl_nns));
1958| 
1959|   /* Look for this name among those already loaded.  */
1960|   for (l = GL(dl_ns)[nsid]._ns_loaded; l; l = l->l_next)
1961|     {
1962|       /* If the requested name matches the soname of a loaded object,
1963| 	 use that object.  Elide this check for names that have not
1964| 	 yet been opened.  */
1965|       if (__glibc_unlikely ((l->l_faked | l->l_removed) != 0))
1966| 	continue;
1967|       if (!_dl_name_match_p (name, l))
1968| 	{
1969| 	  const char *soname;
1970| 
1971| 	  if (__glibc_likely (l->l_soname_added)
1972| 	      || l->l_info[DT_SONAME] == NULL)
1973| 	    continue;
1974| 
1975| 	  soname = ((const char *) D_PTR (l, l_info[DT_STRTAB])
1976| 		    + l->l_info[DT_SONAME]->d_un.d_val);
1977| 	  if (strcmp (name, soname) != 0)
1978| 	    continue;
1979| 
1980| 	  /* We have a match on a new name -- cache it.  */
1981| 	  add_name_to_object (l, soname);
1982| 	  l->l_soname_added = 1;
1983| 	}
1984| 
1985|       /* We have a match.  */
1986|       return l;
1987|     }
1988| 
1989|   /* Display information if we are debugging.  */
1990|   if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_FILES)
1991|       && loader != NULL)
1992|     _dl_debug_printf ((mode & __RTLD_CALLMAP) == 0
1993| 		      ? "
file=%s [%lu];  needed by %s [%lu]
"
1994| 		      : "
file=%s [%lu];  dynamically loaded by %s [%lu]
",
1995| 		      name, nsid, DSO_FILENAME (loader->l_name), loader->l_ns);
1996| 
1997| #ifdef SHARED
1998|   /* Give the auditing libraries a chance to change the name before we
1999|      try anything.  */
2000|   if (__glibc_unlikely (GLRO(dl_naudit) > 0))
2001|     {
2002|       const char *before = name;
2003|       name = _dl_audit_objsearch (name, loader, LA_SER_ORIG);
2004|       if (name == NULL)
2005| 	{
2006| 	  fd = -1;
2007| 	  goto no_file;
2008| 	}
2009|       if (before != name && strcmp (before, name) != 0)
2010| 	origname = before;
2011|     }
2012| #endif
2013| 
2014|   /* Will be true if we found a DSO which is of the other ELF class.  */
2015|   bool found_other_class = false;
2016| 
2017|   if (strchr (name, ''/'') == NULL)
2018|     {
2019|       /* Search for NAME in several places.  */
2020| 
2021|       size_t namelen = strlen (name) + 1;
2022| 
2023|       if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
2024| 	_dl_debug_printf ("find library=%s [%lu]; searching
", name, nsid);
2025| 
2026|       fd = -1;
2027| 
2028|       /* When the object has the RUNPATH information we don''t use any
2029| 	 RPATHs.  */
2030|       if (loader == NULL || loader->l_info[DT_RUNPATH] == NULL)
2031| 	{
2032| 	  /* This is the executable''s map (if there is one).  Make sure that
2033| 	     we do not look at it twice.  */
2034| 	  struct link_map *main_map = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
2035| 	  bool did_main_map = false;
2036| 
2037| 	  /* First try the DT_RPATH of the dependent object that caused NAME
2038| 	     to be loaded.  Then that object''s dependent, and on up.  */
2039| 	  for (l = loader; l; l = l->l_loader)
2040| 	    if (cache_rpath (l, &l->l_rpath_dirs, DT_RPATH, "RPATH"))
2041| 	      {
2042| 		fd = open_path (name, namelen, mode,
2043| 				&l->l_rpath_dirs,
2044| 				&realname, &fb, loader, LA_SER_RUNPATH,
2045| 				&found_other_class);
2046| 		if (fd != -1)
2047| 		  break;
2048| 
2049| 		did_main_map |= l == main_map;
2050| 	      }
2051| 
2052| 	  /* If dynamically linked, try the DT_RPATH of the executable
2053| 	     itself.  NB: we do this for lookups in any namespace.  */
2054| 	  if (fd == -1 && !did_main_map
2055| 	      && main_map != NULL && main_map->l_type != lt_loaded
2056| 	      && cache_rpath (main_map, &main_map->l_rpath_dirs, DT_RPATH,
2057| 			      "RPATH"))
2058| 	    fd = open_path (name, namelen, mode,
2059| 			    &main_map->l_rpath_dirs,
2060| 			    &realname, &fb, loader ?: main_map, LA_SER_RUNPATH,
2061| 			    &found_other_class);
2062| 
2063| 	  /* Also try DT_RUNPATH in the executable for LD_AUDIT dlopen
2064| 	     call.  */
2065| 	  if (__glibc_unlikely (mode & __RTLD_AUDIT)
2066| 	      && fd == -1 && !did_main_map
2067| 	      && main_map != NULL && main_map->l_type != lt_loaded)
2068| 	    {
2069| 	      struct r_search_path_struct l_rpath_dirs;
2070| 	      l_rpath_dirs.dirs = NULL;
2071| 	      if (cache_rpath (main_map, &l_rpath_dirs,
2072| 			       DT_RUNPATH, "RUNPATH"))
2073| 		fd = open_path (name, namelen, mode, &l_rpath_dirs,
2074| 				&realname, &fb, loader ?: main_map,
2075| 				LA_SER_RUNPATH, &found_other_class);
2076| 	    }
2077| 	}
2078| 
2079|       /* Try the LD_LIBRARY_PATH environment variable.  */
2080|       if (fd == -1 && __rtld_env_path_list.dirs != (void *) -1)
2081| 	fd = open_path (name, namelen, mode, &__rtld_env_path_list,
2082| 			&realname, &fb,
2083| 			loader ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded,
2084| 			LA_SER_LIBPATH, &found_other_class);
2085| 
2086|       /* Look at the RUNPATH information for this binary.  */
2087|       if (fd == -1 && loader != NULL
2088| 	  && cache_rpath (loader, &loader->l_runpath_dirs,
2089| 			  DT_RUNPATH, "RUNPATH"))
2090| 	fd = open_path (name, namelen, mode,
2091| 			&loader->l_runpath_dirs, &realname, &fb, loader,
2092| 			LA_SER_RUNPATH, &found_other_class);
2093| 
2094|       if (fd == -1)
2095|         {
2096|           realname = _dl_sysdep_open_object (name, namelen, &fd);
2097|           if (realname != NULL)
2098|             {
2099|               fd = open_verify (realname, fd,
2100|                                 &fb, loader ?: GL(dl_ns)[nsid]._ns_loaded,
2101|                                 LA_SER_CONFIG, mode, &found_other_class,
2102|                                 false);
2103|               if (fd == -1)
2104|                 free (realname);
2105|             }
2106|         }
2107| 
2108| #ifdef USE_LDCONFIG
2109|       if (fd == -1
2110| 	  && (__glibc_likely ((mode & __RTLD_SECURE) == 0)
2111| 	      || ! __libc_enable_secure)
2112| 	  && __glibc_likely (GLRO(dl_inhibit_cache) == 0))
2113| 	{
2114| 	  /* Check the list of libraries in the file /etc/ld.so.cache,
2115| 	     for compatibility with Linux''s ldconfig program.  */
2116| 	  char *cached = _dl_load_cache_lookup (name);
2117| 
2118| 	  if (cached != NULL)
2119| 	    {
2120| 	      // XXX Correct to unconditionally default to namespace 0?
2121| 	      l = (loader
2122| 		   ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded
2123| # ifdef SHARED
2124| 		   ?: &GL(dl_rtld_map)
2125| # endif
2126| 		  );
2127| 
2128| 	      /* If the loader has the DF_1_NODEFLIB flag set we must not
2129| 		 use a cache entry from any of these directories.  */
2130| 	      if (__glibc_unlikely (l->l_flags_1 & DF_1_NODEFLIB))
2131| 		{
2132| 		  const char *dirp = system_dirs;
2133| 		  unsigned int cnt = 0;
2134| 
2135| 		  do
2136| 		    {
2137| 		      if (memcmp (cached, dirp, system_dirs_len[cnt]) == 0)
2138| 			{
2139| 			  /* The prefix matches.  Don''t use the entry.  */
2140| 			  free (cached);
2141| 			  cached = NULL;
2142| 			  break;
2143| 			}
2144| 
2145| 		      dirp += system_dirs_len[cnt] + 1;
2146| 		      ++cnt;
2147| 		    }
2148| 		  while (cnt < nsystem_dirs_len);
2149| 		}
2150| 
2151| 	      if (cached != NULL)
2152| 		{
2153| 		  fd = open_verify (cached, -1,
2154| 				    &fb, loader ?: GL(dl_ns)[nsid]._ns_loaded,
2155| 				    LA_SER_CONFIG, mode, &found_other_class,
2156| 				    false);
2157| 		  if (__glibc_likely (fd != -1))
2158| 		    realname = cached;
2159| 		  else
2160| 		    free (cached);
2161| 		}
2162| 	    }
2163| 	}
2164| #endif
2165| 
2166|       /* Finally, try the default path.  */
2167|       if (fd == -1
2168| 	  && ((l = loader ?: GL(dl_ns)[nsid]._ns_loaded) == NULL
2169| 	      || __glibc_likely (!(l->l_flags_1 & DF_1_NODEFLIB)))
2170| 	  && __rtld_search_dirs.dirs != (void *) -1)
2171| 	fd = open_path (name, namelen, mode, &__rtld_search_dirs,
2172| 			&realname, &fb, l, LA_SER_DEFAULT, &found_other_class);
2173| 
2174|       /* Add another newline when we are tracing the library loading.  */
2175|       if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
2176| 	_dl_debug_printf ("
");
2177|     }
2178|   else
2179|     {
2180|       /* The path may contain dynamic string tokens.  */
2181|       realname = (loader
2182| 		  ? expand_dynamic_string_token (loader, name)
2183| 		  : __strdup (name));
2184|       if (realname == NULL)
2185| 	fd = -1;
2186|       else
2187| 	{
2188| 	  fd = open_verify (realname, -1, &fb,
2189| 			    loader ?: GL(dl_ns)[nsid]._ns_loaded, 0, mode,
2190| 			    &found_other_class, true);
2191| 	  if (__glibc_unlikely (fd == -1))
2192| 	    free (realname);
2193| 	}
2194|     }
2195| 
2196| #ifdef SHARED
2197|  no_file:
2198| #endif
2199|   /* In case the LOADER information has only been provided to get to
2200|      the appropriate RUNPATH/RPATH information we do not need it
2201|      anymore.  */
2202|   if (mode & __RTLD_CALLMAP)
2203|     loader = NULL;
2204| 
2205|   if (__glibc_unlikely (fd == -1))
2206|     {
2207|       if (trace_mode)
2208| 	{
2209| 	  /* We haven''t found an appropriate library.  But since we
2210| 	     are only interested in the list of libraries this isn''t
2211| 	     so severe.  Fake an entry with all the information we
2212| 	     have.  */
2213| 	  static const Elf_Symndx dummy_bucket = STN_UNDEF;
2214| 
2215| 	  /* Allocate a new object map.  */
2216| 	  if ((name_copy = __strdup (name)) == NULL
2217| 	      || (l = _dl_new_object (name_copy, name, type, loader,
2218| 				      mode, nsid)) == NULL)
2219| 	    {
2220| 	      free (name_copy);
2221| 	      _dl_signal_error (ENOMEM, name, NULL,
2222| 				N_("cannot create shared object descriptor"));
2223| 	    }
2224| 	  /* Signal that this is a faked entry.  */
2225| 	  l->l_faked = 1;
2226| 	  /* Since the descriptor is initialized with zero we do not
2227| 	     have do this here.
2228| 	  l->l_reserved = 0; */
2229| 	  l->l_buckets = &dummy_bucket;
2230| 	  l->l_nbuckets = 1;
2231| 	  l->l_relocated = 1;
2232| 
2233| 	  /* Enter the object in the object list.  */
2234| 	  _dl_add_to_namespace_list (l, nsid);
2235| 
2236| 	  return l;
2237| 	}
2238|       else if (found_other_class)
2239| 	_dl_signal_error (0, name, NULL,
2240| 			  ELFW(CLASS) == ELFCLASS32
2241| 			  ? N_("wrong ELF class: ELFCLASS64")
2242| 			  : N_("wrong ELF class: ELFCLASS32"));
2243|       else
2244| 	_dl_signal_error (errno, name, NULL,
2245| 			  N_("cannot open shared object file"));
2246|     }
2247| 
2248|   void *stack_end = __libc_stack_end;
2249|   return _dl_map_object_from_fd (name, origname, fd, &fb, realname, loader,
2250| 				 type, mode, &stack_end, nsid);
2251| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|   	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> 	      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|   	    }
#  447|   	  break;
(Example-1) Reason Marked as False Positive:
declaration is in scope for all jumps to print_err, and fmt is set prior to each of those jumps

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|
(Example-2) Reason Marked as False Positive:
yylex initializes yylval around line 1182

', '2025-11-17 21:39:07.118807');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (416, 102, 'def19', 'UNINIT', 'glibc-2.39/nss/getaddrinfo.c:1875: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:1883: uninit_use: Using uninitialized value "endp".
# 1881|       *cp++ = ''\0'';
# 1882|     *pos = cp;
# 1883|->   if (inet_pton (AF_INET6, val1, &prefix)
# 1884|         && (cp == NULL
# 1885|   	  || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX', 'TRUE POSITIVE', 'Variable `endp` is declared without an initializer (line 1875) and, in the execution path where `cp == NULL`, its use in the conditional statement (line 1885) occurs before potential initialization by `strtoul()`, due to short-circuit evaluation, thus constituting a vulnerability.', 'The variable `endp` is declared without an initializer on line 1875, as reported.

The first potential use of `endp` is on line 1885 within the `strtoul` function call, which is conditional upon the execution path reaching this point.

However, there is no explicit initialization of `endp` before its potential use in `strtoul(cp, &endp, 10)` on line 1885, if the condition `cp != NULL` is true.

Although `strtoul` would initialize `endp` if executed, the issue arises if the condition `cp == NULL` is true, potentially bypassing the initialization of `endp` by `strtoul`.

In the case where `cp == NULL`, the value of `endp` remains uninitialized when the logical OR (`||`) operation is evaluated, because the second operand of the OR is not evaluated if the first operand is true (short-circuit evaluation).

Since there''s a plausible execution path (when `cp == NULL`) where `endp` is not initialized before its use in the conditional statement, this constitutes a vulnerability as described by the CVE (using an uninitialized value).

Unlike Example-1, where `endp` is initialized by `strtoul()` regardless of the conditional path, the provided code snippet does not guarantee initialization of `endp` in all execution paths leading to its use.', NULL, 0.0000, '*** Source Code Context ***

code of nss/getaddrinfo.c file:
1868| static bool
1869| add_prefixlist (struct prefixlist **listp, size_t *lenp, bool *nullbitsp,
1870| 		char *val1, char *val2, char **pos)
1871| {
1872|   struct in6_addr prefix;
1873|   unsigned long int bits;
1874|   unsigned long int val;
1875|   char *endp;
1876| 
1877|   bits = 128;
1878|   __set_errno (0);
1879|   char *cp = strchr (val1, ''/'');
1880|   if (cp != NULL)
1881|     *cp++ = ''\0'';
1882|   *pos = cp;
1883|   if (inet_pton (AF_INET6, val1, &prefix)
1884|       && (cp == NULL
1885| 	  || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
1886| 	  || errno != ERANGE)
1887|       && *endp == ''\0''
1888|       && bits <= 128
1889|       && ((val = strtoul (val2, &endp, 10)) != ULONG_MAX
1890| 	  || errno != ERANGE)
1891|       && *endp == ''\0''
1892|       && val <= INT_MAX)
1893|     {
1894|       struct prefixlist *newp = malloc (sizeof (*newp));
1895|       if (newp == NULL)
1896| 	return false;
1897| 
1898|       memcpy (&newp->entry.prefix, &prefix, sizeof (prefix));
1899|       newp->entry.bits = bits;
1900|       newp->entry.val = val;
1901|       newp->next = *listp;
1902|       *listp = newp;
1903|       ++*lenp;
1904|       *nullbitsp |= bits == 0;
1905|     }
1906|   return true;
1907| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/nss/getaddrinfo.c:2034: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:2066: uninit_use: Using uninitialized value "endp".
# 2064|   		    }
# 2065|   		}
# 2066|-> 	      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
# 2067|   		       && (cp == NULL
# 2068|   			   || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
(Example-1) Reason Marked as False Positive:
endp is initialized by strtoul() on line 2068

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/libio/obprintf.c:82: var_decl: Declaring variable "buf" without initializer.
glibc-2.39/libio/obprintf.c:99: uninit_use: Using uninitialized value "buf.ch".
#   97|     if (buf.base.write_ptr == &buf.ch + 1)
#   98|       /* buf.ch is in use.  Put it into the obstack.  */
#   99|->     obstack_1grow (buf.obstack, buf.ch);
#  100|     else if (buf.base.write_ptr != &buf.ch)
#  101|       /* Shrink the buffer to the space we really currently need.  */
(Example-2) Reason Marked as False Positive:
ch is used as a temporary buffer, set up by __printf_buffer_flush_obstack, and protected by write_base and write_ptr.  It will only be read if it''s been set up as a queue and the queue written to.

', '2025-11-17 21:39:07.118808');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (417, 102, 'def20', 'UNINIT', 'glibc-2.39/nss/getaddrinfo.c:2034: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:2044: uninit_use: Using uninitialized value "endp".
# 2042|   		{
# 2043|   		  bits = 128;
# 2044|-> 		  if (IN6_IS_ADDR_V4MAPPED (&prefix)
# 2045|   		      && (cp == NULL
# 2046|   			  || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX', 'FALSE POSITIVE', 'Variable ''endp'' is either initialized by ''strtoul'' on line 2046 when ''cp'' is not NULL, or its potential uninitialized use is avoided due to short-circuiting in the conditional statement when ''cp'' is NULL (lines 2045-2046), mitigating the reported vulnerability.', 'The variable ''endp'' is declared without an initializer on line 2034, but this alone does not necessarily lead to a vulnerability.

The reported ''uninit_use'' on line 2044 is within a conditional statement that checks if ''cp'' is NULL before using ''endp''.

If ''cp'' is NOT NULL, ''endp'' is initialized by the ''strtoul'' function on line 2046, which takes ''&endp'' as an argument, ensuring ''endp'' is updated with the end pointer of the converted string.

The crucial condition is when ''cp'' IS NULL. In this case, ''endp'' is not explicitly initialized before use. However, examining the logic:

  * If ''cp'' is NULL, the expression ''(cp == NULL || ...)'' will short-circuit to TRUE without evaluating the ''strtoul'' part, due to the OR (||) operator''s behavior in C.

  * This means ''endp'' is not used in the ''strtoul'' function when ''cp'' is NULL, avoiding the potential uninitialized use vulnerability in this specific execution path.

Given the conditional logic and the behavior of ''strtoul'' when ''cp'' is not NULL, there is no direct evidence that ''endp'' is used in an uninitialized state within the provided code snippet.', NULL, 0.0000, '*** Source Code Context ***

code of nss/getaddrinfo.c file:
1929| static void
1930| gaiconf_init (void)
1931| {
1932|   struct prefixlist *labellist = NULL;
1933|   size_t nlabellist = 0;
1934|   bool labellist_nullbits = false;
1935|   struct prefixlist *precedencelist = NULL;
1936|   size_t nprecedencelist = 0;
1937|   bool precedencelist_nullbits = false;
1938|   struct scopelist *scopelist =  NULL;
1939|   size_t nscopelist = 0;
1940|   bool scopelist_nullbits = false;
1941| 
1942|   FILE *fp = fopen (GAICONF_FNAME, "rce");
1943|   if (fp == NULL)
1944|     goto no_file;
1945| 
1946|   struct __stat64_t64 st;
1947|   if (__fstat64_time64 (fileno (fp), &st) != 0)
1948|     {
1949|       fclose (fp);
1950|       goto no_file;
1951|     }
1952| 
1953|   char *line = NULL;
1954|   size_t linelen = 0;
1955| 
1956|   __fsetlocking (fp, FSETLOCKING_BYCALLER);
1957| 
1958|   while (!feof_unlocked (fp))
1959|     {
1960|       ssize_t n = __getline (&line, &linelen, fp);
1961|       if (n <= 0)
1962| 	break;
1963| 
1964|       /* Handle comments.  No escaping possible so this is easy.  */
1965|       char *cp = strchr (line, ''#'');
1966|       if (cp != NULL)
1967| 	*cp = ''\0'';
1968| 
1969|       cp = line;
1970|       while (isspace (*cp))
1971| 	++cp;
1972| 
1973|       char *cmd = cp;
1974|       while (*cp != ''\0'' && !isspace (*cp))
1975| 	++cp;
1976|       size_t cmdlen = cp - cmd;
1977| 
1978|       if (*cp != ''\0'')
1979| 	*cp++ = ''\0'';
1980|       while (isspace (*cp))
1981| 	++cp;
1982| 
1983|       char *val1 = cp;
1984|       while (*cp != ''\0'' && !isspace (*cp))
1985| 	++cp;
1986|       size_t val1len = cp - cmd;
1987| 
1988|       /* We always need at least two values.  */
1989|       if (val1len == 0)
1990| 	continue;
1991| 
1992|       if (*cp != ''\0'')
1993| 	*cp++ = ''\0'';
1994|       while (isspace (*cp))
1995| 	++cp;
1996| 
1997|       char *val2 = cp;
1998|       while (*cp != ''\0'' && !isspace (*cp))
1999| 	++cp;
2000| 
2001|       /*  Ignore the rest of the line.  */
2002|       *cp = ''\0'';
2003| 
2004|       switch (cmdlen)
2005| 	{
2006| 	case 5:
2007| 	  if (strcmp (cmd, "label") == 0)
2008| 	    {
2009| 	      if (!add_prefixlist (&labellist, &nlabellist,
2010| 				   &labellist_nullbits, val1, val2, &cp))
2011| 		{
2012| 		  free (line);
2013| 		  fclose (fp);
2014| 		  goto no_file;
2015| 		}
2016| 	    }
2017| 	  break;
2018| 
2019| 	case 6:
2020| 	  if (strcmp (cmd, "reload") == 0)
2021| 	    {
2022| 	      gaiconf_reload_flag = strcmp (val1, "yes") == 0;
2023| 	      if (gaiconf_reload_flag)
2024| 		gaiconf_reload_flag_ever_set = 1;
2025| 	    }
2026| 	  break;
2027| 
2028| 	case 7:
2029| 	  if (strcmp (cmd, "scopev4") == 0)
2030| 	    {
2031| 	      struct in6_addr prefix;
2032| 	      unsigned long int bits;
2033| 	      unsigned long int val;
2034| 	      char *endp;
2035| 
2036| 	      bits = 32;
2037| 	      __set_errno (0);
2038| 	      cp = strchr (val1, ''/'');
2039| 	      if (cp != NULL)
2040| 		*cp++ = ''\0'';
2041| 	      if (inet_pton (AF_INET6, val1, &prefix))
2042| 		{
2043| 		  bits = 128;
2044| 		  if (IN6_IS_ADDR_V4MAPPED (&prefix)
2045| 		      && (cp == NULL
2046| 			  || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
2047| 			  || errno != ERANGE)
2048| 		      && *endp == ''\0''
2049| 		      && bits >= 96
2050| 		      && bits <= 128
2051| 		      && ((val = strtoul (val2, &endp, 10)) != ULONG_MAX
2052| 			  || errno != ERANGE)
2053| 		      && *endp == ''\0''
2054| 		      && val <= INT_MAX)
2055| 		    {
2056| 		      if (!add_scopelist (&scopelist, &nscopelist,
2057| 					  &scopelist_nullbits, &prefix,
2058| 					  bits, val))
2059| 			{
2060| 			  free (line);
2061| 			  fclose (fp);
2062| 			  goto no_file;
2063| 			}
2064| 		    }
2065| 		}
2066| 	      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
2067| 		       && (cp == NULL
2068| 			   || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
2069| 			   || errno != ERANGE)
2070| 		       && *endp == ''\0''
2071| 		       && bits <= 32
2072| 		       && ((val = strtoul (val2, &endp, 10)) != ULONG_MAX
2073| 			   || errno != ERANGE)
2074| 		       && *endp == ''\0''
2075| 		       && val <= INT_MAX)
2076| 		{
2077| 		  if (!add_scopelist (&scopelist, &nscopelist,
2078| 				      &scopelist_nullbits, &prefix,
2079| 				      bits + 96, val))
2080| 		    {
2081| 		      free (line);
2082| 		      fclose (fp);
2083| 		      goto no_file;
2084| 		    }
2085| 		}
2086| 	    }
2087| 	  break;
2088| 
2089| 	case 10:
2090| 	  if (strcmp (cmd, "precedence") == 0)
2091| 	    {
2092| 	      if (!add_prefixlist (&precedencelist, &nprecedencelist,
2093| 				   &precedencelist_nullbits, val1, val2,
2094| 				   &cp))
2095| 		{
2096| 		  free (line);
2097| 		  fclose (fp);
2098| 		  goto no_file;
2099| 		}
2100| 	    }
2101| 	  break;
2102| 	}
2103|     }
2104| 
2105|   free (line);
2106| 
2107|   fclose (fp);
2108| 
2109|   /* Create the array for the labels.  */
2110|   struct prefixentry *new_labels;
2111|   if (nlabellist > 0)
2112|     {
2113|       if (!labellist_nullbits)
2114| 	++nlabellist;
2115|       new_labels = malloc (nlabellist * sizeof (*new_labels));
2116|       if (new_labels == NULL)
2117| 	goto no_file;
2118| 
2119|       int i = nlabellist;
2120|       if (!labellist_nullbits)
2121| 	{
2122| 	  --i;
2123| 	  memset (&new_labels[i].prefix, ''\0'', sizeof (struct in6_addr));
2124| 	  new_labels[i].bits = 0;
2125| 	  new_labels[i].val = 1;
2126| 	}
2127| 
2128|       struct prefixlist *l = labellist;
2129|       while (i-- > 0)
2130| 	{
2131| 	  new_labels[i] = l->entry;
2132| 	  l = l->next;
2133| 	}
2134|       free_prefixlist (labellist);
2135|       labellist = NULL;
2136| 
2137|       /* Sort the entries so that the most specific ones are at
2138| 	 the beginning.  */
2139|       qsort (new_labels, nlabellist, sizeof (*new_labels), prefixcmp);
2140|     }
2141|   else
2142|     new_labels = (struct prefixentry *) default_labels;
2143| 
2144|   struct prefixentry *new_precedence;
2145|   if (nprecedencelist > 0)
2146|     {
2147|       if (!precedencelist_nullbits)
2148| 	++nprecedencelist;
2149|       new_precedence = malloc (nprecedencelist * sizeof (*new_precedence));
2150|       if (new_precedence == NULL)
2151| 	{
2152| 	  if (new_labels != default_labels)
2153| 	    free (new_labels);
2154| 	  goto no_file;
2155| 	}
2156| 
2157|       int i = nprecedencelist;
2158|       if (!precedencelist_nullbits)
2159| 	{
2160| 	  --i;
2161| 	  memset (&new_precedence[i].prefix, ''\0'',
2162| 		  sizeof (struct in6_addr));
2163| 	  new_precedence[i].bits = 0;
2164| 	  new_precedence[i].val = 40;
2165| 	}
2166| 
2167|       struct prefixlist *l = precedencelist;
2168|       while (i-- > 0)
2169| 	{
2170| 	  new_precedence[i] = l->entry;
2171| 	  l = l->next;
2172| 	}
2173|       free_prefixlist (precedencelist);
2174|       precedencelist = NULL;
2175| 
2176|       /* Sort the entries so that the most specific ones are at
2177| 	 the beginning.  */
2178|       qsort (new_precedence, nprecedencelist, sizeof (*new_precedence),
2179| 	     prefixcmp);
2180|     }
2181|   else
2182|     new_precedence = (struct prefixentry *) default_precedence;
2183| 
2184|   struct scopeentry *new_scopes;
2185|   if (nscopelist > 0)
2186|     {
2187|       if (!scopelist_nullbits)
2188| 	++nscopelist;
2189|       new_scopes = malloc (nscopelist * sizeof (*new_scopes));
2190|       if (new_scopes == NULL)
2191| 	{
2192| 	  if (new_labels != default_labels)
2193| 	    free (new_labels);
2194| 	  if (new_precedence != default_precedence)
2195| 	    free (new_precedence);
2196| 	  goto no_file;
2197| 	}
2198| 
2199|       int i = nscopelist;
2200|       if (!scopelist_nullbits)
2201| 	{
2202| 	  --i;
2203| 	  new_scopes[i].addr32 = 0;
2204| 	  new_scopes[i].netmask = 0;
2205| 	  new_scopes[i].scope = 14;
2206| 	}
2207| 
2208|       struct scopelist *l = scopelist;
2209|       while (i-- > 0)
2210| 	{
2211| 	  new_scopes[i] = l->entry;
2212| 	  l = l->next;
2213| 	}
2214|       free_scopelist (scopelist);
2215| 
2216|       /* Sort the entries so that the most specific ones are at
2217| 	 the beginning.  */
2218|       qsort (new_scopes, nscopelist, sizeof (*new_scopes),
2219| 	     scopecmp);
2220|     }
2221|   else
2222|     new_scopes = (struct scopeentry *) default_scopes;
2223| 
2224|   /* Now we are ready to replace the values.  */
2225|   const struct prefixentry *old = labels;
2226|   labels = new_labels;
2227|   if (old != default_labels)
2228|     free ((void *) old);
2229| 
2230|   old = precedence;
2231|   precedence = new_precedence;
2232|   if (old != default_precedence)
2233|     free ((void *) old);
2234| 
2235|   const struct scopeentry *oldscope = scopes;
2236|   scopes = new_scopes;
2237|   if (oldscope != default_scopes)
2238|     free ((void *) oldscope);
2239| 
2240|   save_gaiconf_mtime (&st);
2241|   return;
2242| 
2243| no_file:
2244|   free_prefixlist (labellist);
2245|   free_prefixlist (precedencelist);
2246|   free_scopelist (scopelist);
2247| 
2248|   /* If we previously read the file but it is gone now, free the old data and
2249|      use the builtin one.  Leave the reload flag alone.  */
2250|   __libc_getaddrinfo_freemem ();
2251| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/nss/getaddrinfo.c:2034: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:2066: uninit_use: Using uninitialized value "endp".
# 2064|   		    }
# 2065|   		}
# 2066|-> 	      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
# 2067|   		       && (cp == NULL
# 2068|   			   || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
(Example-1) Reason Marked as False Positive:
endp is initialized by strtoul() on line 2068

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   	  waitlist->counter = total;
#  173|-> 	  waitlist->sigev = *sig;
#  174|   	}
#  175|       }
(Example-2) Reason Marked as False Positive:
defsigev.sigev_notify = SIGEV_NONE prevents access to the uninitialized portions

', '2025-11-17 21:39:07.118808');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (418, 102, 'def21', 'UNINIT', 'glibc-2.39/posix/regcomp.c:1173: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regcomp.c:1173: assign: Assigning: "dfa->eclosures" = "(re_node_set *)malloc(dfa->nodes_alloc * 16UL)", which points to uninitialized data.
glibc-2.39/posix/regcomp.c:1205: uninit_use_in_call: Using uninitialized value "dfa->eclosures->nelem" when calling "calc_eclosure".
# 1203|     if (__glibc_unlikely (ret != REG_NOERROR))
# 1204|       return ret;
# 1205|->   ret = calc_eclosure (dfa);
# 1206|     if (__glibc_unlikely (ret != REG_NOERROR))
# 1207|       return ret;', 'TRUE POSITIVE', 'Uninitialized memory allocated for `dfa->eclosures` at line 1173 is used without explicit initialization at line 1205 in `calc_eclosure(dfa)`, directly correlating with the CVE''s described vulnerability of using uninitialized memory.', 'The CVE report explicitly states that `malloc` returns uninitialized memory at line 1173, which is then assigned to `dfa->eclosures`.

The code at line 1173, `dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);`, indeed allocates memory using `re_malloc` (which is likely a wrapper for `malloc`, given the context) without any subsequent initialization before its use.

At line 1205, `dfa->eclosures` is passed to `calc_eclosure(dfa)`, and the report specifically highlights `dfa->eclosures->nelem` as an uninitialized value being used within this call.

There is no explicit initialization of `dfa->eclosures` or its members (including `nelem`) between its allocation at line 1173 and its use at line 1205 in the provided code snippet.

The absence of explicit initialization for `dfa->eclosures` and its members before use in `calc_eclosure(dfa)` directly correlates with the vulnerability described in the CVE (using uninitialized memory).

Uncertainty about the internal implementation of `calc_eclosure(dfa)` does not negate the fact that uninitialized memory is being passed to it; without explicit initialization or a guarantee of initialization within `calc_eclosure`, this remains a vulnerability.

The provided examples (Example-1 and Example-2) of known false positives involve limiting access to allocated memory through indices (`fs->num`), which is not evident in the handling of `dfa->eclosures` in the reported CVE.', 'Conduct a comprehensive code review to verify the absence of any implicit or indirect initialization of `dfa->eclosures` or its members before its use at `regcomp.c:1205`.

Analyze all potential execution paths leading to `regcomp.c:1205` to ensure no initialization occurs via other means (e.g., through function calls not included in the provided snippet).

Investigate the implementation of `calc_eclosure(dfa)` to determine if it inherently handles or assumes initialized input, potentially mitigating the vulnerability.', 0.0000, '*** Source Code Context ***

code of posix/regcomp.c file:
1163| static reg_errcode_t
1164| analyze (regex_t *preg)
1165| {
1166|   re_dfa_t *dfa = preg->buffer;
1167|   reg_errcode_t ret;
1168| 
1169|   /* Allocate arrays.  */
1170|   dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);
1171|   dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);
1172|   dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);
1173|   dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);
1174|   if (__glibc_unlikely (dfa->nexts == NULL || dfa->org_indices == NULL
1175| 			|| dfa->edests == NULL || dfa->eclosures == NULL))
1176|     return REG_ESPACE;
1177| 
1178|   dfa->subexp_map = re_malloc (Idx, preg->re_nsub);
1179|   if (dfa->subexp_map != NULL)
1180|     {
1181|       Idx i;
1182|       for (i = 0; i < preg->re_nsub; i++)
1183| 	dfa->subexp_map[i] = i;
1184|       preorder (dfa->str_tree, optimize_subexps, dfa);
1185|       for (i = 0; i < preg->re_nsub; i++)
1186| 	if (dfa->subexp_map[i] != i)
1187| 	  break;
1188|       if (i == preg->re_nsub)
1189| 	{
1190| 	  re_free (dfa->subexp_map);
1191| 	  dfa->subexp_map = NULL;
1192| 	}
1193|     }
1194| 
1195|   ret = postorder (dfa->str_tree, lower_subexps, preg);
1196|   if (__glibc_unlikely (ret != REG_NOERROR))
1197|     return ret;
1198|   ret = postorder (dfa->str_tree, calc_first, dfa);
1199|   if (__glibc_unlikely (ret != REG_NOERROR))
1200|     return ret;
1201|   preorder (dfa->str_tree, calc_next, dfa);
1202|   ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);
1203|   if (__glibc_unlikely (ret != REG_NOERROR))
1204|     return ret;
1205|   ret = calc_eclosure (dfa);
1206|   if (__glibc_unlikely (ret != REG_NOERROR))
1207|     return ret;
1208| 
1209|   /* We only need this during the prune_impossible_nodes pass in regexec.c;
1210|      skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */
1211|   if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)
1212|       || dfa->nbackref)
1213|     {
1214|       dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);
1215|       if (__glibc_unlikely (dfa->inveclosures == NULL))
1216| 	return REG_ESPACE;
1217|       ret = calc_inveclosure (dfa);
1218|     }
1219| 
1220|   return ret;
1221| }

code of /shared-data/source/glibc-2.39/hurd/hurdmalloc.c file:
144| static struct free_list malloc_free_list[NBUCKETS];
145| 
146| /* Initialization just sets everything to zero, but might be necessary on a
code of /shared-data/source/glibc-2.39/posix/regcomp.c file:
56| static reg_errcode_t calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa,
57| 					 Idx node, bool root);

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }
(Example-1) Reason Marked as False Positive:
fs->num limits access to the stack; memory will not be accessed until it is initialized and num is incremented.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# 1427|   		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
# 1428|   		  {
# 1429|-> 		    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
# 1430|   					       prev_idx_match, &eps_via_nodes);
# 1431|   		    break;
(Example-2) Reason Marked as False Positive:
fs->num limits the amount of fs->stack that''s accessed to only those entries that are initialized via push_fail_stack()

', '2025-11-17 21:39:07.118808');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (419, 102, 'def22', 'UNINIT', 'glibc-2.39/posix/regcomp.c:1173: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regcomp.c:1173: assign: Assigning: "dfa->eclosures" = "(re_node_set *)malloc(dfa->nodes_alloc * 16UL)", which points to uninitialized data.
glibc-2.39/posix/regcomp.c:1217: uninit_use_in_call: Using uninitialized value "dfa->eclosures->elems" when calling "calc_inveclosure".
# 1215|         if (__glibc_unlikely (dfa->inveclosures == NULL))
# 1216|   	return REG_ESPACE;
# 1217|->       ret = calc_inveclosure (dfa);
# 1218|       }
# 1219|', 'TRUE POSITIVE', 'Uninitialized memory allocated for `dfa->eclosures` at `regcomp.c:1173` is directly used via `dfa->eclosures->elems` in `calc_inveclosure` at `regcomp.c:1217` without explicit initialization, correlating with the CVE''s description of using uninitialized data.', 'The code at `regcomp.c:1173` explicitly assigns the result of `malloc` to `dfa->eclosures` without initializing the allocated memory. This matches the CVE description of returning uninitialized memory.

The allocated memory (`dfa->eclosures`) is used without explicit initialization in the call to `calc_inveclosure` at `regcomp.c:1217`, specifically through the access of `dfa->eclosures->elems`. This directly correlates with the CVE''s description of using uninitialized data.

There is no explicit initialization of `dfa->eclosures` or its `elems` member between the allocation at `regcomp.c:1173` and its use at `regcomp.c:1217`. The code provided does not perform any operation that would initialize this memory before it is used.

Unlike the provided false positive examples (Example-1 and Example-2), where access to allocated memory is guarded by indices (`fs->num`) that ensure only initialized parts are accessed, no such guarding mechanism is evident in the provided code snippet for `dfa->eclosures`.

Given the direct allocation, lack of explicit initialization, and subsequent use of `dfa->eclosures->elems` in a function call, there is a clear, demonstrable link between the code''s behavior and the vulnerability described in the CVE, satisfying the criteria for a TRUE POSITIVE finding.', NULL, 0.0000, '*** Source Code Context ***

code of posix/regcomp.c file:
1163| static reg_errcode_t
1164| analyze (regex_t *preg)
1165| {
1166|   re_dfa_t *dfa = preg->buffer;
1167|   reg_errcode_t ret;
1168| 
1169|   /* Allocate arrays.  */
1170|   dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);
1171|   dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);
1172|   dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);
1173|   dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);
1174|   if (__glibc_unlikely (dfa->nexts == NULL || dfa->org_indices == NULL
1175| 			|| dfa->edests == NULL || dfa->eclosures == NULL))
1176|     return REG_ESPACE;
1177| 
1178|   dfa->subexp_map = re_malloc (Idx, preg->re_nsub);
1179|   if (dfa->subexp_map != NULL)
1180|     {
1181|       Idx i;
1182|       for (i = 0; i < preg->re_nsub; i++)
1183| 	dfa->subexp_map[i] = i;
1184|       preorder (dfa->str_tree, optimize_subexps, dfa);
1185|       for (i = 0; i < preg->re_nsub; i++)
1186| 	if (dfa->subexp_map[i] != i)
1187| 	  break;
1188|       if (i == preg->re_nsub)
1189| 	{
1190| 	  re_free (dfa->subexp_map);
1191| 	  dfa->subexp_map = NULL;
1192| 	}
1193|     }
1194| 
1195|   ret = postorder (dfa->str_tree, lower_subexps, preg);
1196|   if (__glibc_unlikely (ret != REG_NOERROR))
1197|     return ret;
1198|   ret = postorder (dfa->str_tree, calc_first, dfa);
1199|   if (__glibc_unlikely (ret != REG_NOERROR))
1200|     return ret;
1201|   preorder (dfa->str_tree, calc_next, dfa);
1202|   ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);
1203|   if (__glibc_unlikely (ret != REG_NOERROR))
1204|     return ret;
1205|   ret = calc_eclosure (dfa);
1206|   if (__glibc_unlikely (ret != REG_NOERROR))
1207|     return ret;
1208| 
1209|   /* We only need this during the prune_impossible_nodes pass in regexec.c;
1210|      skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */
1211|   if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)
1212|       || dfa->nbackref)
1213|     {
1214|       dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);
1215|       if (__glibc_unlikely (dfa->inveclosures == NULL))
1216| 	return REG_ESPACE;
1217|       ret = calc_inveclosure (dfa);
1218|     }
1219| 
1220|   return ret;
1221| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }
(Example-1) Reason Marked as False Positive:
fs->num limits access to the stack; memory will not be accessed until it is initialized and num is incremented.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# 1427|   		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
# 1428|   		  {
# 1429|-> 		    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
# 1430|   					       prev_idx_match, &eps_via_nodes);
# 1431|   		    break;
(Example-2) Reason Marked as False Positive:
fs->num limits the amount of fs->stack that''s accessed to only those entries that are initialized via push_fail_stack()

', '2025-11-17 21:39:07.118808');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (420, 102, 'def23', 'UNINIT', 'glibc-2.39/sysdeps/pthread/sem_open.c:41: var_decl: Declaring variable "result" without initializer.
glibc-2.39/sysdeps/pthread/sem_open.c:203: uninit_use: Using uninitialized value "result".
#  201|   
#  202|     /* Map the mmap error to the error we need.  */
#  203|->   if (MAP_FAILED != (void *) SEM_FAILED && result == MAP_FAILED)
#  204|       result = SEM_FAILED;
#  205|', 'FALSE POSITIVE', 'Multiple execution paths initialize ''result'' before its use at line 203, and the self-protective check at line 203 (`result == MAP_FAILED`) mitigates the risk of exploiting an uninitialized variable, making the reported vulnerability conditional and not unequivocally exploitable.', 'The variable ''result'' is declared without an initializer at line 41, but this alone does not necessarily lead to a vulnerability.

The reported use of an uninitialized value at line 203 is contingent upon the execution path reaching this point without ''result'' being initialized.

Upon examining the code, there are multiple execution paths that initialize ''result'' before line 203, making the uninitialized use conditional:

* Line 83: `result = __sem_check_add_mapping (name, fd, SEM_FAILED);` (when `(oflag & O_CREAT) == 0 || (oflag & O_EXCL) == 0`)

* Line 104: `result = SEM_FAILED;` (when `value > SEM_VALUE_MAX`)

* Line 132: `result = SEM_FAILED;` (when `__mktemp (tmpfname) == NULL`)

* Line 153: `result = SEM_FAILED;` (when opening the temporary file fails and `errno != EEXIST` or after `NRETRIES`)

* Line 175: `result = SEM_FAILED;` (after unlinking the temporary file, in case of an error)

Before reaching line 203, ''result'' is checked and potentially reassigned in the context of mmap operations (lines 164-167). If ''result'' is still uninitialized here, it implies none of the above initialization paths were executed, and the specific condition at line 203 (`MAP_FAILED != (void *) SEM_FAILED && result == MAP_FAILED`) is **self-protective**: it checks if ''result'' is exactly ''MAP_FAILED'' before potentially reassigning it to ''SEM_FAILED''.

Given the conditional nature of the uninitialized use and the protective check at line 203, there is no direct, unavoidable execution path from the declaration of ''result'' to its use that would unequivocally lead to the exploitation of an uninitialized variable vulnerability as described.', NULL, 0.0000, '*** Source Code Context ***

code of sysdeps/pthread/sem_open.c file:
37| sem_t *
38| __sem_open (const char *name, int oflag, ...)
39| {
40|   int fd;
41|   sem_t *result;
42| 
43|   /* Check that shared futexes are supported.  */
44|   int err = futex_supports_pshared (PTHREAD_PROCESS_SHARED);
45|   if (err != 0)
46|     {
47|       __set_errno (err);
48|       return SEM_FAILED;
49|     }
50| 
51|   struct shmdir_name dirname;
52|   int ret = __shm_get_name (&dirname, name, true);
53|   if (ret != 0)
54|     {
55|       __set_errno (ret);
56|       return SEM_FAILED;
57|     }
58| 
59|   /* Disable asynchronous cancellation.  */
60| #ifdef __libc_ptf_call
61|   int state;
62|   __libc_ptf_call (__pthread_setcancelstate,
63|                    (PTHREAD_CANCEL_DISABLE, &state), 0);
64| #endif
65| 
66|   /* If the semaphore object has to exist simply open it.  */
67|   if ((oflag & O_CREAT) == 0 || (oflag & O_EXCL) == 0)
68|     {
69|     try_again:
70|       fd = __open (dirname.name, (oflag & O_EXCL) | SEM_OPEN_FLAGS);
71| 
72|       if (fd == -1)
73| 	{
74| 	  /* If we are supposed to create the file try this next.  */
75| 	  if ((oflag & O_CREAT) != 0 && errno == ENOENT)
76| 	    goto try_create;
77| 
78| 	  /* Return.  errno is already set.  */
79| 	}
80|       else
81| 	/* Check whether we already have this semaphore mapped and
82| 	   create one if necessary.  */
83| 	result = __sem_check_add_mapping (name, fd, SEM_FAILED);
84|     }
85|   else
86|     {
87|       /* We have to open a temporary file first since it must have the
88| 	 correct form before we can start using it.  */
89|       mode_t mode;
90|       unsigned int value;
91|       va_list ap;
92| 
93|     try_create:
94|       va_start (ap, oflag);
95| 
96|       mode = va_arg (ap, mode_t);
97|       value = va_arg (ap, unsigned int);
98| 
99|       va_end (ap);
100| 
101|       if (value > SEM_VALUE_MAX)
102| 	{
103| 	  __set_errno (EINVAL);
104| 	  result = SEM_FAILED;
105| 	  goto out;
106| 	}
107| 
108|       /* Create the initial file content.  */
109|       union
110|       {
111| 	sem_t initsem;
112| 	struct new_sem newsem;
113|       } sem;
114| 
115|       __new_sem_open_init (&sem.newsem, value);
116| 
117|       /* Initialize the remaining bytes as well.  */
118|       memset ((char *) &sem.initsem + sizeof (struct new_sem), ''\0'',
119| 	      sizeof (sem_t) - sizeof (struct new_sem));
120| 
121|       char tmpfname[] = SHMDIR "sem.XXXXXX";
122|       int retries = 0;
123| #define NRETRIES 50
124|       while (1)
125| 	{
126| 	  /* We really want to use mktemp here.  We cannot use mkstemp
127| 	     since the file must be opened with a specific mode.  The
128| 	     mode cannot later be set since then we cannot apply the
129| 	     file create mask.  */
130| 	  if (__mktemp (tmpfname) == NULL)
131| 	    {
132| 	      result = SEM_FAILED;
133| 	      goto out;
134| 	    }
135| 
136| 	  /* Open the file.  Make sure we do not overwrite anything.  */
137| 	  fd = __open (tmpfname, O_CREAT | O_EXCL | SEM_OPEN_FLAGS, mode);
138| 	  if (fd == -1)
139| 	    {
140| 	      if (errno == EEXIST)
141| 		{
142| 		  if (++retries < NRETRIES)
143| 		    {
144| 		      /* Restore the six placeholder bytes before the
145| 			 null terminator before the next attempt.  */
146| 		      memcpy (tmpfname + sizeof (tmpfname) - 7, "XXXXXX", 6);
147| 		      continue;
148| 		    }
149| 
150| 		  __set_errno (EAGAIN);
151| 		}
152| 
153| 	      result = SEM_FAILED;
154| 	      goto out;
155| 	    }
156| 
157| 	  /* We got a file.  */
158| 	  break;
159| 	}
160| 
161|       if (TEMP_FAILURE_RETRY (write (fd, &sem.initsem, sizeof (sem_t)))
162| 	  == sizeof (sem_t)
163| 	  /* Map the sem_t structure from the file.  */
164| 	  && (result = (sem_t *) __mmap (NULL, sizeof (sem_t),
165| 					 PROT_READ | PROT_WRITE, MAP_SHARED,
166| 					 fd, 0)) != MAP_FAILED)
167| 	{
168| 	  /* Create the file.  Don''t overwrite an existing file.  */
169| 	  if (__link (tmpfname, dirname.name) != 0)
170| 	    {
171| 	      /* Undo the mapping.  */
172| 	      __munmap (result, sizeof (sem_t));
173| 
174| 	      /* Reinitialize ''result''.  */
175| 	      result = SEM_FAILED;
176| 
177| 	      /* This failed.  If O_EXCL is not set and the problem was
178| 		 that the file exists, try again.  */
179| 	      if ((oflag & O_EXCL) == 0 && errno == EEXIST)
180| 		{
181| 		  /* Remove the file.  */
182| 		  __unlink (tmpfname);
183| 
184| 		  /* Close the file.  */
185| 		  __close (fd);
186| 
187| 		  goto try_again;
188| 		}
189| 	    }
190| 	  else
191| 	    /* Insert the mapping into the search tree.  This also
192| 	       determines whether another thread sneaked by and already
193| 	       added such a mapping despite the fact that we created it.  */
194| 	    result = __sem_check_add_mapping (name, fd, result);
195| 	}
196| 
197|       /* Now remove the temporary name.  This should never fail.  If
198| 	 it fails we leak a file name.  Better fix the kernel.  */
199|       __unlink (tmpfname);
200|     }
201| 
202|   /* Map the mmap error to the error we need.  */
203|   if (MAP_FAILED != (void *) SEM_FAILED && result == MAP_FAILED)
204|     result = SEM_FAILED;
205| 
206|   /* We don''t need the file descriptor anymore.  */
207|   if (fd != -1)
208|     {
209|       /* Do not disturb errno.  */
210|       int save = errno;
211|       __close (fd);
212|       errno = save;
213|     }
214| 
215| out:
216| #ifdef __libc_ptf_call
217|   __libc_ptf_call (__pthread_setcancelstate, (state, NULL), 0);
218| #endif
219| 
220|   return result;
221| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|   	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> 	      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|   	    }
#  447|   	  break;
(Example-1) Reason Marked as False Positive:
declaration is in scope for all jumps to print_err, and fmt is set prior to each of those jumps

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/benchtests/bench-pthread-lock-base.c:53: var_decl: Declaring variable "buf2" without initializer.
glibc-2.39/benchtests/bench-pthread-lock-base.c:55: uninit_use_in_call: Using uninitialized value "*buf2" when calling "memcpy". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   53|     char buf1[512], buf2[512];
#   54|     int f = fibonacci (4);
#   55|->   memcpy (buf1, buf2, f);
#   56|   }
#   57|
(Example-2) Reason Marked as False Positive:
This function exists only to waste some time and block optimizations.

', '2025-11-17 21:39:07.118809');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (421, 102, 'def24', 'USE_AFTER_FREE', 'glibc-2.39/support/resolv_test.c:329: alias: Equality between "crname_target" and "crname" implies that they are aliases.
glibc-2.39/support/resolv_test.c:331: freed_arg: "free" frees "crname". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/support/resolv_test.c:338: deref_after_free: Dereferencing freed pointer "crname_target".
#  336|           {
#  337|             /* The name is known.  Reference the previous location.  */
#  338|->           unsigned int old_offset = crname_target->offset;
#  339|             TEST_VERIFY_EXIT (old_offset < compression_limit);
#  340|             response_add_byte (b, 0xC0 | (old_offset >> 8));', 'TRUE POSITIVE', 'Dereferencing `crname_target->offset` at line 338 occurs after `crname` (its alias) is explicitly freed at line 331, with no intervening reallocation, directly matching the Use After Free (CWE-416) vulnerability described in the CVE report.', 'The CVE report indicates a potential **Use After Free (CWE-416)** vulnerability, where `crname_target` (an alias of `crname`) is dereferenced after `crname` has been freed.

At line **331**, `free (crname)` is explicitly called, releasing the memory allocated for `crname`.

Prior to the `free` call, at line **329**, it is noted that `crname_target` and `crname` are aliases, meaning they point to the same memory location.

After `crname` is freed, the code at line **338** attempts to access `crname_target->offset`, which is the same memory location as the freed `crname`, since they are aliases.

This direct access to memory after it has been freed matches the description of a **Use After Free** vulnerability, as described in the CVE report.

There is no evidence within the provided code that the memory is reallocated or reused between the `free` call and the dereference, which would be necessary to consider this a false positive.

The implementation of `free` is not provided in the context, but based on standard behavior, once `free` is called on a pointer, the memory is considered invalid for access, reinforcing the vulnerability.

Given the explicit operations in the provided code, there is a clear, direct correlation between the code''s behavior and the described vulnerability, with no definitive proof to contradict the vulnerability''s existence.', 'Verify the memory allocation mechanism used for `crname` to ensure it''s not using a method that would render the vulnerability a false positive (e.g., `asprintf` or similar dynamic allocation with potential built-in safety measures).

Investigate the implementation of the `free` function in the context of the ''builtin model'' override to confirm its behavior aligns with standard `free` functionality.

Assess the impact of any custom memory allocators or compiler optimizations that might be in use, which could affect the vulnerability''s severity or exploitability.', 0.0000, '*** Source Code Context ***

code of support/resolv_test.c file:
266| void
267| resolv_response_add_name (struct resolv_response_builder *b,
268|                           const char *const origname)
269| {
270|   unsigned char encoded_name[NS_MAXDNAME];
271|   if (ns_name_pton (origname, encoded_name, sizeof (encoded_name)) < 0)
272|     FAIL_EXIT1 ("ns_name_pton (\"%s\"): %m", origname);
273| 
274|   /* Copy the encoded name into the output buffer, apply compression
275|      where possible.  */
276|   for (const unsigned char *name = encoded_name; ;)
277|     {
278|       if (*name == ''\0'')
279|         {
280|           /* We have reached the end of the name.  Add the terminating
281|              NUL byte.  */
282|           response_add_byte (b, ''\0'');
283|           break;
284|         }
285| 
286|       /* Set to the compression target if compression is possible.  */
287|       struct compressed_name *crname_target;
288| 
289|       /* Compression references can only reach the beginning of the
290|          packet.  */
291|       enum { compression_limit = 1 << 12 };
292| 
293|       {
294|         /* The trailing part of the name to be looked up in the tree
295|            with the compression targets.  */
296|         struct compressed_name *crname
297|           = allocate_compressed_name (name, b->offset);
298| 
299|         if (b->offset < compression_limit)
300|           {
301|             /* Add the name to the tree, for future compression
302|                references.  */
303|             void **ptr = tsearch (crname, &b->compression_offsets,
304|                                   compare_compressed_name);
305|             if (ptr == NULL)
306|               FAIL_EXIT1 ("tsearch out of memory");
307|             crname_target = *ptr;
308| 
309|             if (crname_target != crname)
310|               /* The new name was not actually added to the tree.
311|                  Deallocate it.  */
312|               free (crname);
313|             else
314|               /* Signal that the tree did not yet contain the name,
315|                  but keep the allocation because it is now part of the
316|                  tree.  */
317|               crname_target = NULL;
318|           }
319|         else
320|           {
321|             /* This name cannot be reached by a compression reference.
322|                No need to add it to the tree for future reference.  */
323|             void **ptr = tfind (crname, &b->compression_offsets,
324|                                 compare_compressed_name);
325|             if (ptr != NULL)
326|               crname_target = *ptr;
327|             else
328|               crname_target = NULL;
329|             TEST_VERIFY (crname_target != crname);
330|             /* Not added to the tree.  */
331|             free (crname);
332|           }
333|       }
334| 
335|       if (crname_target != NULL)
336|         {
337|           /* The name is known.  Reference the previous location.  */
338|           unsigned int old_offset = crname_target->offset;
339|           TEST_VERIFY_EXIT (old_offset < compression_limit);
340|           response_add_byte (b, 0xC0 | (old_offset >> 8));
341|           response_add_byte (b, old_offset);
342|           break;
343|         }
344|       else
345|         {
346|           /* The name is new.  Add this label.  */
347|           unsigned int len = 1 + *name;
348|           resolv_response_add_data (b, name, len);
349|           name += len;
350|         }
351|     }
352| }

code of /shared-data/source/glibc-2.39/hurd/hurdmalloc.c file:
128| typedef struct free_list {
129| 	spin_lock_t lock;	/* spin lock for mutual exclusion */
130| 	header_t head;		/* head of free list for this size */
131| #ifdef	DEBUG
132| 	int in_use;		/* # mallocs - # frees */
133| #endif	/* DEBUG */
134| } *free_list_t;

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
glibc-2.33.9000-984-gddcc612ce9/string/strerror_l.c:44: freed_arg: "free" frees "tls_internal->strerror_l_buf". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.33.9000-984-gddcc612ce9/string/strerror_l.c:49: use_after_free: Using freed pointer "tls_internal->strerror_l_buf".
(Example-1) Reason Marked as False Positive:
False positive.  buf is allocated using asprintf.

** Example-2 **
(Example-2) Known False Positive:
Error USE_AFTER_FREE (CWE-416):
glibc-2.33.9000-984-gddcc612ce9/string/strsignal.c:34: freed_arg: "free" frees "tls_internal->strsignal_buf". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.33.9000-984-gddcc612ce9/string/strsignal.c:49: use_after_free: Using freed pointer "tls_internal->strsignal_buf".
(Example-2) Reason Marked as False Positive:
False positive.  buf is allocated using asprintf.

', '2025-11-17 21:39:07.118809');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (422, 102, 'def25', 'INTEGER_OVERFLOW', 'glibc-2.39/elf/sprof.c:646: tainted_data_argument: The value "ehdr2" is considered tainted.
glibc-2.39/elf/sprof.c:653: tainted_data_argument: "ehdr2.e_shoff" is considered tainted.
glibc-2.39/elf/sprof.c:653: underflow: The cast of "ehdr2.e_shoff" to a signed type could result in a negative number.
#  651|   	  size_t size = ehdr2.e_shnum * sizeof (ElfW(Shdr));
#  652|   	  ElfW(Shdr) *shdr2 = (ElfW(Shdr) *) alloca (size);
#  653|-> 	  if (pread (fd2, shdr2, size, ehdr2.e_shoff) != size)
#  654|   	    error (EXIT_FAILURE, errno,
#  655|   		   _("reading of section headers failed"));', 'TRUE POSITIVE', 'Unvalidated, potentially tainted `ehdr2.e_shoff` is cast to a signed type and used as an offset in `pread` (line 653), risking underflow and unexpected behavior, with no visible mitigating checks in the provided code.', 'The CVE report explicitly highlights `ehdr2.e_shoff` as tainted and potentially causing an underflow when cast to a signed type (lines 653, CVE report).

The code at line 653 uses `ehdr2.e_shoff` as the offset for the `pread` function without any prior validation or sanitization that is visible within the provided code snippet.

An underflow in `ehdr2.e_shoff` could indeed result in a negative number, which, when passed to `pread` as an offset, might lead to unexpected behavior or errors, aligning with the CWE description of underflow (CWE-191).

There is no explicit check in the provided code for `ehdr2.e_shoff` being within a valid range (e.g., non-negative, within file bounds) before its use in `pread`, which would mitigate the underflow concern.

The allocation of `shdr2` (line 652) and its size determination (line 651) do not directly influence the validity of `ehdr2.e_shoff` as an offset, thus not mitigating the underflow risk.

Given the direct correlation between the code''s behavior and the vulnerability described (use of potentially tainted and underflowed value in a sensitive operation), and without explicit proof of safety within the provided code, the finding cannot be conclusively marked as a FALSE POSITIVE.', 'Obtain and analyze the complete `sprof.c` file, including all functions that interact with `ehdr2.e_shoff`, to identify any potential implicit checks or mitigations.

Investigate compiler flags and optimizations used during the build process that might influence the behavior of the potentially underflowed value in `ehdr2.e_shoff`.

Verify the implementation of `pread` in the context of glibc-2.39 to ensure no additional checks or behaviors are introduced that could mitigate the underflow risk.', 0.0000, '*** Source Code Context ***

code of elf/sprof.c file:
400| static struct shobj *
401| load_shobj (const char *name)
402| {
403|   struct link_map *map = NULL;
404|   struct shobj *result;
405|   ElfW(Addr) mapstart = ~((ElfW(Addr)) 0);
406|   ElfW(Addr) mapend = 0;
407|   const ElfW(Phdr) *ph;
408|   size_t textsize;
409|   ElfW(Ehdr) *ehdr;
410|   int fd;
411|   ElfW(Shdr) *shdr;
412|   size_t pagesize = getpagesize ();
413| 
414|   /* Since we use dlopen() we must be prepared to work around the sometimes
415|      strange lookup rules for the shared objects.  If we have a file foo.so
416|      in the current directory and the user specifies foo.so on the command
417|      line (without specifying a directory) we should load the file in the
418|      current directory even if a normal dlopen() call would read the other
419|      file.  We do this by adding a directory portion to the name.  */
420|   if (strchr (name, ''/'') == NULL)
421|     {
422|       char *load_name = (char *) alloca (strlen (name) + 3);
423|       stpcpy (stpcpy (load_name, "./"), name);
424| 
425|       map = (struct link_map *) dlopen (load_name, RTLD_LAZY | __RTLD_SPROF);
426|     }
427|   if (map == NULL)
428|     {
429|       map = (struct link_map *) dlopen (name, RTLD_LAZY | __RTLD_SPROF);
430|       if (map == NULL)
431| 	{
432| 	  error (0, errno, _("failed to load shared object `%s''"), name);
433| 	  return NULL;
434| 	}
435|     }
436| 
437|   /* Prepare the result.  */
438|   result = (struct shobj *) calloc (1, sizeof (struct shobj));
439|   if (result == NULL)
440|     {
441|       error (0, errno, _("cannot create internal descriptor"));
442|       dlclose (map);
443|       return NULL;
444|     }
445|   result->name = name;
446|   result->map = map;
447| 
448|   /* Compute the size of the sections which contain program code.
449|      This must match the code in dl-profile.c (_dl_start_profile).  */
450|   for (ph = map->l_phdr; ph < &map->l_phdr[map->l_phnum]; ++ph)
451|     if (ph->p_type == PT_LOAD && (ph->p_flags & PF_X))
452|       {
453| 	ElfW(Addr) start = (ph->p_vaddr & ~(pagesize - 1));
454| 	ElfW(Addr) end = ((ph->p_vaddr + ph->p_memsz + pagesize - 1)
455| 			  & ~(pagesize - 1));
456| 
457| 	if (start < mapstart)
458| 	  mapstart = start;
459| 	if (end > mapend)
460| 	  mapend = end;
461|       }
462| 
463|   result->lowpc = ROUNDDOWN ((uintptr_t) (mapstart + map->l_addr),
464| 			     HISTFRACTION * sizeof (HISTCOUNTER));
465|   result->highpc = ROUNDUP ((uintptr_t) (mapend + map->l_addr),
466| 			    HISTFRACTION * sizeof (HISTCOUNTER));
467|   if (do_test)
468|     printf ("load addr: %0#*" PRIxPTR "
"
469| 	    "lower bound PC: %0#*" PRIxPTR "
"
470| 	    "upper bound PC: %0#*" PRIxPTR "
",
471| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, map->l_addr,
472| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->lowpc,
473| 	    __ELF_NATIVE_CLASS == 32 ? 10 : 18, result->highpc);
474| 
475|   textsize = result->highpc - result->lowpc;
476|   result->kcountsize = textsize / HISTFRACTION;
477|   result->hashfraction = HASHFRACTION;
478|   if (do_test)
479|     printf ("hashfraction = %d
divider = %zu
",
480| 	    result->hashfraction,
481| 	    result->hashfraction * sizeof (struct here_fromstruct));
482|   result->tossize = textsize / HASHFRACTION;
483|   result->fromlimit = textsize * ARCDENSITY / 100;
484|   if (result->fromlimit < MINARCS)
485|     result->fromlimit = MINARCS;
486|   if (result->fromlimit > MAXARCS)
487|     result->fromlimit = MAXARCS;
488|   result->fromssize = result->fromlimit * sizeof (struct here_fromstruct);
489| 
490|   result->expected_size = (sizeof (struct gmon_hdr)
491| 			   + 4 + sizeof (struct gmon_hist_hdr)
492| 			   + result->kcountsize
493| 			   + 4 + 4
494| 			   + (result->fromssize
495| 			      * sizeof (struct here_cg_arc_record)));
496| 
497|   if (do_test)
498|     printf ("expected size: %zd
", result->expected_size);
499| 
500| #define SCALE_1_TO_1	0x10000L
501| 
502|   if (result->kcountsize < result->highpc - result->lowpc)
503|     {
504|       size_t range = result->highpc - result->lowpc;
505|       size_t quot = range / result->kcountsize;
506| 
507|       if (quot >= SCALE_1_TO_1)
508| 	result->s_scale = 1;
509|       else if (quot >= SCALE_1_TO_1 / 256)
510| 	result->s_scale = SCALE_1_TO_1 / quot;
511|       else if (range > ULONG_MAX / 256)
512| 	result->s_scale = ((SCALE_1_TO_1 * 256)
513| 			   / (range / (result->kcountsize / 256)));
514|       else
515| 	result->s_scale = ((SCALE_1_TO_1 * 256)
516| 			   / ((range * 256) / result->kcountsize));
517|     }
518|   else
519|     result->s_scale = SCALE_1_TO_1;
520| 
521|   if (do_test)
522|     printf ("s_scale: %d
", result->s_scale);
523| 
524|   /* Determine the dynamic string table.  */
525|   if (map->l_info[DT_STRTAB] == NULL)
526|     result->dynstrtab = NULL;
527|   else
528|     result->dynstrtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
529|   if (do_test)
530|     printf ("string table: %p
", result->dynstrtab);
531| 
532|   /* Determine the soname.  */
533|   if (map->l_info[DT_SONAME] == NULL)
534|     result->soname = NULL;
535|   else
536|     result->soname = result->dynstrtab + map->l_info[DT_SONAME]->d_un.d_val;
537|   if (do_test && result->soname != NULL)
538|     printf ("soname: %s
", result->soname);
539| 
540|   /* Now we have to load the symbol table.
541| 
542|      First load the section header table.  */
543|   ehdr = (ElfW(Ehdr) *) map->l_map_start;
544| 
545|   /* Make sure we are on the right party.  */
546|   if (ehdr->e_shentsize != sizeof (ElfW(Shdr)))
547|     abort ();
548| 
549|   /* And we need the shared object file descriptor again.  */
550|   fd = open (map->l_name, O_RDONLY);
551|   if (fd == -1)
552|     /* Dooh, this really shouldn''t happen.  We know the file is available.  */
553|     error (EXIT_FAILURE, errno, _("Reopening shared object `%s'' failed"),
554| 	   map->l_name);
555| 
556|   /* Map the section header.  */
557|   size_t size = ehdr->e_shnum * sizeof (ElfW(Shdr));
558|   shdr = (ElfW(Shdr) *) alloca (size);
559|   if (pread (fd, shdr, size, ehdr->e_shoff) != size)
560|     error (EXIT_FAILURE, errno, _("reading of section headers failed"));
561| 
562|   /* Get the section header string table.  */
563|   char *shstrtab = (char *) alloca (shdr[ehdr->e_shstrndx].sh_size);
564|   if (pread (fd, shstrtab, shdr[ehdr->e_shstrndx].sh_size,
565| 	     shdr[ehdr->e_shstrndx].sh_offset)
566|       != shdr[ehdr->e_shstrndx].sh_size)
567|     error (EXIT_FAILURE, errno,
568| 	   _("reading of section header string table failed"));
569| 
570|   /* Search for the ".symtab" section.  */
571|   ElfW(Shdr) *symtab_entry = NULL;
572|   ElfW(Shdr) *debuglink_entry = NULL;
573|   for (int idx = 0; idx < ehdr->e_shnum; ++idx)
574|     if (shdr[idx].sh_type == SHT_SYMTAB
575| 	&& strcmp (shstrtab + shdr[idx].sh_name, ".symtab") == 0)
576|       {
577| 	symtab_entry = &shdr[idx];
578| 	break;
579|       }
580|     else if (shdr[idx].sh_type == SHT_PROGBITS
581| 	     && strcmp (shstrtab + shdr[idx].sh_name, ".gnu_debuglink") == 0)
582|       debuglink_entry = &shdr[idx];
583| 
584|   /* Get the file name of the debuginfo file if necessary.  */
585|   int symfd = fd;
586|   if (symtab_entry == NULL && debuglink_entry != NULL)
587|     {
588|       size_t size = debuglink_entry->sh_size;
589|       char *debuginfo_fname = (char *) alloca (size + 1);
590|       debuginfo_fname[size] = ''\0'';
591|       if (pread (fd, debuginfo_fname, size, debuglink_entry->sh_offset)
592| 	  != size)
593| 	{
594| 	  fprintf (stderr, _("*** Cannot read debuginfo file name: %m
"));
595| 	  goto no_debuginfo;
596| 	}
597| 
598|       static const char procpath[] = "/proc/self/fd/%d";
599|       char origprocname[sizeof (procpath) + sizeof (int) * 3];
600|       snprintf (origprocname, sizeof (origprocname), procpath, fd);
601|       char *origlink = (char *) alloca (PATH_MAX);
602|       ssize_t n = readlink (origprocname, origlink, PATH_MAX - 1);
603|       if (n == -1)
604| 	goto no_debuginfo;
605|       origlink[n] = ''\0'';
606| 
607|       /* Try to find the actual file.  There are three places:
608| 	 1. the same directory the DSO is in
609| 	 2. in a subdir named .debug of the directory the DSO is in
610| 	 3. in /usr/lib/debug/PATH-OF-DSO
611|       */
612|       char *realname = canonicalize_file_name (origlink);
613|       char *cp = NULL;
614|       if (realname == NULL || (cp = strrchr (realname, ''/'')) == NULL)
615| 	error (EXIT_FAILURE, errno, _("cannot determine file name"));
616| 
617|       /* Leave the last slash in place.  */
618|       *++cp = ''\0'';
619| 
620|       /* First add the debuginfo file name only.  */
621|       static const char usrlibdebug[]= "/usr/lib/debug/";
622|       char *workbuf = (char *) alloca (sizeof (usrlibdebug)
623| 				       + (cp - realname)
624| 				       + strlen (debuginfo_fname));
625|       strcpy (stpcpy (workbuf, realname), debuginfo_fname);
626| 
627|       int fd2 = open (workbuf, O_RDONLY);
628|       if (fd2 == -1)
629| 	{
630| 	  strcpy (stpcpy (stpcpy (workbuf, realname), ".debug/"),
631| 		  debuginfo_fname);
632| 	  fd2 = open (workbuf, O_RDONLY);
633| 	  if (fd2 == -1)
634| 	    {
635| 	      strcpy (stpcpy (stpcpy (workbuf, usrlibdebug), realname),
636| 		      debuginfo_fname);
637| 	      fd2 = open (workbuf, O_RDONLY);
638| 	    }
639| 	}
640| 
641|       if (fd2 != -1)
642| 	{
643| 	  ElfW(Ehdr) ehdr2;
644| 
645| 	  /* Read the ELF header.  */
646| 	  if (pread (fd2, &ehdr2, sizeof (ehdr2), 0) != sizeof (ehdr2))
647| 	    error (EXIT_FAILURE, errno,
648| 		   _("reading of ELF header failed"));
649| 
650| 	  /* Map the section header.  */
651| 	  size_t size = ehdr2.e_shnum * sizeof (ElfW(Shdr));
652| 	  ElfW(Shdr) *shdr2 = (ElfW(Shdr) *) alloca (size);
653| 	  if (pread (fd2, shdr2, size, ehdr2.e_shoff) != size)
654| 	    error (EXIT_FAILURE, errno,
655| 		   _("reading of section headers failed"));
656| 
657| 	  /* Get the section header string table.  */
658| 	  shstrtab = (char *) alloca (shdr2[ehdr2.e_shstrndx].sh_size);
659| 	  if (pread (fd2, shstrtab, shdr2[ehdr2.e_shstrndx].sh_size,
660| 		     shdr2[ehdr2.e_shstrndx].sh_offset)
661| 	      != shdr2[ehdr2.e_shstrndx].sh_size)
662| 	    error (EXIT_FAILURE, errno,
663| 		   _("reading of section header string table failed"));
664| 
665| 	  /* Search for the ".symtab" section.  */
666| 	  for (int idx = 0; idx < ehdr2.e_shnum; ++idx)
667| 	    if (shdr2[idx].sh_type == SHT_SYMTAB
668| 		&& strcmp (shstrtab + shdr2[idx].sh_name, ".symtab") == 0)
669| 	      {
670| 		symtab_entry = &shdr2[idx];
671| 		shdr = shdr2;
672| 		symfd = fd2;
673| 		break;
674| 	      }
675| 
676| 	  if  (fd2 != symfd)
677| 	    close (fd2);
678| 	}
679|     }
680| 
681|  no_debuginfo:
682|   if (symtab_entry == NULL)
683|     {
684|       fprintf (stderr, _("\
685| *** The file `%s'' is stripped: no detailed analysis possible
"),
686| 	      name);
687|       result->symtab = NULL;
688|       result->strtab = NULL;
689|     }
690|   else
691|     {
692|       ElfW(Off) min_offset, max_offset;
693|       ElfW(Shdr) *strtab_entry;
694| 
695|       strtab_entry = &shdr[symtab_entry->sh_link];
696| 
697|       /* Find the minimum and maximum offsets that include both the symbol
698| 	 table and the string table.  */
699|       if (symtab_entry->sh_offset < strtab_entry->sh_offset)
700| 	{
701| 	  min_offset = symtab_entry->sh_offset & ~(pagesize - 1);
702| 	  max_offset = strtab_entry->sh_offset + strtab_entry->sh_size;
703| 	}
704|       else
705| 	{
706| 	  min_offset = strtab_entry->sh_offset & ~(pagesize - 1);
707| 	  max_offset = symtab_entry->sh_offset + symtab_entry->sh_size;
708| 	}
709| 
710|       result->symbol_map = mmap (NULL, max_offset - min_offset,
711| 				 PROT_READ, MAP_SHARED|MAP_FILE, symfd,
712| 				 min_offset);
713|       if (result->symbol_map == MAP_FAILED)
714| 	error (EXIT_FAILURE, errno, _("failed to load symbol data"));
715| 
716|       result->symtab
717| 	= (const ElfW(Sym) *) ((const char *) result->symbol_map
718| 			       + (symtab_entry->sh_offset - min_offset));
719|       result->symtab_size = symtab_entry->sh_size;
720|       result->strtab = ((const char *) result->symbol_map
721| 			+ (strtab_entry->sh_offset - min_offset));
722|       result->symbol_mapsize = max_offset - min_offset;
723|     }
724| 
725|   /* Free the descriptor for the shared object.  */
726|   close (fd);
727|   if (symfd != fd)
728|     close (symfd);
729| 
730|   return result;
731| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/elf/dl-map-segments.h:101: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h:101: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h:106: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h:156: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h:156: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h:163: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h:176: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h:176: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  174|                       return DL_MAP_SEGMENTS_ERROR_MPROTECT;
#  175|                   }
#  176|->               memset ((void *) zero, ''\0'', zeropage - zero);
#  177|                 if (__glibc_unlikely ((c->prot & PROT_WRITE) == 0))
#  178|                   __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),
(Example-2) Reason Marked as False Positive:
The only negative value that can be returned is -1 (MAP_FAILED) and that''s tested for.

', '2025-11-17 21:39:07.118809');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (424, 102, 'def27', 'CPPCHECK_WARNING', 'glibc-2.39/timezone/zic.c:2270: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2268|                     for (i = old0; i < typecnt; i++)
# 2269|                           if (!omittype[i])
# 2270|->                                 putc(ttisstds[i], fp);
# 2271|                   if (utcnt != 0)
# 2272|                     for (i = old0; i < typecnt; i++)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c:2270: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2268|                     for (i = old0; i < typecnt; i++)
# 2269|                           if (!omittype[i])
# 2270|->                                 putc(ttisstds[i], fp);
# 2271|                   if (utcnt != 0)
# 2272|                     for (i = old0; i < typecnt; i++)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-686):
glibc-2.39/timezone/zic.c:2270: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2268|                     for (i = old0; i < typecnt; i++)
# 2269|                           if (!omittype[i])
# 2270|->                                 putc(ttisstds[i], fp);
# 2271|                   if (utcnt != 0)
# 2272|                     for (i = old0; i < typecnt; i++)
(Example-1) Reason Marked as False Positive:
The checker is broken.  Bool promotes to int just fine.

** Example-2 **
(Example-2) Known False Positive:
Error CPPCHECK_WARNING (CWE-686):
glibc-2.39/timezone/zic.c:2274: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2272|   		  for (i = old0; i < typecnt; i++)
# 2273|   			if (!omittype[i])
# 2274|-> 				putc(ttisuts[i], fp);
# 2275|   	}
# 2276|   	fprintf(fp, "
%s
", string);
(Example-2) Reason Marked as False Positive:
The checker is broken. Bool promotes to int just fine.

', '2025-11-17 21:39:07.11881');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (425, 102, 'def28', 'CPPCHECK_WARNING', 'glibc-2.39/timezone/zic.c:2274: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2272|   		  for (i = old0; i < typecnt; i++)
# 2273|   			if (!omittype[i])
# 2274|-> 				putc(ttisuts[i], fp);
# 2275|   	}
# 2276|   	fprintf(fp, "\n%s\n", string);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c:2274: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2272|    erotik (i = old0; i < typecnt; i++)
# 2273|    if (!omittype[i])
# 2274|-> putc(ttisuts[i], fp);
# 2275|    }
# 2276|    fprintf(fp, "
%s
", string);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-686):
glibc-2.39/timezone/zic.c:2274: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2272|   		  for (i = old0; i < typecnt; i++)
# 2273|   			if (!omittype[i])
# 2274|-> 				putc(ttisuts[i], fp);
# 2275|   	}
# 2276|   	fprintf(fp, "
%s
", string);
(Example-1) Reason Marked as False Positive:
The checker is broken. Bool promotes to int just fine.

** Example-2 **
(Example-2) Known False Positive:
Error CPPCHECK_WARNING (CWE-686):
glibc-2.39/timezone/zic.c:2270: error[invalidFunctionArgBool]: Invalid putc() argument nr 1. A non-boolean value is required.
# 2268|                     for (i = old0; i < typecnt; i++)
# 2269|                           if (!omittype[i])
# 2270|->                                 putc(ttisstds[i], fp);
# 2271|                   if (utcnt != 0)
# 2272|                     for (i = old0; i < typecnt; i++)
(Example-2) Reason Marked as False Positive:
The checker is broken.  Bool promotes to int just fine.

', '2025-11-17 21:39:07.11881');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (426, 102, 'def29', 'INTEGER_OVERFLOW', 'glibc-2.39/elf/dl-map-segments.h:101: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h:101: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h:106: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h:156: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h:156: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h:163: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h:176: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h:176: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  174|                       return DL_MAP_SEGMENTS_ERROR_MPROTECT;
#  175|                   }
#  176|->               memset ((void *) zero, ''\0'', zeropage - zero);
#  177|                 if (__glibc_unlikely ((c->prot & PROT_WRITE) == 0))
#  178|                   __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/elf/dl-map-segments.h: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/elf/dl-map-segments.h:101: tainted_data_return: Called function "_dl_map_segment(c, mappref, maplength, fd)", and a possible return value is known to be less than zero.
glibc-2.39/elf/dl-map-segments.h:101: assign: Assigning: "l->l_map_start" = "_dl_map_segment(c, mappref, maplength, fd)".
glibc-2.39/elf/dl-map-segments.h:106: assign: Assigning: "l->l_addr" = "l->l_map_start - c->mapstart".
glibc-2.39/elf/dl-map-segments.h:156: overflow: The expression "l->l_addr + c->allocend" is considered to have possibly overflowed.
glibc-2.39/elf/dl-map-segments.h:156: assign: Assigning: "zeroend" = "l->l_addr + c->allocend".
glibc-2.39/elf/dl-map-segments.h:163: assign: Assigning: "zeropage" = "zeroend".
glibc-2.39/elf/dl-map-segments.h:176: overflow: The expression "zeropage - zero" is deemed overflowed because at least one of its arguments has overflowed.
glibc-2.39/elf/dl-map-segments.h:176: overflow_sink: "zeropage - zero", which might have underflowed, is passed to "memset((void *)zero, 0, zeropage - zero)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  174|                       return DL_MAP_SEGMENTS_ERROR_MPROTECT;
#  175|                   }
#  176|->               memset ((void *) zero, ''\0'', zeropage - zero);
#  177|                 if (__glibc_unlikely ((c->prot & PROT_WRITE) == 0))
#  178|                   __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),
(Example-1) Reason Marked as False Positive:
The only negative value that can be returned is -1 (MAP_FAILED) and that''s tested for.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/locale/programs/linereader.c:805: underflow: The decrement operator on the unsigned variable "lrb.act" might result in an underflow.
glibc-2.39/locale/programs/linereader.c:810: overflow_sink: "lrb.act", which might have underflowed, is passed to "addc(&lrb, ''\0'')".
#  808|   	lr_error (lr, _("unterminated string"));
#  809|   
#  810|->       addc (&lrb, ''\0'');
#  811|       }
#  812|     else
(Example-2) Reason Marked as False Positive:
condition preceeding this line prevents underflow

', '2025-11-17 21:39:07.118811');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (427, 102, 'def30', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|           /* Increase the buffer.  */
#  522|->         new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|           if (new_inbuf == NULL)
#  524|             {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|           /* Increase the buffer.  */
#  522|->         new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|           if (new_inbuf == NULL)
#  524|             {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-1) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-2) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

', '2025-11-17 21:39:07.118811');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (428, 102, 'def31', 'INTEGER_OVERFLOW', 'glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|    /* Increase the buffer.  */
#  576|->  new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|    if (new_inbuf == NULL)
#  578|      {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_prog.c:550: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_prog.c:576: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_prog.c:576: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  574|   
#  575|   	/* Increase the buffer.  */
#  576|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  577|   	if (new_inbuf == NULL)
#  578|   	  {
(Example-1) Reason Marked as False Positive:
maxlen+32768 can''t "wrap under" because realloc() won''t succeed once the size exceeds half of size_t''s range.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/iconv/iconv_charmap.c:496: tainted_data_argument: The check "actlen < maxlen" contains the tainted expression "actlen" which causes "maxlen" to be considered tainted.
glibc-2.39/iconv/iconv_charmap.c:522: overflow: The expression "maxlen + 32768UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/iconv/iconv_charmap.c:522: overflow_sink: "maxlen + 32768UL", which might have underflowed, is passed to "realloc(inbuf, maxlen + 32768UL)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  520|   
#  521|   	/* Increase the buffer.  */
#  522|-> 	new_inbuf = (char *) realloc (inbuf, maxlen + 32768);
#  523|   	if (new_inbuf == NULL)
#  524|   	  {
(Example-2) Reason Marked as False Positive:
realloc is limited to half of the address space per allocation; 38768U increments cannot underflow without hitting the size limitation first.

', '2025-11-17 21:39:07.118811');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (429, 102, 'def32', 'INTEGER_OVERFLOW', 'glibc-2.39/locale/programs/ld-numeric.c:308: underflow: The decrement operator on the unsigned variable "act" might result in an underflow.
glibc-2.39/locale/programs/ld-numeric.c:311: overflow_sink: "act", which might have underflowed, is passed to "xrealloc(grouping, act)".
#  309|   	      grouping[act++] = ''\0'';
#  310|   
#  311|-> 	      numeric->grouping = xrealloc (grouping, act);
#  312|   	      numeric->grouping_len = act;
#  313|   	    }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-numeric.c: underflow: The decrement operator on the unsigned variable "act" might result in an underflow.
glibc-2.39/locale/programs/ld-numeric.c: overflow_sink: "act", which might have underflowed, is passed to "xrealloc(grouping, act)".
#    grouping[act++] = ''\0'';
#    
#->  numeric->grouping = xrealloc (grouping, act);
#    numeric->grouping_len = act;
#    }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/locale/programs/ld-numeric.c:308: underflow: The decrement operator on the unsigned variable "act" might result in an underflow.
glibc-2.39/locale/programs/ld-numeric.c:311: overflow_sink: "act", which might have underflowed, is passed to "xrealloc(grouping, act)".
#  309|   	      grouping[act++] = ''\0'';
#  310|   
#  311|-> 	      numeric->grouping = xrealloc (grouping, act);
#  312|   	      numeric->grouping_len = act;
#  313|   	    }
(Example-1) Reason Marked as False Positive:
check for act==1 in previous line prevents underflow

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/locale/programs/linereader.c:805: underflow: The decrement operator on the unsigned variable "lrb.act" might result in an underflow.
glibc-2.39/locale/programs/linereader.c:810: overflow_sink: "lrb.act", which might have underflowed, is passed to "addc(&lrb, ''\0'')".
#  808|   	lr_error (lr, _("unterminated string"));
#  809|   
#  810|->       addc (&lrb, ''\0'');
#  811|       }
#  812|     else
(Example-2) Reason Marked as False Positive:
condition preceeding this line prevents underflow

', '2025-11-17 21:39:07.118811');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (430, 102, 'def33', 'INTEGER_OVERFLOW', 'glibc-2.39/locale/programs/linereader.c:805: underflow: The decrement operator on the unsigned variable "lrb.act" might result in an underflow.
glibc-2.39/locale/programs/linereader.c:810: overflow_sink: "lrb.act", which might have underflowed, is passed to "addc(&lrb, ''\0'')".
#  808|   	lr_error (lr, _("unterminated string"));
#  809|   
#  810|->       addc (&lrb, ''\0'');
#  811|       }
#  812|     else', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/linereader.c:805: underflow: The decrement operator on the unsigned variable "lrb.act" might result in an underflow.
glibc-2.39/locale/programs/linereader.c:810: overflow_sink: "lrb.act", which might have underflowed, is passed to "addc(&lrb, ''\0'')".
#  808|    lr_error (lr, "_("unterminated string")");
#  809|   
#  810|->       addc (&lrb, ''\0'');
#  811|       }
#  812|     else', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/locale/programs/linereader.c:805: underflow: The decrement operator on the unsigned variable "lrb.act" might result in an underflow.
glibc-2.39/locale/programs/linereader.c:810: overflow_sink: "lrb.act", which might have underflowed, is passed to "addc(&lrb, ''\0'')".
#  808|   	lr_error (lr, _("unterminated string"));
#  809|   
#  810|->       addc (&lrb, ''\0'');
#  811|       }
#  812|     else
(Example-1) Reason Marked as False Positive:
condition preceeding this line prevents underflow

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/locale/programs/ld-numeric.c:308: underflow: The decrement operator on the unsigned variable "act" might result in an underflow.
glibc-2.39/locale/programs/ld-numeric.c:311: overflow_sink: "act", which might have underflowed, is passed to "xrealloc(grouping, act)".
#  309|   	      grouping[act++] = ''\0'';
#  310|   
#  311|-> 	      numeric->grouping = xrealloc (grouping, act);
#  312|   	      numeric->grouping_len = act;
#  313|   	    }
(Example-2) Reason Marked as False Positive:
check for act==1 in previous line prevents underflow

', '2025-11-17 21:39:07.118812');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (431, 102, 'def34', 'INTEGER_OVERFLOW', 'glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|    cp = *thisansp;
#  747|->  while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|    cp += n;
#  749|    len -= n;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;
(Example-1) Reason Marked as False Positive:
there''s a check for read returning > 0 in the conditional

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:764: tainted_data_return: Called function "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:764: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/resolv/res_send.c:764: overflow_sink: "(len > 512UL) ? 512UL : len", which might have underflowed, is passed to "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  762|   			char junk[PACKETSZ];
#  763|   
#  764|-> 			n = read(statp->_vcsock, junk,
#  765|   				 (len > sizeof junk) ? sizeof junk : len);
#  766|   			if (n > 0)
(Example-2) Reason Marked as False Positive:
The value returned from read() will either be nonpositive (error) or no greater than the number of bytes requested.  Such limit prevents "n" from being more than "len" or less than one, so subtracting it from len cannot make len become negative.

', '2025-11-17 21:39:07.118812');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (432, 102, 'def35', 'INTEGER_OVERFLOW', 'glibc-2.39/resolv/res_send.c:764: tainted_data_return: Called function "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:764: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/resolv/res_send.c:764: overflow_sink: "(len > 512UL) ? 512UL : len", which might have underflowed, is passed to "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  762|   			char junk[PACKETSZ];
#  763|   
#  764|-> 			n = read(statp->_vcsock, junk,
#  765|   				 (len > sizeof junk) ? sizeof junk : len);
#  766|   			if (n > 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/res_send.c: tainted_data_return: Called function "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/resolv/res_send.c: overflow_sink: "(len > 512UL) ? 512UL : len", which might have underflowed, is passed to "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))".
#    char junk[PACKETSZ];
#    
#-> n = read(statp->_vcsock, junk, (len > sizeof junk) ? sizeof junk : len);
#    if (n > 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:764: tainted_data_return: Called function "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:764: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:767: overflow: The expression "len -= n" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/resolv/res_send.c:764: overflow_sink: "(len > 512UL) ? 512UL : len", which might have underflowed, is passed to "read(statp->_vcsock, junk, ((len > 512UL) ? 512UL : len))". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  762|   			char junk[PACKETSZ];
#  763|   
#  764|-> 			n = read(statp->_vcsock, junk,
#  765|   				 (len > sizeof junk) ? sizeof junk : len);
#  766|   			if (n > 0)
(Example-1) Reason Marked as False Positive:
The value returned from read() will either be nonpositive (error) or no greater than the number of bytes requested.  Such limit prevents "n" from being more than "len" or less than one, so subtracting it from len cannot make len become negative.

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;
(Example-2) Reason Marked as False Positive:
there''s a check for read returning > 0 in the conditional

', '2025-11-17 21:39:07.118812');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (433, 102, 'def36', 'INTEGER_OVERFLOW', 'glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)".
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> =read_count = read (infd, buf, to_read);
#   82|         else
#   83|   read_count = pread64 (infd, buf, to_read, *pinoff);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/support/support_copy_file_range.c:81: tainted_data_return: Called function "read(infd, buf, to_read)", and a possible return value may be less than zero.
glibc-2.39/support/support_copy_file_range.c:81: assign: Assigning: "read_count" = "read(infd, buf, to_read)".
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/support/support_copy_file_range.c:140: overflow: The expression "length -= read_count" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/support/support_copy_file_range.c:74: assign: Assigning: "to_read" = "length".
glibc-2.39/support/support_copy_file_range.c:81: overflow_sink: "to_read", which might have underflowed, is passed to "read(infd, buf, to_read)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   79|         ssize_t read_count;
#   80|         if (pinoff == NULL)
#   81|-> 	read_count = read (infd, buf, to_read);
#   82|         else
#   83|   	read_count = pread64 (infd, buf, to_read, *pinoff);
(Example-1) Reason Marked as False Positive:
negative return value is checked for on line 87

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/resolv/res_send.c:747: tainted_data_return: Called function "read(statp->_vcsock, (char *)cp, (int)len)", and a possible return value may be less than zero.
glibc-2.39/resolv/res_send.c:747: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
glibc-2.39/resolv/res_send.c:749: overflow: The expression "len -= n" might be negative, but is used in a context that treats it as unsigned.
glibc-2.39/resolv/res_send.c:747: overflow_sink: "(int)len", which might be negative, is passed to "read(statp->_vcsock, (char *)cp, (int)len)". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  745|   
#  746|   	cp = *thisansp;
#  747|-> 	while (len != 0 && (n = read(statp->_vcsock, (char *)cp, (int)len)) > 0){
#  748|   		cp += n;
#  749|   		len -= n;
(Example-2) Reason Marked as False Positive:
there''s a check for read returning > 0 in the conditional

', '2025-11-17 21:39:07.118813');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (434, 102, 'def37', 'INTEGER_OVERFLOW', 'glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;', 'FALSE POSITIVE', 'The unsigned variable ''i'' cannot underflow in a way that causes a dereference overflow on line 711, as the while loop (lines 677-680) would terminate due to the comparison `timer < transitions[i - 1]` becoming false if ''i'' were to wrap around, ensuring ''i'' remains within bounds as implied by the assertion (lines 709-710).', 'The variable ''i'' is of type ''size_t'', which is an unsigned type. While it''s true that the decrement operator on line 678 might attempt to reduce ''i'' below 0, the behavior of unsigned integers in C is to wrap around to the maximum value (e.g., SIZE_MAX for size_t). However, this alone doesn''t justify a FALSE POSITIVE without considering the context.

Crucially, the decrement operation on line 678 (`--i;`) is within a while loop condition (`while (timer < transitions[i - 1])`). The loop''s continuation depends on the comparison `timer < transitions[i - 1]`. Given ''i'' is unsigned, if ''i'' were to underflow (wrap around), ''i - 1'' would evaluate to a very large number, making the comparison `timer < transitions[i - 1]` inevitably false, thus exiting the loop before any underflow could affect the subsequent use of ''i'' on line 711.

Furthermore, the assertion on lines 709-710 (`/* assert (timer >= transitions[i - 1] && (i == num_transitions || timer < transitions[i])) */`) implies that ''i'' is within a valid range for the array accesses on line 711. Although assertions are not always enabled, the code''s logic (as shown in the loop and conditional statements surrounding the reported lines) ensures ''i'' remains within bounds, reinforcing the assertion''s implication.

Given the unsigned nature of ''i'', the specific loop and conditional logic surrounding its decrement, and the assertion''s implied bounds checking, there is no execution path where ''i'' underflows in a manner that would lead to a dereference overflow on line 711, as the loop would terminate before such a condition could occur.', NULL, 0.0000, '*** Source Code Context ***

code of time/tzfile.c file:
582| void
583| __tzfile_compute (__time64_t timer, int use_localtime,
584| 		  long int *leap_correct, int *leap_hit,
585| 		  struct tm *tp)
586| {
587|   size_t i;
588| 
589|   if (use_localtime)
590|     {
591|       __tzname[0] = NULL;
592|       __tzname[1] = NULL;
593| 
594|       if (__glibc_unlikely (num_transitions == 0 || timer < transitions[0]))
595| 	{
596| 	  /* TIMER is before any transition (or there are no transitions).
597| 	     Choose the first non-DST type
598| 	     (or the first if they''re all DST types).  */
599| 	  i = 0;
600| 	  while (i < num_types && types[i].isdst)
601| 	    {
602| 	      if (__tzname[1] == NULL)
603| 		__tzname[1] = __tzstring (&zone_names[types[i].idx]);
604| 
605| 	      ++i;
606| 	    }
607| 
608| 	  if (i == num_types)
609| 	    i = 0;
610| 	  __tzname[0] = __tzstring (&zone_names[types[i].idx]);
611| 	  if (__tzname[1] == NULL)
612| 	    {
613| 	      size_t j = i;
614| 	      while (j < num_types)
615| 		if (types[j].isdst)
616| 		  {
617| 		    __tzname[1] = __tzstring (&zone_names[types[j].idx]);
618| 		    break;
619| 		  }
620| 		else
621| 		  ++j;
622| 	    }
623| 	}
624|       else if (__glibc_unlikely (timer >= transitions[num_transitions - 1]))
625| 	{
626| 	  if (__glibc_unlikely (tzspec == NULL))
627| 	    {
628| 	    use_last:
629| 	      i = num_transitions;
630| 	      goto found;
631| 	    }
632| 
633| 	  /* Parse the POSIX TZ-style string.  */
634| 	  __tzset_parse_tz (tzspec);
635| 
636| 	  /* Convert to broken down structure.  If this fails do not
637| 	     use the string.  */
638| 	  if (__glibc_unlikely (! __offtime (timer, 0, tp)))
639| 	    goto use_last;
640| 
641| 	  /* Use the rules from the TZ string to compute the change.  */
642| 	  __tz_compute (timer, tp, 1);
643| 
644| 	  /* If tzspec comes from posixrules loaded by __tzfile_default,
645| 	     override the STD and DST zone names with the ones user
646| 	     requested in TZ envvar.  */
647| 	  if (__glibc_unlikely (zone_names == (char *) &leaps[num_leaps]))
648| 	    {
649| 	      assert (num_types == 2);
650| 	      __tzname[0] = __tzstring (zone_names);
651| 	      __tzname[1] = __tzstring (&zone_names[strlen (zone_names) + 1]);
652| 	    }
653| 
654| 	  goto leap;
655| 	}
656|       else
657| 	{
658| 	  /* Find the first transition after TIMER, and
659| 	     then pick the type of the transition before it.  */
660| 	  size_t lo = 0;
661| 	  size_t hi = num_transitions - 1;
662| 	  /* Assume that DST is changing twice a year and guess
663| 	     initial search spot from it.  Half of a gregorian year
664| 	     has on average 365.2425 * 86400 / 2 = 15778476 seconds.
665| 	     The value i can be truncated if size_t is smaller than
666| 	     __time64_t, but this is harmless because it is just
667| 	     a guess.  */
668| 	  i = (transitions[num_transitions - 1] - timer) / 15778476;
669| 	  if (i < num_transitions)
670| 	    {
671| 	      i = num_transitions - 1 - i;
672| 	      if (timer < transitions[i])
673| 		{
674| 		  if (i < 10 || timer >= transitions[i - 10])
675| 		    {
676| 		      /* Linear search.  */
677| 		      while (timer < transitions[i - 1])
678| 			--i;
679| 		      goto found;
680| 		    }
681| 		  hi = i - 10;
682| 		}
683| 	      else
684| 		{
685| 		  if (i + 10 >= num_transitions || timer < transitions[i + 10])
686| 		    {
687| 		      /* Linear search.  */
688| 		      while (timer >= transitions[i])
689| 			++i;
690| 		      goto found;
691| 		    }
692| 		  lo = i + 10;
693| 		}
694| 	    }
695| 
696| 	  /* Binary search.  */
697| 	  /* assert (timer >= transitions[lo] && timer < transitions[hi]); */
698| 	  while (lo + 1 < hi)
699| 	    {
700| 	      i = (lo + hi) / 2;
701| 	      if (timer < transitions[i])
702| 		hi = i;
703| 	      else
704| 		lo = i;
705| 	    }
706| 	  i = hi;
707| 
708| 	found:
709| 	  /* assert (timer >= transitions[i - 1]
710| 	     && (i == num_transitions || timer < transitions[i])); */
711| 	  __tzname[types[type_idxs[i - 1]].isdst]
712| 	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
713| 	  size_t j = i;
714| 	  while (j < num_transitions)
715| 	    {
716| 	      int type = type_idxs[j];
717| 	      int dst = types[type].isdst;
718| 	      int idx = types[type].idx;
719| 
720| 	      if (__tzname[dst] == NULL)
721| 		{
722| 		  __tzname[dst] = __tzstring (&zone_names[idx]);
723| 
724| 		  if (__tzname[1 - dst] != NULL)
725| 		    break;
726| 		}
727| 
728| 	      ++j;
729| 	    }
730| 
731| 	  if (__glibc_unlikely (__tzname[0] == NULL))
732| 	    __tzname[0] = __tzname[1];
733| 
734| 	  i = type_idxs[i - 1];
735| 	}
736| 
737|       struct ttinfo *info = &types[i];
738|       __daylight = daylight_saved;
739|       __timezone = -rule_stdoff;
740| 
741|       if (__tzname[0] == NULL)
742| 	{
743| 	  /* This should only happen if there are no transition rules.
744| 	     In this case there should be only one single type.  */
745| 	  assert (num_types == 1);
746| 	  __tzname[0] = __tzstring (zone_names);
747| 	}
748|       if (__tzname[1] == NULL)
749| 	/* There is no daylight saving time.  */
750| 	__tzname[1] = __tzname[0];
751|       tp->tm_isdst = info->isdst;
752|       assert (strcmp (&zone_names[info->idx], __tzname[tp->tm_isdst]) == 0);
753|       tp->tm_zone = __tzname[tp->tm_isdst];
754|       tp->tm_gmtoff = info->offset;
755|     }
756| 
757|  leap:
758|   *leap_correct = 0L;
759|   *leap_hit = 0;
760| 
761|   /* Find the last leap second correction transition time before TIMER.  */
762|   i = num_leaps;
763|   do
764|     if (i-- == 0)
765|       return;
766|   while (timer < leaps[i].transition);
767| 
768|   /* Apply its correction.  */
769|   *leap_correct = leaps[i].change;
770| 
771|   if (timer == leaps[i].transition /* Exactly at the transition time.  */
772|       && (leaps[i].change > (i == 0 ? 0 : leaps[i - 1].change)))
773|     {
774|       *leap_hit = 1;
775|       while (i > 0
776| 	     && leaps[i].transition == leaps[i - 1].transition + 1
777| 	     && leaps[i].change == leaps[i - 1].change + 1)
778| 	{
779| 	  ++*leap_hit;
780| 	  --i;
781| 	}
782|     }
783| }


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;
(Example-1) Reason Marked as False Positive:
Lines 668/669 limit i to 0..num_transitions-1.  transitions[0] is known to be > timer (line 594) so loop on 667 will terminate before i is zero

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: overflow: The expression "i - 1UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i - 1UL", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;
(Example-2) Reason Marked as False Positive:
The conditional on line 674 precludes the conditions that lead to underflow

', '2025-11-17 21:39:07.118813');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (435, 102, 'def38', 'INTEGER_OVERFLOW', 'glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: overflow: The expression "i - 1UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i - 1UL", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: overflow: The expression "i - 1UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i - 1UL", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|     assert (timer >= transitions[i - 1]
#  710|         && (i == num_transitions || timer < transitions[i]); 
#  711|->  __tzname[types[type_idxs[i - 1]].isdst]
#  712|         = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|     size_t j = i;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: overflow: The expression "i - 1UL" is deemed underflowed because at least one of its arguments has underflowed.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i - 1UL", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;
(Example-1) Reason Marked as False Positive:
The conditional on line 674 precludes the conditions that lead to underflow

** Example-2 **
(Example-2) Known False Positive:
Error INTEGER_OVERFLOW (CWE-190):
glibc-2.39/time/tzfile.c:678: underflow: The decrement operator on the unsigned variable "i" might result in an underflow.
glibc-2.39/time/tzfile.c:711: deref_overflow: "i", which might have underflowed, is passed to "__tzname[types[type_idxs[i - 1UL]].isdst]".
#  709|   	  /* assert (timer >= transitions[i - 1]
#  710|   	     && (i == num_transitions || timer < transitions[i])); */
#  711|-> 	  __tzname[types[type_idxs[i - 1]].isdst]
#  712|   	    = __tzstring (&zone_names[types[type_idxs[i - 1]].idx]);
#  713|   	  size_t j = i;
(Example-2) Reason Marked as False Positive:
Lines 668/669 limit i to 0..num_transitions-1.  transitions[0] is known to be > timer (line 594) so loop on 667 will terminate before i is zero

', '2025-11-17 21:39:07.118813');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (436, 102, 'def39', 'OVERRUN', 'glibc-2.39/benchtests/bench-rawmemchr.c:34: overrun-buffer-arg: Calling "memchr" with "s" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   32|   {
#   33|     if ((unsigned char) c != 0)
#   34|->     return memchr (s, c, PTRDIFF_MAX);
#   35|     return (char *)s + strlen (s);
#   36|   }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/benchtests/bench-rawmemchr.c:34: overrun-buffer-arg: Calling "memchr" with "s" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   32|   {
#   33|     if ((unsigned char) c != 0)
#   34|->     return memchr (s, c, PTRDIFF_MAX);
#   35|     return (char *)s + strlen (s);
#   36|   }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-rawmemchr.c:34: overrun-buffer-arg: Calling "memchr" with "s" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   32|   {
#   33|     if ((unsigned char) c != 0)
#   34|->     return memchr (s, c, PTRDIFF_MAX);
#   35|     return (char *)s + strlen (s);
#   36|   }
(Example-1) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "memchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|
(Example-2) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

', '2025-11-17 21:39:07.118813');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (437, 102, 'def40', 'OVERRUN', 'glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "memchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "memchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "memchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|
(Example-1) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-rawmemchr.c:34: overrun-buffer-arg: Calling "memchr" with "s" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   32|   {
#   33|     if ((unsigned char) c != 0)
#   34|->     return memchr (s, c, PTRDIFF_MAX);
#   35|     return (char *)s + strlen (s);
#   36|   }
(Example-2) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

', '2025-11-17 21:39:07.118814');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (478, 102, 'def81', 'UNINIT', 'glibc-2.39/elf/dl-fini.c:68: var_decl: Declaring variable "maps" without initializer.
glibc-2.39/elf/dl-fini.c:94: uninit_use_in_call: Using uninitialized value "*maps" when calling "_dl_sort_maps".
#   92|   	     binary itself which is at the front of the search list for
#   93|   	     the main namespace.  */
#   94|-> 	  _dl_sort_maps (maps, nmaps, (ns == LM_ID_BASE), true);
#   95|   
#   96|   	  /* We do not rely on the linked list of loaded object anymore', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/elf/dl-fini.c:68: var_decl: Declaring variable "maps" without initializer.
glibc-2.39/elf/dl-fini.c:94: uninit_use_in_call: Using uninitialized value "*maps" when calling "_dl_sort_maps".
#   92|      binary itself which is at the front of the search list for
#   93|      the main namespace.  */
#   94|->   _dl_sort_maps (maps, nmaps, (ns == LM_ID_BASE), true);
#   95|   
#   96|     /* We do not rely on the linked list of loaded object anymore', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-fini.c:68: var_decl: Declaring variable "maps" without initializer.
glibc-2.39/elf/dl-fini.c:94: uninit_use_in_call: Using uninitialized value "*maps" when calling "_dl_sort_maps".
#   92|   	     binary itself which is at the front of the search list for
#   93|   	     the main namespace.  */
#   94|-> 	  _dl_sort_maps (maps, nmaps, (ns == LM_ID_BASE), true);
#   95|   
#   96|   	  /* We do not rely on the linked list of loaded object anymore
(Example-1) Reason Marked as False Positive:
maps is initialized via line 79, which counts how many entries are usable into nmaps.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);
(Example-2) Reason Marked as False Positive:
map_array is initialized in the loop at line 797

', '2025-11-17 21:39:07.118826');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (438, 102, 'def41', 'OVERRUN', 'glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "wmemchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|', 'TRUE POSITIVE', 'The `memchr_strlen` function at line 42 invokes `wmemchr` with `PTRDIFF_MAX` (equivalent to the suspicious large index `9223372036854775807UL`) without explicit bounds checking, potentially leading to a buffer overrun for buffers smaller than `PTRDIFF_MAX` bytes.', 'The CVE report explicitly highlights a suspicious call to `wmemchr` with a very large index (`9223372036854775807UL`) at line 42, which may be due to a negative parameter being interpreted as unsigned.

The source code at line 42 indeed invokes `MEMCHR` (defined as `wmemchr` in `bench-string.h` line 99) with `PTRDIFF_MAX` as the third argument, which is equivalent to the suspicious large index mentioned in the CVE report.

There is no explicit bounds checking or validation in the provided `memchr_strlen` function (lines 40-43) to prevent the passing of `PTRDIFF_MAX` as the length to `wmemchr`, which could lead to a buffer overrun if `p` points to a buffer smaller than `PTRDIFF_MAX` bytes.

Unlike the provided FALSE POSITIVE examples (Example-1 and Example-2), there is no explicit context or code within the provided snippet indicating that the function is only called with a needle known to be findable within a safely bounded buffer, thus not guaranteeing safe execution for all possible inputs.

Given the direct correlation between the code''s behavior at line 42 and the vulnerability described in the CVE (potential buffer overrun due to a very large index), and without definitive proof that all execution paths are safe, the finding cannot be conclusively marked as FALSE POSITIVE.', 'Provide the implementation details of the `MEMCHR` function to assess its handling of large index values.

Investigate the calling context of `memchr_strlen` to determine if the function is always called with a buffer that can accommodate the maximum index value.

Verify the type interpretation of `PTRDIFF_MAX` when passed as an argument to `MEMCHR`, to confirm whether it is indeed subject to unsigned interpretation.', 0.0000, '*** Source Code Context ***

code of benchtests/bench-strlen.c file:
39| size_t
40| memchr_strlen (const CHAR *p)
41| {
42|   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
43| }

code of /shared-data/source/glibc-2.39/benchtests/bench-string.h file:
99| #  define MEMCHR wmemchr

*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "wmemchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|
(Example-1) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/benchtests/bench-strlen.c:42: overrun-buffer-arg: Calling "memchr" with "p" and "9223372036854775807UL" is suspicious because of the very large index, 9223372036854775807. The index may be due to a negative parameter being interpreted as unsigned.
#   40|   memchr_strlen (const CHAR *p)
#   41|   {
#   42|->   return (const CHAR *)MEMCHR (p, 0, PTRDIFF_MAX) - p;
#   43|   }
#   44|
(Example-2) Reason Marked as False Positive:
This function is only called in a context where the needle is known to be findable.

', '2025-11-17 21:39:07.118814');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (439, 102, 'def42', 'OVERRUN', 'glibc-2.39/elf/dl-cache.c:449: overrun-buffer-arg: Overrunning array "cache_new->magic" of 17 bytes by passing it to a function which accesses it at byte offset 19 using argument "20UL".
#  447|   
#  448|   	  cache_new = (struct cache_file_new *) ((void *) cache + offset);
#  449|-> 	  if (cachesize < (offset + sizeof (struct cache_file_new))
#  450|   	      || memcmp (cache_new->magic, CACHEMAGIC_VERSION_NEW,
#  451|   			 sizeof CACHEMAGIC_VERSION_NEW - 1) != 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/elf/dl-cache.c:449: overrun-buffer-arg: Overrunning array "cache_new->magic" of 17 bytes by passing it to a function which accesses it at byte offset 19 using argument "20UL".
#  447|   
#  448|    cache_new = (struct cache_file_new *) ((void *) cache + offset);
#  449|-> if (cachesize < (offset + sizeof (struct cache_file_new))
#  450|    || memcmp (cache_new->magic, CACHEMAGIC_VERSION_NEW,
#  451|    sizeof CACHEMAGIC_VERSION_NEW - 1) != 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/elf/dl-cache.c:449: overrun-buffer-arg: Overrunning array "cache_new->magic" of 17 bytes by passing it to a function which accesses it at byte offset 19 using argument "20UL".
#  447|   
#  448|   	  cache_new = (struct cache_file_new *) ((void *) cache + offset);
#  449|-> 	  if (cachesize < (offset + sizeof (struct cache_file_new))
#  450|   	      || memcmp (cache_new->magic, CACHEMAGIC_VERSION_NEW,
#  451|   			 sizeof CACHEMAGIC_VERSION_NEW - 1) != 0)
(Example-1) Reason Marked as False Positive:
Your parser is faulty.  "sizeof FOO - 1" computes "sizeof FOO" first, then subtracts 1, resulting in an argument of 17UL.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4140: overrun-local: Overrunning array "tcache->counts" of 64 2-byte elements at element index 194 (byte offset 389) using index "tc_idx" (which evaluates to 194).
# 4138|   	      /* Fill cache first, return to user only if cache fills.
# 4139|   		 We may return one of these chunks later.  */
# 4140|-> 	      if (tcache_nb > 0
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{
(Example-2) Reason Marked as False Positive:
Line 4060 sets tcache_nb if tc_idx is within its valid range; tcache_nb is checked on line 4141 to prevent out of range behavior.

', '2025-11-17 21:39:07.118814');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (440, 102, 'def43', 'OVERRUN', 'glibc-2.39/locale/programs/locfile.c:370: strlen_assign: Setting variable "len" to the return value of strlen called with argument "output_path".
glibc-2.39/locale/programs/locfile.c:371: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  369|     /* Remove trailing slashes and trailing pathname component.  */
#  370|     len = strlen (output_path);
#  371|->   base = (char *) alloca (len);
#  372|     memcpy (base, output_path, len);
#  373|     p = base + len;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/locfile.c:370: strlen_assign: Setting variable "len" to the return value of strlen called with argument "output_path".
glibc-2.39/locale/programs/locfile.c:371: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  369|     /* Remove trailing slashes and trailing pathname component.  */
#  370|     len = strlen (output_path);
#  371|->   base = (char *) alloca (len);
#  372|     memcpy (base, output_path, len);
#  373|     p = base + len;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/locale/programs/locfile.c:370: strlen_assign: Setting variable "len" to the return value of strlen called with argument "output_path".
glibc-2.39/locale/programs/locfile.c:371: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  369|     /* Remove trailing slashes and trailing pathname component.  */
#  370|     len = strlen (output_path);
#  371|->   base = (char *) alloca (len);
#  372|     memcpy (base, output_path, len);
#  373|     p = base + len;
(Example-1) Reason Marked as False Positive:
Line 383 fills in a trailing NUL, but will always decrement p at least once first, so there is guaranteed to be enough space.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {
(Example-2) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

', '2025-11-17 21:39:07.118815');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (441, 102, 'def44', 'OVERRUN', 'glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4140: overrun-local: Overrunning array "tcache->counts" of 64 2-byte elements at element index 194 (byte offset 389) using index "tc_idx" (which evaluates to 194).
# 4138|   	      /* Fill cache first, return to user only if cache fills.
# 4139|   		 We may return one of these chunks later.  */
# 4140|-> 	      if (tcache_nb > 0
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/malloc/malloc.c: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c: overrun-local: Overrunning array "tcache->counts" of 64 2-byte elements at element index 194 using index "tc_idx" (which evaluates to 194).
#    /* Fill cache first, return to user only if cache fills.
#     We may return one of these chunks later.  */
#->     if (tcache_nb > 0
#    && tcache->counts[tc_idx] < mp_.tcache_count)
#    {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4140: overrun-local: Overrunning array "tcache->counts" of 64 2-byte elements at element index 194 (byte offset 389) using index "tc_idx" (which evaluates to 194).
# 4138|   	      /* Fill cache first, return to user only if cache fills.
# 4139|   		 We may return one of these chunks later.  */
# 4140|-> 	      if (tcache_nb > 0
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{
(Example-1) Reason Marked as False Positive:
Line 4060 sets tcache_nb if tc_idx is within its valid range; tcache_nb is checked on line 4141 to prevent out of range behavior.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4248: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_get".
# 4246|         if (return_cached)
# 4247|   	{
# 4248|-> 	  return tcache_get (tc_idx);
# 4249|   	}
# 4250|   #endif
(Example-2) Reason Marked as False Positive:
return_cached is only set when previous tests ensure that the index is in range.

', '2025-11-17 21:39:07.118815');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (442, 102, 'def45', 'OVERRUN', 'glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4143: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_put".
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{
# 4143|-> 		  tcache_put (victim, tc_idx);
# 4144|   		  return_cached = 1;
# 4145|   		  continue;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4143: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_put".
# 4141|    		 && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142| 		 {
# 4143|-> 		 tcache_put (victim, tc_idx);
# 4144| 		 return_cached = 1;
# 4145| 		 continue;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4143: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_put".
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{
# 4143|-> 		  tcache_put (victim, tc_idx);
# 4144|   		  return_cached = 1;
# 4145|   		  continue;
(Example-1) Reason Marked as False Positive:
Line 4060 sets tcache_nb if tc_idx is within its valid range; tcache_nb is checked on line 4141 to prevent out of range behavior.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4248: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_get".
# 4246|         if (return_cached)
# 4247|   	{
# 4248|-> 	  return tcache_get (tc_idx);
# 4249|   	}
# 4250|   #endif
(Example-2) Reason Marked as False Positive:
return_cached is only set when previous tests ensure that the index is in range.

', '2025-11-17 21:39:07.118815');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (443, 102, 'def46', 'OVERRUN', 'glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4248: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_get".
# 4246|         if (return_cached)
# 4247|   	{
# 4248|-> 	  return tcache_get (tc_idx);
# 4249|   	}
# 4250|   #endif', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4248: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_get".
# 4246|         if (return_cached)
# 4247|   	{
# 4248|-> 	  return tcache_get (tc_idx);
# 4249|   	}
# 4250|   #endif', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4248: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_get".
# 4246|         if (return_cached)
# 4247|   	{
# 4248|-> 	  return tcache_get (tc_idx);
# 4249|   	}
# 4250|   #endif
(Example-1) Reason Marked as False Positive:
return_cached is only set when previous tests ensure that the index is in range.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/malloc/malloc.c:3879: cond_at_least: Checking "nb == 0UL" implies that "nb" is at least 1 on the false branch.
glibc-2.39/malloc/malloc.c:3977: cond_at_least: Checking "(unsigned long)nb < 1024UL" implies that "nb" is at least 1024 on the false branch.
glibc-2.39/malloc/malloc.c:4039: cond_between: Checking "((unsigned long)nb >> 6) <= 48UL" implies that "nb" is between 1024 and 3135 (inclusive) on the true branch.
glibc-2.39/malloc/malloc.c:4059: assignment: Assigning: "tc_idx" = "(nb - 32UL + 16UL - 1UL) / 16UL". The value of "tc_idx" is now between 62 and 194 (inclusive).
glibc-2.39/malloc/malloc.c:4143: overrun-call: Overrunning callee''s array of size 64 by passing argument "tc_idx" (which evaluates to 194) in call to "tcache_put".
# 4141|   		  && tcache->counts[tc_idx] < mp_.tcache_count)
# 4142|   		{
# 4143|-> 		  tcache_put (victim, tc_idx);
# 4144|   		  return_cached = 1;
# 4145|   		  continue;
(Example-2) Reason Marked as False Positive:
Line 4060 sets tcache_nb if tc_idx is within its valid range; tcache_nb is checked on line 4141 to prevent out of range behavior.

', '2025-11-17 21:39:07.118816');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (444, 102, 'def47', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-grp.c:303: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:304: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  302|   	{
#  303|   	  size_t len = strlen (result->gr_name);
#  304|-> 	  char buf[len];
#  305|   	  enum nss_status status;
#  306|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-grp.c:303: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:304: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  302|   	{
#  303|    	size_t len = strlen (result->gr_name);
#  304|-> 	char buf[len];
#  305|    	enum nss_status status;
#  306|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-grp.c:303: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:304: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  302|   	{
#  303|   	  size_t len = strlen (result->gr_name);
#  304|-> 	  char buf[len];
#  305|   	  enum nss_status status;
#  306|
(Example-1) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-grp.c:571: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:572: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  570|   	  /* Yes, no +1, see the memcpy call below.  */
#  571|   	  size_t len = strlen (result->gr_name);
#  572|-> 	  char buf[len];
#  573|   	  enum nss_status status;
#  574|
(Example-2) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

', '2025-11-17 21:39:07.118816');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (445, 102, 'def48', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-grp.c:571: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:572: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  570|   	  /* Yes, no +1, see the memcpy call below.  */
#  571|   	  size_t len = strlen (result->gr_name);
#  572|-> 	  char buf[len];
#  573|   	  enum nss_status status;
#  574|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-grp.c:571: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:572: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  570|     Yes, no +1, see the memcpy call below.  
#  571|     size_t len = strlen (result->gr_name);
#  572|->  char buf[len];
#  573|     enum nss_status status;
#  574|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-grp.c:571: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:572: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  570|   	  /* Yes, no +1, see the memcpy call below.  */
#  571|   	  size_t len = strlen (result->gr_name);
#  572|-> 	  char buf[len];
#  573|   	  enum nss_status status;
#  574|
(Example-1) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-grp.c:303: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->gr_name".
glibc-2.39/nss/nss_compat/compat-grp.c:304: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  302|   	{
#  303|   	  size_t len = strlen (result->gr_name);
#  304|-> 	  char buf[len];
#  305|   	  enum nss_status status;
#  306|
(Example-2) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

', '2025-11-17 21:39:07.118816');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (446, 102, 'def49', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|   	  size_t len = strlen (result->pw_name);
# 1012|-> 	  char buf[len];
# 1013|   	  enum nss_status status;
# 1014|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|    	size_t len = strlen (result->pw_name);
# 1012|-> 	char buf[len];
# 1013|    	enum nss_status status;
# 1014|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|   	  size_t len = strlen (result->pw_name);
# 1012|-> 	  char buf[len];
# 1013|   	  enum nss_status status;
# 1014|
(Example-1) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:994: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:995: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  993|   	{
#  994|   	  size_t len = strlen (result->pw_name);
#  995|-> 	  char buf[len];
#  996|   	  enum nss_status status;
#  997|
(Example-2) Reason Marked as False Positive:
buf doesn''t hold a C string, it holds bytes.  The trailing NUL is never stored.

', '2025-11-17 21:39:07.118816');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (460, 102, 'def63', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:415: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  413|   		      rp_longest = trp;
#  414|   		      cnt_longest = cnt;
#  415|-> 		      if (s.decided == not
#  416|   			  && strcmp (_NL_CURRENT (LC_TIME, MON_1 + cnt),
#  417|   				     month_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:415: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  413|   3388      rp_longest = trp;
#  414|   3389      cnt_longest = cnt;
#  415|-> 3390      if (s.decided == not
#  416|   3391      && strcmp (_NL_CURRENT (LC_TIME, MON_1 + cnt),
#  417|   3392      month_name[cnt])', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:415: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  413|   		      rp_longest = trp;
#  414|   		      cnt_longest = cnt;
#  415|-> 		      if (s.decided == not
#  416|   			  && strcmp (_NL_CURRENT (LC_TIME, MON_1 + cnt),
#  417|   				     month_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:426: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  424|   		      rp_longest = trp;
#  425|   		      cnt_longest = cnt;
#  426|-> 		      if (s.decided == not
#  427|   			  && strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),
#  428|   				     ab_month_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.11882');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (447, 102, 'def50', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-pwd.c:583: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:584: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  582|   	{
#  583|   	  size_t len = strlen (result->pw_name);
#  584|-> 	  char buf[len];
#  585|   	  enum nss_status status;
#  586|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-pwd.c:583: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:584: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  582|   	{
#  583|   	  size_t len = strlen (result->pw_name);
#  584|-> 	  char buf[len];
#  585|   	  enum nss_status status;
#  586|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:583: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:584: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  582|   	{
#  583|   	  size_t len = strlen (result->pw_name);
#  584|-> 	  char buf[len];
#  585|   	  enum nss_status status;
#  586|
(Example-1) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|   	  size_t len = strlen (result->pw_name);
# 1012|-> 	  char buf[len];
# 1013|   	  enum nss_status status;
# 1014|
(Example-2) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

', '2025-11-17 21:39:07.118817');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (448, 102, 'def51', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-pwd.c:994: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:995: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  993|   	{
#  994|   	  size_t len = strlen (result->pw_name);
#  995|-> 	  char buf[len];
#  996|   	  enum nss_status status;
#  997|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-pwd.c:994: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:995: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  993|   	{
#  994|   	  size_t len = strlen (result->pw_name);
#  995|-> 	  char buf[len];
#  996|   	  enum nss_status status;
#  997|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:994: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:995: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  993|   	{
#  994|   	  size_t len = strlen (result->pw_name);
#  995|-> 	  char buf[len];
#  996|   	  enum nss_status status;
#  997|
(Example-1) Reason Marked as False Positive:
buf doesn''t hold a C string, it holds bytes.  The trailing NUL is never stored.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|   	  size_t len = strlen (result->pw_name);
# 1012|-> 	  char buf[len];
# 1013|   	  enum nss_status status;
# 1014|
(Example-2) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

', '2025-11-17 21:39:07.118817');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (449, 102, 'def52', 'OVERRUN', 'glibc-2.39/nss/nss_compat/compat-spwd.c:536: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->sp_namp".
glibc-2.39/nss/nss_compat/compat-spwd.c:537: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  535|   	{
#  536|   	  size_t len = strlen (result->sp_namp);
#  537|-> 	  char buf[len];
#  538|   	  enum nss_status status;
#  539|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/nss_compat/compat-spwd.c:536: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->sp_namp".
glibc-2.39/nss/nss_compat/compat-spwd.c:537: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  535|   	{
#  536|   	  size_t len = strlen (result->sp_namp);
#  537|-> 	  char buf[len];
#  538|   	  enum nss_status status;
#  539|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-spwd.c:536: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->sp_namp".
glibc-2.39/nss/nss_compat/compat-spwd.c:537: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  535|   	{
#  536|   	  size_t len = strlen (result->sp_namp);
#  537|-> 	  char buf[len];
#  538|   	  enum nss_status status;
#  539|
(Example-1) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/nss/nss_compat/compat-pwd.c:1011: strlen_assign: Setting variable "len" to the return value of strlen called with argument "result->pw_name".
glibc-2.39/nss/nss_compat/compat-pwd.c:1012: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
# 1010|   	{
# 1011|   	  size_t len = strlen (result->pw_name);
# 1012|-> 	  char buf[len];
# 1013|   	  enum nss_status status;
# 1014|
(Example-2) Reason Marked as False Positive:
the value copied in starts at the second character of the string, not the first, leaving room for the NUL

', '2025-11-17 21:39:07.118817');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (450, 102, 'def53', 'OVERRUN', 'glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:720: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  718|                 int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
#  719|                 if (use_alloca)
#  720|->                 newp = alloca_account (home_len + dirlen, alloca_used);
#  721|                 else
#  722|                   {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:720: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  718|                 int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
#  719|                 if (use_alloca)
#  720|->                 newp = alloca_account (home_len + dirlen, alloca_used);
#  721|                 else
#  722|                   {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:720: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  718|                 int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
#  719|                 if (use_alloca)
#  720|->                 newp = alloca_account (home_len + dirlen, alloca_used);
#  721|                 else
#  722|                   {
(Example-1) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {
(Example-2) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

', '2025-11-17 21:39:07.118817');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (451, 102, 'def54', 'OVERRUN', 'glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {
(Example-1) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:720: alloc_strlen: Allocating insufficient memory for the terminating null of the string.
#  718|                 int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);
#  719|                 if (use_alloca)
#  720|->                 newp = alloca_account (home_len + dirlen, alloca_used);
#  721|                 else
#  722|                   {
(Example-2) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

', '2025-11-17 21:39:07.118818');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (452, 102, 'def55', 'OVERRUN', 'glibc-2.39/sysdeps/posix/getcwd.c:244: assignment: Assigning: "allocated" = "4096UL".
glibc-2.39/sysdeps/posix/getcwd.c:429: cond_at_most: Checking "allocated > namlen" implies that "namlen" may be up to 4095 on the true branch.
glibc-2.39/sysdeps/posix/getcwd.c:443: overrun-buffer-arg: Overrunning array "d->d_name" of 256 bytes by passing it to a function which accesses it at byte offset 4094 using argument "namlen" (which evaluates to 4095). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  441|           }
#  442|         dirp -= namlen;
#  443|->       memcpy (dirp, d->d_name, namlen);
#  444|         *--dirp = ''/'';
#  445|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/posix/getcwd.c:244: assignment: Assigning: "allocated" = "4096UL".
glibc-2.39/sysdeps/posix/getcwd.c:429: cond_at_most: Checking "allocated > namlen" implies that "namlen" may be up to 4095 on the true branch.
glibc-2.39/sysdeps/posix/getcwd.c:443: overrun-buffer-arg: Overrunning array "d->d_name" of 256 bytes by passing it to a function which accesses it at byte offset 4094 using argument "namlen" (which evaluates to 4095).
#  441|           }
#  442|         dirp -= namlen;
#  443|->       memcpy (dirp, d->d_name, namlen);
#  444|         *--dirp = ''/'';
#  445|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/posix/getcwd.c:244: assignment: Assigning: "allocated" = "4096UL".
glibc-2.39/sysdeps/posix/getcwd.c:429: cond_at_most: Checking "allocated > namlen" implies that "namlen" may be up to 4095 on the true branch.
glibc-2.39/sysdeps/posix/getcwd.c:443: overrun-buffer-arg: Overrunning array "d->d_name" of 256 bytes by passing it to a function which accesses it at byte offset 4094 using argument "namlen" (which evaluates to 4095). [Note: The source code implementation of the function has been overridden by a builtin model.]
#  441|           }
#  442|         dirp -= namlen;
#  443|->       memcpy (dirp, d->d_name, namlen);
#  444|         *--dirp = ''/'';
#  445|
(Example-1) Reason Marked as False Positive:
line 415 limits copy to size of d->d_name, and buffer is resized if it''s smaller in the large clause following.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/posix/glob.c:508: strlen_assign: Setting variable "dirlen" to the return value of strlen called with argument "pattern".
glibc-2.39/posix/glob.c:717: strlen_assign: Setting variable "home_len" to the return value of strlen called with argument "home_dir".
glibc-2.39/posix/glob.c:723: alloc_strlen: Allocating insufficient memory for the terminating null of the string. [Note: The source code implementation of the function has been overridden by a builtin model.]
#  721|                 else
#  722|                   {
#  723|->                   newp = malloc (home_len + dirlen);
#  724|                     if (newp == NULL)
#  725|                       {
(Example-2) Reason Marked as False Positive:
mempcpy at line 733 starts at the *second* character of dirname, which causes the NUL at the end of dirname to be included within the allocated memory

', '2025-11-17 21:39:07.118818');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (453, 102, 'def56', 'OVERRUN', 'glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:113: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:114: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:123: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  121|       {
#  122|         char *l;
#  123|->       while ((l = next_line (fd, buffer, &cp, &re, buffer_end)) != NULL)
#  124|   	/* The current format of /proc/stat has all the cpu* entries
#  125|   	   at the front.  We assume here that stays this way.  */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:113: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:114: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:123: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  121|       {
#  122|         char *l;
#  123|->       while ((l = next_line (fd, buffer, &cp, &re, buffer_end)) != NULL)
#  124|    /* The current format of /proc/stat has all the cpu* entries
#  125|    at the front.  We assume here that stays this way.  */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:113: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:114: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:123: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  121|       {
#  122|         char *l;
#  123|->       while ((l = next_line (fd, buffer, &cp, &re, buffer_end)) != NULL)
#  124|   	/* The current format of /proc/stat has all the cpu* entries
#  125|   	   at the front.  We assume here that stays this way.  */
(Example-1) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|   	do
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118818');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (454, 102, 'def57', 'OVERRUN', 'glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|   	do', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|    do', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|   	do
(Example-1) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118819');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (461, 102, 'def64', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:426: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  424|   		      rp_longest = trp;
#  425|   		      cnt_longest = cnt;
#  426|-> 		      if (s.decided == not
#  427|   			  && strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),
#  428|   				     ab_month_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:426: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  424|   3388      rp_longest = trp;
#  425|   3389      cnt_longest = cnt;
#  426|-> 3390      if (s.decided == not
#  427|   3391      && strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),
#  428|   3392      ab_month_name[cnt]))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:426: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  424|   		      rp_longest = trp;
#  425|   		      cnt_longest = cnt;
#  426|-> 		      if (s.decided == not
#  427|   			  && strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),
#  428|   				     ab_month_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:451: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  449|   		      rp_longest = trp;
#  450|   		      cnt_longest = cnt;
#  451|-> 		      if (s.decided == not
#  452|   			  && strcmp (_NL_CURRENT (LC_TIME, _NL_ABALTMON_1 + cnt),
#  453|   				     alt_month_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.118821');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (455, 102, 'def58', 'OVERRUN', 'glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:79: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:80: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 256 of "buffer" (which consists of 256 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/procutils.c:90: overrun-local: Overrunning array of 256 bytes at byte offset 256 by dereferencing pointer "cp".
#   88|     char *l;
#   89|     int r;
#   90|->   while ((r = next_line (&l, fd, buffer, &cp, &re, buffer_end)) > 0)
#   91|       if (closure (l, arg) != 0)
#   92|         break;
(Example-1) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:142: alias: Assigning: "buffer_end" = "buffer + buffer_size". "buffer_end" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:143: alias: Assigning: "cp" = "buffer_end". "cp" now points to byte 1024 of "buffer" (which consists of 1024 bytes).
glibc-2.39/sysdeps/unix/sysv/linux/getsysstats.c:153: overrun-local: Overrunning array of 1024 bytes at byte offset 1024 by dereferencing pointer "cp".
#  151|     if (fd != -1)
#  152|       {
#  153|->       l = next_line (fd, buffer, &cp, &re, buffer_end);
#  154|         if (l != NULL)
#  155|   	do
(Example-2) Reason Marked as False Positive:
re and cp always point between buffer and buffer_end, access to *cp is limited by re-cp, so no real access happens until after at least line 38 when those pointers are changed.

', '2025-11-17 21:39:07.118819');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (456, 102, 'def59', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:359: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  357|   		      rp_longest = trp;
#  358|   		      cnt_longest = cnt;
#  359|-> 		      if (s.decided == not
#  360|   			  && strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),
#  361|   				     weekday_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:359: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  357|             rp_longest = trp;
#  358|             cnt_longest = cnt;
#  359|->           if (s.decided == not
#  360|             && strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),
#  361|             weekday_name[cnt])', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:359: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  357|   		      rp_longest = trp;
#  358|   		      cnt_longest = cnt;
#  359|-> 		      if (s.decided == not
#  360|   			  && strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),
#  361|   				     weekday_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:370: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  368|   		      rp_longest = trp;
#  369|   		      cnt_longest = cnt;
#  370|-> 		      if (s.decided == not
#  371|   			  && strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),
#  372|   				     ab_weekday_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118819');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (457, 102, 'def60', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:370: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  368|   		      rp_longest = trp;
#  369|   		      cnt_longest = cnt;
#  370|-> 		      if (s.decided == not
#  371|   			  && strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),
#  372|   				     ab_weekday_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:370: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  368|         rp_longest = trp;
#  369|         cnt_longest = cnt;
#  370|->       if (s.decided == not
#  371|         && strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),
#  372|         ab_weekday_name[cnt])', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:370: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  368|   		      rp_longest = trp;
#  369|   		      cnt_longest = cnt;
#  370|-> 		      if (s.decided == not
#  371|   			  && strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),
#  372|   				     ab_weekday_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:359: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  357|   		      rp_longest = trp;
#  358|   		      cnt_longest = cnt;
#  359|-> 		      if (s.decided == not
#  360|   			  && strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),
#  361|   				     weekday_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118819');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (458, 102, 'def61', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:378: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  376|   #endif
#  377|   	      if (s.decided != loc
#  378|-> 		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|   		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:378: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  376|   #endif
#  377|       if (s.decided != loc
#  378|->     && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|         && trp > rp_longest)
#  380|         || ((trp = rp, match_string (ab_weekday_name[cnt], rp))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:378: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  376|   #endif
#  377|   	      if (s.decided != loc
#  378|-> 		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|   		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:380: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  378|   		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|-> 		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
#  381|   			  && trp > rp_longest)))
#  382|   		{
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.11882');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (459, 102, 'def62', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:380: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  378|   		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|-> 		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
#  381|   			  && trp > rp_longest)))
#  382|   		{', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:380: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  378|    erotik && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|    erotik && trp > rp_longest)
#  380|-> erotik || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
#  381|    erotik && trp > rp_longest)))
#  382|    erotik {', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:380: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[0].string + cnt".
#  378|   		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|-> 		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
#  381|   			  && trp > rp_longest)))
#  382|   		{
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:347: cond_at_most: Checking "cnt < 7" implies that "cnt" may be up to 6 on the true branch.
glibc-2.39/time/strptime_l.c:378: overrun-local: Overrunning array of 1 8-byte elements at element index 6 (byte offset 55) by dereferencing pointer "&_nl_C_LC_TIME.values[7].string + cnt".
#  376|   #endif
#  377|   	      if (s.decided != loc
#  378|-> 		  && (((trp = rp, match_string (weekday_name[cnt], trp))
#  379|   		       && trp > rp_longest)
#  380|   		      || ((trp = rp, match_string (ab_weekday_name[cnt], rp))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.11882');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (462, 102, 'def65', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:439: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  437|   		      rp_longest = trp;
#  438|   		      cnt_longest = cnt;
#  439|-> 		      if (s.decided == not
#  440|   			  && strcmp (_NL_CURRENT (LC_TIME, ALTMON_1 + cnt),
#  441|   				     alt_month_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:439: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  437|   3388      rp_longest = trp;
#  438|   3389      cnt_longest = cnt;
#  439|-> 3390      if (s.decided == not
#  440|   3391      && strcmp (_NL_CURRENT (LC_TIME, ALTMON_1 + cnt),
#  441|   3392      alt_month_name[cnt]))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:439: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  437|   		      rp_longest = trp;
#  438|   		      cnt_longest = cnt;
#  439|-> 		      if (s.decided == not
#  440|   			  && strcmp (_NL_CURRENT (LC_TIME, ALTMON_1 + cnt),
#  441|   				     alt_month_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:451: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  449|   		      rp_longest = trp;
#  450|   		      cnt_longest = cnt;
#  451|-> 		      if (s.decided == not
#  452|   			  && strcmp (_NL_CURRENT (LC_TIME, _NL_ABALTMON_1 + cnt),
#  453|   				     alt_month_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.118821');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (463, 102, 'def66', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:451: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  449|   		      rp_longest = trp;
#  450|   		      cnt_longest = cnt;
#  451|-> 		      if (s.decided == not
#  452|   			  && strcmp (_NL_CURRENT (LC_TIME, _NL_ABALTMON_1 + cnt),
#  453|   				     alt_month_name[cnt]))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:451: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  449|   3388              rp_longest = trp;
#  450|   3389              cnt_longest = cnt;
#  451|-> 3390              if (s.decided == not
#  452|   3391                  && strcmp (_NL_CURRENT (LC_TIME, _NL_ABALTMON_1 + cnt),
#  453|   3392                     alt_month_name[cnt]))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:451: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  449|   		      rp_longest = trp;
#  450|   		      cnt_longest = cnt;
#  451|-> 		      if (s.decided == not
#  452|   			  && strcmp (_NL_CURRENT (LC_TIME, _NL_ABALTMON_1 + cnt),
#  453|   				     alt_month_name[cnt]))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:439: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  437|   		      rp_longest = trp;
#  438|   		      cnt_longest = cnt;
#  439|-> 		      if (s.decided == not
#  440|   			  && strcmp (_NL_CURRENT (LC_TIME, ALTMON_1 + cnt),
#  441|   				     alt_month_name[cnt]))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118821');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (464, 102, 'def67', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:460: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  458|   #endif
#  459|   	      if (s.decided != loc
#  460|-> 		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|   		      || ((trp = rp, match_string (ab_month_name[cnt], trp))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:460: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  458|   #endif
#  459|       if (s.decided != loc
#  460|->      && (((trp = rp, match_string (month_name[cnt], trp))
#  461|          && trp > rp_longest)
#  462|         || ((trp = rp, match_string (ab_month_name[cnt], trp))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:460: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[26].string + cnt".
#  458|   #endif
#  459|   	      if (s.decided != loc
#  460|-> 		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|   		      || ((trp = rp, match_string (ab_month_name[cnt], trp))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:462: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  460|   		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|-> 		      || ((trp = rp, match_string (ab_month_name[cnt], trp))
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

', '2025-11-17 21:39:07.118821');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (465, 102, 'def68', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:462: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  460|   		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|-> 		      || ((trp = rp, match_string (ab_month_name[cnt], trp))
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:462: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  460|    erotik && (((trp = rp, match_string (month_name[cnt], trp))
#  461|    erotik && trp > rp_longest)
#  462|-> erotik || ((trp = rp, match_string (ab_month_name[cnt], trp))
#  463|    erotik && trp > rp_longest)
#  464|   #ifdef _LIBC', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:462: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[14].string + cnt".
#  460|   		  && (((trp = rp, match_string (month_name[cnt], trp))
#  461|   		       && trp > rp_longest)
#  462|-> 		      || ((trp = rp, match_string (ab_month_name[cnt], trp))
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 7 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|-> 		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|   		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values.  The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118822');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (466, 102, 'def69', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|-> 		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|   		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|       && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|->        || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|       && trp > rp_longest)
#  467|     || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|-> 		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|   		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values.  The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:467: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[135].string + cnt".
#  465|   		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|-> 		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
#  468|   			  && trp > rp_longest)
#  469|   #endif
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118822');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (472, 102, 'def75', 'UNINIT', 'glibc-2.39/benchtests/bench-pthread-lock-base.c:53: var_decl: Declaring variable "buf2" without initializer.
glibc-2.39/benchtests/bench-pthread-lock-base.c:55: uninit_use_in_call: Using uninitialized value "*buf2" when calling "memcpy". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   53|     char buf1[512], buf2[512];
#   54|     int f = fibonacci (4);
#   55|->   memcpy (buf1, buf2, f);
#   56|   }
#   57|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/benchtests/bench-pthread-lock-base.c:53: var_decl: Declaring variable "buf2" without initializer.
glibc-2.39/benchtests/bench-pthread-lock-base.c:55: uninit_use_in_call: Using uninitialized value "*buf2" when calling "memcpy". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   53|     char buf1[512], buf2[512];
#   54|     int f = fibonacci (4);
#   55|->   memcpy (buf1, buf2, f);
#   56|   }
#   57|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/benchtests/bench-pthread-lock-base.c:53: var_decl: Declaring variable "buf2" without initializer.
glibc-2.39/benchtests/bench-pthread-lock-base.c:55: uninit_use_in_call: Using uninitialized value "*buf2" when calling "memcpy". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   53|     char buf1[512], buf2[512];
#   54|     int f = fibonacci (4);
#   55|->   memcpy (buf1, buf2, f);
#   56|   }
#   57|
(Example-1) Reason Marked as False Positive:
This function exists only to waste some time and block optimizations.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/libio/obprintf.c:82: var_decl: Declaring variable "buf" without initializer.
glibc-2.39/libio/obprintf.c:99: uninit_use: Using uninitialized value "buf.ch".
#   97|     if (buf.base.write_ptr == &buf.ch + 1)
#   98|       /* buf.ch is in use.  Put it into the obstack.  */
#   99|->     obstack_1grow (buf.obstack, buf.ch);
#  100|     else if (buf.base.write_ptr != &buf.ch)
#  101|       /* Shrink the buffer to the space we really currently need.  */
(Example-2) Reason Marked as False Positive:
ch is used as a temporary buffer, set up by __printf_buffer_flush_obstack, and protected by write_base and write_ptr.  It will only be read if it''s been set up as a queue and the queue written to.

', '2025-11-17 21:39:07.118824');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (467, 102, 'def70', 'OVERRUN', 'glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:467: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[135].string + cnt".
#  465|   		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|-> 		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
#  468|   			  && trp > rp_longest)
#  469|   #endif', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:467: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[135].string + cnt".
#  465|   ''|| ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|    ''&& trp > rp_longest)
#  467|-> ''|| ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
#  468|    ''&& trp > rp_longest)
#  469|   ''#endif', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:467: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[135].string + cnt".
#  465|   		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|-> 		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
#  468|   			  && trp > rp_longest)
#  469|   #endif
(Example-1) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values. The data it''s accessing indeed has 12 string values starting at offset 111

** Example-2 **
(Example-2) Known False Positive:
Error OVERRUN (CWE-119):
glibc-2.39/time/strptime_l.c:403: cond_at_most: Checking "cnt < 12" implies that "cnt" may be up to 11 on the true branch.
glibc-2.39/time/strptime_l.c:465: overrun-local: Overrunning array of 1 8-byte elements at element index 11 (byte offset 95) by dereferencing pointer "&_nl_C_LC_TIME.values[111].string + cnt".
#  463|   			  && trp > rp_longest)
#  464|   #ifdef _LIBC
#  465|-> 		      || ((trp = rp, match_string (alt_month_name[cnt], trp))
#  466|   			  && trp > rp_longest)
#  467|   		      || ((trp = rp, match_string (ab_alt_month_name[cnt], trp))
(Example-2) Reason Marked as False Positive:
This code is weird; the data has an array of values, each of which has one string - but they''re sequential, so accessing it as an array actually accesses the strings in sequential values.  The data it''s accessing indeed has 12 string values starting at offset 111

', '2025-11-17 21:39:07.118822');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (468, 102, 'def71', 'RESOURCE_LEAK', 'glibc-2.39/benchtests/bench-strchr.c:183: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:183: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:188: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:199: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  197|       json_array_begin (json_ctx, "timings");
#  198|   
#  199|->     FOR_EACH_IMPL (impl, 0)
#  200|         do_one_rand_test (json_ctx, impl, buf + align, c);
#  201|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/benchtests/bench-strchr.c: alloc_fn: Storage is returned from allocation function "xmalloc".
glibc-2.39/benchtests/bench-strchr.c: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strchr.c: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.39/benchtests/bench-strchr.c:183: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:183: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:188: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:199: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  197|       json_array_begin (json_ctx, "timings");
#  198|   
#  199|->     FOR_EACH_IMPL (impl, 0)
#  200|         do_one_rand_test (json_ctx, impl, buf + align, c);
#  201|
(Example-1) Reason Marked as False Positive:
This only happens once, and this is a standalone benchmark program, so it''s irrelevent

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.39/benchtests/bench-strstr.c:314: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:314: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:319: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:349: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  347|       json_array_begin (json_ctx, "timings");
#  348|   
#  349|->     FOR_EACH_IMPL (impl, 0)
#  350|         do_one_test (json_ctx, impl, hs, ne, NULL);
#  351|
(Example-2) Reason Marked as False Positive:
This only happens once, and this is a standalone benchmark program, so it''s irrelevent

', '2025-11-17 21:39:07.118823');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (469, 102, 'def72', 'RESOURCE_LEAK', 'glibc-2.39/benchtests/bench-strstr.c:314: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:314: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:319: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:349: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  347|       json_array_begin (json_ctx, "timings");
#  348|   
#  349|->     FOR_EACH_IMPL (impl, 0)
#  350|         do_one_test (json_ctx, impl, hs, ne, NULL);
#  351|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/benchtests/bench-strstr.c: alloc_fn: Storage is returned from allocation function "xmalloc".
glibc-2.39/benchtests/bench-strstr.c: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strstr.c: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.39/benchtests/bench-strstr.c:314: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:314: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:314: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strstr.c:319: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strstr.c:349: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  347|       json_array_begin (json_ctx, "timings");
#  348|   
#  349|->     FOR_EACH_IMPL (impl, 0)
#  350|         do_one_test (json_ctx, impl, hs, ne, NULL);
#  351|
(Example-1) Reason Marked as False Positive:
This only happens once, and this is a standalone benchmark program, so it''s irrelevent

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
glibc-2.39/benchtests/bench-strchr.c:183: alloc_fn: Storage is returned from allocation function "xmalloc". [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl_array" = storage returned from "xmalloc((impl_count + func_count) * 24UL)".
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "a" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:183: leaked_storage: Variable "a" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:183: var_assign: Assigning: "impl" = "impl_array".
glibc-2.39/benchtests/bench-strchr.c:188: leaked_storage: Variable "impl" going out of scope leaks the storage it points to.
glibc-2.39/benchtests/bench-strchr.c:199: overwrite_var: Overwriting "impl_array" in "impl_array = xmalloc((impl_count + func_count) * 24UL)" leaks the storage that "impl_array" points to.
#  197|       json_array_begin (json_ctx, "timings");
#  198|   
#  199|->     FOR_EACH_IMPL (impl, 0)
#  200|         do_one_rand_test (json_ctx, impl, buf + align, c);
#  201|
(Example-2) Reason Marked as False Positive:
This only happens once, and this is a standalone benchmark program, so it''s irrelevent

', '2025-11-17 21:39:07.118823');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (470, 102, 'def73', 'REVERSE_NEGATIVE', 'glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:297: negative_sink: Using "jz" as index to array "iq".
glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:306: check_after_sink: You might be using variable "jz" before verifying that it is >= 0.
#  304|        full precision (this function is not called for zero arguments).
#  305|        Help the compiler to know it.  */
#  306|->   if (jz < 0) __builtin_unreachable ();
#  307|   
#  308|     /* convert integer "bit" chunk to floating-point value */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:297: negative_sink: Using "jz" as index to array "iq".
glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:306: check_after_sink: You might be using variable "jz" before verifying that it is >= 0.
#  304|        full precision (this function is not called for zero arguments).
#  305|        Help the compiler to know it.  */
#  306|->   if (jz < 0) __builtin_unreachable ();
#  307|   
#  308|     /* convert integer "bit" chunk to floating-point value */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error REVERSE_NEGATIVE (CWE-191):
glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:297: negative_sink: Using "jz" as index to array "iq".
glibc-2.39/sysdeps/ieee754/dbl-64/k_rem_pio2.c:306: check_after_sink: You might be using variable "jz" before verifying that it is >= 0.
#  304|        full precision (this function is not called for zero arguments).
#  305|        Help the compiler to know it.  */
#  306|->   if (jz < 0) __builtin_unreachable ();
#  307|   
#  308|     /* convert integer "bit" chunk to floating-point value */
(Example-1) Reason Marked as False Positive:
As per the comment prior to this line, this comparison is known to be false at this point, and the code exists only to silence the very error you are reporting.

', '2025-11-17 21:39:07.118823');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (471, 102, 'def74', 'UNINIT', 'glibc-2.39/argp/argp-help.c:465: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/argp/argp-help.c:465: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
glibc-2.39/argp/argp-help.c:491: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
#  489|   	    {
#  490|   	      entry->num++;
#  491|-> 	      if (oshort (o) && ! find_char (o->key, hol->short_options, so))
#  492|   		/* O has a valid short option which hasn''t already been used.*/
#  493|   		*so++ = o->key;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/argp/argp-help.c: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/argp/argp-help.c: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
glibc-2.39/argp/argp-help.c: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
# ... (matching code snippet, ignoring line numbers)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/argp/argp-help.c:465: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/argp/argp-help.c:465: assign: Assigning: "hol->short_options" = "malloc(num_short_options + 1U)", which points to uninitialized data.
glibc-2.39/argp/argp-help.c:491: uninit_use_in_call: Using uninitialized value "*hol->short_options" when calling "find_char".
#  489|   	    {
#  490|   	      entry->num++;
#  491|-> 	      if (oshort (o) && ! find_char (o->key, hol->short_options, so))
#  492|   		/* O has a valid short option which hasn''t already been used.*/
#  493|   		*so++ = o->key;
(Example-1) Reason Marked as False Positive:
also passes "so" which points to the boundary between initialized data and uninitialized.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);
(Example-2) Reason Marked as False Positive:
map_array is initialized in the loop at line 797

', '2025-11-17 21:39:07.118824');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (473, 102, 'def76', 'UNINIT', 'glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|
(Example-1) Reason Marked as False Positive:
yylex initializes yylval around line 1182

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1054: assign: Assigning: "yyvsp" = "yyvs", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1269: uninit_use: Using uninitialized value "yyvsp[1 - yylen]".
# 1267|        unconditionally makes the parser a bit smaller, and it avoids a
# 1268|        GCC warning that YYVAL may be used uninitialized.  */
# 1269|->   yyval = yyvsp[1-yylen];
# 1270|   
# 1271|
(Example-2) Reason Marked as False Positive:
yyval is intentionally set to uninitizlied data in the cases where the following switch statement will initialize it, to avoid warning that the value is uninitialized, as the comment says.

', '2025-11-17 21:39:07.118824');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (474, 102, 'def77', 'UNINIT', 'glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1054: assign: Assigning: "yyvsp" = "yyvs", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1269: uninit_use: Using uninitialized value "yyvsp[1 - yylen]".
# 1267|        unconditionally makes the parser a bit smaller, and it avoids a
# 1268|        GCC warning that YYVAL may be used uninitialized.  */
# 1269|->   yyval = yyvsp[1-yylen];
# 1270|   
# 1271|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1054: assign: Assigning: "yyvsp" = "yyvs", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1269: uninit_use: Using uninitialized value "yyvsp[1 - yylen]".
# 1267|        unconditionally makes the parser a bit smaller, and it avoids a
# 1268|        GCC warning that YYVAL may be used uninitialized.  */
# 1269|->   yyval = yyvsp[1-yylen];
# 1270|   
# 1271|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1054: assign: Assigning: "yyvsp" = "yyvs", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1269: uninit_use: Using uninitialized value "yyvsp[1 - yylen]".
# 1267|        unconditionally makes the parser a bit smaller, and it avoids a
# 1268|        GCC warning that YYVAL may be used uninitialized.  */
# 1269|->   yyval = yyvsp[1-yylen];
# 1270|   
# 1271|
(Example-1) Reason Marked as False Positive:
yyval is intentionally set to uninitizlied data in the cases where the following switch statement will initialize it, to avoid warning that the value is uninitialized, as the comment says.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|
(Example-2) Reason Marked as False Positive:
yylex initializes yylval around line 1182

', '2025-11-17 21:39:07.118824');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (475, 102, 'def78', 'UNINIT', 'glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1143: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1141|             YYNOMEM;
# 1142|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1143|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1144|   #  undef YYSTACK_RELOCATE
# 1145|           if (yyss1 != yyssa)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1143: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1141|             YYNOMEM;
# 1142|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1143|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1144|   #  undef YYSTACK_RELOCATE
# 1145|           if (yyss1 != yyssa)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1052: var_decl: Declaring variable "yyvsa" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1053: assign: Assigning: "yyvs" = "yyvsa", which points to uninitialized data.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1143: uninit_use_in_call: Using uninitialized value "*yyvs" when calling "__builtin_memcpy".
# 1141|             YYNOMEM;
# 1142|           YYSTACK_RELOCATE (yyss_alloc, yyss);
# 1143|->         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
# 1144|   #  undef YYSTACK_RELOCATE
# 1145|           if (yyss1 != yyssa)
(Example-1) Reason Marked as False Positive:
(1) this code is part of bison, not glibc, and (2) this code is merely replacing a too-small buffer with a larger buffer; the logic for avoiding using uninitialized memory applies to the new buffer as much as it applied to the old.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1031: var_decl: Declaring variable "yylval" without initializer.
glibc-2.39/build-x86_64-redhat-linux/intl/plural.c:1477: uninit_use: Using uninitialized value "yylval".
# 1475|   
# 1476|     YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# 1477|->   *++yyvsp = yylval;
# 1478|     YY_IGNORE_MAYBE_UNINITIALIZED_END
# 1479|
(Example-2) Reason Marked as False Positive:
yylex initializes yylval around line 1182

', '2025-11-17 21:39:07.118825');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (476, 102, 'def79', 'UNINIT', 'glibc-2.39/catgets/gencat.c:852: var_decl: Declaring variable "string_pool" without initializer.
glibc-2.39/catgets/gencat.c:974: assign: Assigning: "__o" = "&string_pool", which points to uninitialized data.
glibc-2.39/catgets/gencat.c:974: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
#  972|   	  /* Add current string to the continuous space containing all
#  973|   	     strings.  */
#  974|-> 	  obstack_grow0 (&string_pool, message_run->message,
#  975|   			 strlen (message_run->message));
#  976|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/catgets/gencat.c:852: var_decl: Declaring variable "string_pool" without initializer.
glibc-2.39/catgets/gencat.c:974: assign: Assigning: "__o" = "&string_pool", which points to uninitialized data.
glibc-2.39/catgets/gencat.c:974: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
#  972|   lte  /* Add current string to the continuous space containing all
#  973|    strings.  */
#  974|->  obstack_grow0 (&string_pool, message_run->message,
#  975|    strlen (message_run->message))
#  976|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/catgets/gencat.c:852: var_decl: Declaring variable "string_pool" without initializer.
glibc-2.39/catgets/gencat.c:974: assign: Assigning: "__o" = "&string_pool", which points to uninitialized data.
glibc-2.39/catgets/gencat.c:974: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
#  972|   	  /* Add current string to the continuous space containing all
#  973|   	     strings.  */
#  974|-> 	  obstack_grow0 (&string_pool, message_run->message,
#  975|   			 strlen (message_run->message));
#  976|
(Example-1) Reason Marked as False Positive:
call to obstack_init in line 950 makes the data initialized.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2309: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2309: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2307|   					  + runp->nmbs - 1);
# 2308|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2309|-> 		obstack_make_room (&extrapool, added);
# 2310|   
# 2311|   		obstack_int32_grow_fast (&extrapool, weightidx);
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118825');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (477, 102, 'def80', 'UNINIT', 'glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);
(Example-1) Reason Marked as False Positive:
map_array is initialized in the loop at line 797

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-fini.c:68: var_decl: Declaring variable "maps" without initializer.
glibc-2.39/elf/dl-fini.c:94: uninit_use_in_call: Using uninitialized value "*maps" when calling "_dl_sort_maps".
#   92|   	     binary itself which is at the front of the search list for
#   93|   	     the main namespace.  */
#   94|-> 	  _dl_sort_maps (maps, nmaps, (ns == LM_ID_BASE), true);
#   95|   
#   96|   	  /* We do not rely on the linked list of loaded object anymore
(Example-2) Reason Marked as False Positive:
maps is initialized via line 79, which counts how many entries are usable into nmaps.

', '2025-11-17 21:39:07.118825');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (479, 102, 'def82', 'UNINIT', 'glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2165: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2165: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2163|   	int j;
# 2164|   
# 2165|-> 	obstack_make_room (&weightpool, nrules);
# 2166|   
# 2167|   	for (j = 0; j < nrules; ++j)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2165: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2165: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2163|    int j;
# 2164|   
# 2165|-> obstack_make_room (&weightpool, nrules);
# 2166|   
# 2167|    for (j = 0; j < nrules; ++j)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2165: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2165: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2163|   	int j;
# 2164|   
# 2165|-> 	obstack_make_room (&weightpool, nrules);
# 2166|   
# 2167|   	for (j = 0; j < nrules; ++j)
(Example-1) Reason Marked as False Positive:
obstack_init() initialized it.  extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118826');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (480, 102, 'def83', 'UNINIT', 'glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|
(Example-1) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2165: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2165: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2163|   	int j;
# 2164|   
# 2165|-> 	obstack_make_room (&weightpool, nrules);
# 2166|   
# 2167|   	for (j = 0; j < nrules; ++j)
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it.  extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118826');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (481, 102, 'def84', 'UNINIT', 'glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2352: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2352: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2350|     /* Add padding to the tables if necessary.  */
# 2351|     while (!LOCFILE_ALIGNED_P (obstack_object_size (&weightpool)))
# 2352|->     obstack_1grow (&weightpool, 0);
# 2353|   
# 2354|     /* Now add the four tables.  */', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2352: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2352: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2350|     /* Add padding to the tables if necessary.  */
# 2351|     while (!LOCFILE_ALIGNED_P (obstack_object_size (&weightpool)))
# 2352|->     obstack_1grow (&weightpool, 0);
# 2353|   
# 2354|     /* Now add the four tables.  */', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2352: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2352: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2350|     /* Add padding to the tables if necessary.  */
# 2351|     while (!LOCFILE_ALIGNED_P (obstack_object_size (&weightpool)))
# 2352|->     obstack_1grow (&weightpool, 0);
# 2353|   
# 2354|     /* Now add the four tables.  */
(Example-1) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118827');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (482, 102, 'def85', 'UNINIT', 'glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2309: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2309: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2307|   					  + runp->nmbs - 1);
# 2308|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2309|-> 		obstack_make_room (&extrapool, added);
# 2310|   
# 2311|   		obstack_int32_grow_fast (&extrapool, weightidx);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2309: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2309: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2307|    + runp->nmbs - 1);
# 2308|    assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2309|->   obstack_make_room (&extrapool, added);
# 2310|   
# 2311|    obstack_int32_grow_fast (&extrapool, weightidx);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2309: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2309: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2307|   					  + runp->nmbs - 1);
# 2308|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2309|-> 		obstack_make_room (&extrapool, added);
# 2310|   
# 2311|   		obstack_int32_grow_fast (&extrapool, weightidx);
(Example-1) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2110: var_decl: Declaring variable "extrapool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2250: assign: Assigning: "__o" = "&extrapool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2250: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2248|   					  + 2 * (runp->nmbs - 1));
# 2249|   		assert (LOCFILE_ALIGNED_P (obstack_object_size (&extrapool)));
# 2250|-> 		obstack_make_room (&extrapool, added);
# 2251|   
# 2252|   		/* More than one consecutive entry.  We mark this by having
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118827');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (483, 102, 'def86', 'UNINIT', 'glibc-2.39/misc/tsearch.c:337: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/misc/tsearch.c:337: assign: Assigning: "q" = "(struct node_t *)malloc(24UL)", which points to uninitialized data.
glibc-2.39/misc/tsearch.c:351: uninit_use: Using uninitialized value "q->left_node".
#  349|         SETNODEPTR(nextp,q);		/* link new node to old */
#  350|         q->key = key;			/* initialize new node */
#  351|->       SETRED(q);
#  352|         SETLEFT(q,NULL);
#  353|         SETRIGHT(q,NULL);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/misc/tsearch.c:337: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/misc/tsearch.c:337: assign: Assigning: "q" = "(struct node_t *)malloc(24UL)", which points to uninitialized data.
glibc-2.39/misc/tsearch.c:351: uninit_use: Using uninitialized value "q->left_node".
#  349|         SETNODEPTR(nextp,q);        /* link new node to old */
#  350|         q->key = key;               /* initialize new node */
#  351|->       SETRED(q);
#  352|         SETLEFT(q,NULL);
#  353|         SETRIGHT(q,NULL);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/misc/tsearch.c:337: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/misc/tsearch.c:337: assign: Assigning: "q" = "(struct node_t *)malloc(24UL)", which points to uninitialized data.
glibc-2.39/misc/tsearch.c:351: uninit_use: Using uninitialized value "q->left_node".
#  349|         SETNODEPTR(nextp,q);		/* link new node to old */
#  350|         q->key = key;			/* initialize new node */
#  351|->       SETRED(q);
#  352|         SETLEFT(q,NULL);
#  353|         SETRIGHT(q,NULL);
(Example-1) Reason Marked as False Positive:
SETRED does not access q->left_node.  Those three macros initialize q.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);
(Example-2) Reason Marked as False Positive:
map_array is initialized in the loop at line 797

', '2025-11-17 21:39:07.118827');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (484, 102, 'def87', 'UNINIT', 'glibc-2.39/nss/getaddrinfo.c:2034: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:2066: uninit_use: Using uninitialized value "endp".
# 2064|   		    }
# 2065|   		}
# 2066|-> 	      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
# 2067|   		       && (cp == NULL
# 2068|   			   || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/nss/getaddrinfo.c: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c: uninit_use: Using uninitialized value "endp".
#->                      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
#                           && (cp == NULL
#                              || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/nss/getaddrinfo.c:2034: var_decl: Declaring variable "endp" without initializer.
glibc-2.39/nss/getaddrinfo.c:2066: uninit_use: Using uninitialized value "endp".
# 2064|   		    }
# 2065|   		}
# 2066|-> 	      else if (inet_pton (AF_INET, val1, &prefix.s6_addr32[3])
# 2067|   		       && (cp == NULL
# 2068|   			   || (bits = strtoul (cp, &endp, 10)) != ULONG_MAX
(Example-1) Reason Marked as False Positive:
endp is initialized by strtoul() on line 2068

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   	  waitlist->counter = total;
#  173|-> 	  waitlist->sigev = *sig;
#  174|   	}
#  175|       }
(Example-2) Reason Marked as False Positive:
defsigev.sigev_notify = SIGEV_NONE prevents access to the uninitialized portions

', '2025-11-17 21:39:07.118827');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (485, 102, 'def88', 'UNINIT', 'glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }
(Example-1) Reason Marked as False Positive:
fs->num limits access to the stack; memory will not be accessed until it is initialized and num is incremented.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# 1427|   		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
# 1428|   		  {
# 1429|-> 		    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
# 1430|   					       prev_idx_match, &eps_via_nodes);
# 1431|   		    break;
(Example-2) Reason Marked as False Positive:
fs->num limits the amount of fs->stack that''s accessed to only those entries that are initialized via push_fail_stack()

', '2025-11-17 21:39:07.118828');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (486, 102, 'def89', 'UNINIT', 'glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# 1427|   		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
# 1428|   		  {
# 1429|-> 		    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
# 1430|   					       prev_idx_match, &eps_via_nodes);
# 1431|   		    break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/posix/regexec.c: alloc_fn: Calling "malloc" which returns uninitialized memory.
glibc-2.39/posix/regexec.c: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# ... (contextual code snippet, ignored for comparison)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->idx" when calling "pop_fail_stack".
glibc-2.39/posix/regexec.c:1429: uninit_use_in_call: Using uninitialized value "fs->stack->node" when calling "pop_fail_stack".
# 1427|   		if (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)
# 1428|   		  {
# 1429|-> 		    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,
# 1430|   					       prev_idx_match, &eps_via_nodes);
# 1431|   		    break;
(Example-1) Reason Marked as False Positive:
fs->num limits the amount of fs->stack that''s accessed to only those entries that are initialized via push_fail_stack()

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/regexec.c:1396: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/posix/regexec.c:1396: assign: Assigning: "fs->stack" = "(struct re_fail_stack_ent_t *)malloc(fs->alloc * 32UL)", which points to uninitialized data.
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->eps_via_nodes.elems" when calling "free_fail_stack_return".
glibc-2.39/posix/regexec.c:1409: uninit_use_in_call: Using uninitialized value "fs->stack->regs" when calling "free_fail_stack_return".
# 1407|       {
# 1408|         regmatch_list_free (&prev_match);
# 1409|->       free_fail_stack_return (fs);
# 1410|         return REG_ESPACE;
# 1411|       }
(Example-2) Reason Marked as False Positive:
fs->num limits access to the stack; memory will not be accessed until it is initialized and num is incremented.

', '2025-11-17 21:39:07.118828');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (487, 102, 'def90', 'UNINIT', 'glibc-2.39/posix/wordexp.c:2212: var_decl: Declaring variable "ifs_white" without initializer.
glibc-2.39/posix/wordexp.c:2267: assign: Assigning: "runp" = "ifs_white", which points to uninitialized data.
glibc-2.39/posix/wordexp.c:2269: uninit_use: Using uninitialized value "*runp".
# 2267|   	      char *runp = ifs_white;
# 2268|   
# 2269|-> 	      while (runp < whch && *runp != *ifsch)
# 2270|   		++runp;
# 2271|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/posix/wordexp.c: var_decl: Declaring variable "ifs_white" without initializer.
glibc-2.39/posix/wordexp.c: assign: Assigning: "runp" = "ifs_white", which points to uninitialized data.
glibc-2.39/posix/wordexp.c: uninit_use: Using uninitialized value "*runp".
# |    char *runp = ifs_white;
# |   
# |-> while (runp < whch && *runp != *ifsch)
# |    ++runp;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/posix/wordexp.c:2212: var_decl: Declaring variable "ifs_white" without initializer.
glibc-2.39/posix/wordexp.c:2267: assign: Assigning: "runp" = "ifs_white", which points to uninitialized data.
glibc-2.39/posix/wordexp.c:2269: uninit_use: Using uninitialized value "*runp".
# 2267|   	      char *runp = ifs_white;
# 2268|   
# 2269|-> 	      while (runp < whch && *runp != *ifsch)
# 2270|   		++runp;
# 2271|
(Example-1) Reason Marked as False Positive:
whch tracks which parts of ifwhite are initialized and which aren''t

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/catgets/gencat.c:852: var_decl: Declaring variable "string_pool" without initializer.
glibc-2.39/catgets/gencat.c:974: assign: Assigning: "__o" = "&string_pool", which points to uninitialized data.
glibc-2.39/catgets/gencat.c:974: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
#  972|   	  /* Add current string to the continuous space containing all
#  973|   	     strings.  */
#  974|-> 	  obstack_grow0 (&string_pool, message_run->message,
#  975|   			 strlen (message_run->message));
#  976|
(Example-2) Reason Marked as False Positive:
call to obstack_init in line 950 makes the data initialized.

', '2025-11-17 21:39:07.118828');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (488, 102, 'def91', 'UNINIT', 'glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   	  waitlist->counter = total;
#  173|-> 	  waitlist->sigev = *sig;
#  174|   	}
#  175|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   (waitlist->counter = total;
#  173|-> (waitlist->sigev = *sig;
#  174|    
#  175|       ', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   	  waitlist->counter = total;
#  173|-> 	  waitlist->sigev = *sig;
#  174|   	}
#  175|       }
(Example-1) Reason Marked as False Positive:
defsigev.sigev_notify = SIGEV_NONE prevents access to the uninitialized portions

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|
(Example-2) Reason Marked as False Positive:
gai_notify_only will only access sig''s other data when sig->sigev_notify is not SIGEV_NONE, and defsigev''s is SIGEV_NONE, which protects the other fields from being accessed.

', '2025-11-17 21:39:07.118828');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (489, 102, 'def92', 'UNINIT', 'glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|
(Example-1) Reason Marked as False Positive:
gai_notify_only will only access sig''s other data when sig->sigev_notify is not SIGEV_NONE, and defsigev''s is SIGEV_NONE, which protects the other fields from being accessed.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|
(Example-2) Reason Marked as False Positive:
gai_notify_only will only access sig''s other data when sig->sigev_notify is not SIGEV_NONE, and defsigev''s is SIGEV_NONE, which protects the other fields from being accessed.

', '2025-11-17 21:39:07.118829');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (490, 102, 'def93', 'UNINIT', 'glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|->  __gai_notify_only (sig,
#   91|    sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|
(Example-1) Reason Marked as False Positive:
gai_notify_only will only access sig''s other data when sig->sigev_notify is not SIGEV_NONE, and defsigev''s is SIGEV_NONE, which protects the other fields from being accessed.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:90: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__gai_notify_only".
#   88|   
#   89|         if (mode == GAI_NOWAIT)
#   90|-> 	__gai_notify_only (sig,
#   91|   			   sig->sigev_notify == SIGEV_SIGNAL ? getpid () : 0);
#   92|
(Example-2) Reason Marked as False Positive:
gai_notify_only will only access sig''s other data when sig->sigev_notify is not SIGEV_NONE, and defsigev''s is SIGEV_NONE, which protects the other fields from being accessed.

', '2025-11-17 21:39:07.118829');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (491, 102, 'def94', 'UNINIT', 'glibc-2.39/resolv/res_send.c:804: var_decl: Declaring variable "slen" without initializer.
glibc-2.39/resolv/res_send.c:856: uninit_use_in_call: Using uninitialized value "slen" when calling "__connect".
#  854|   		DIAG_PUSH_NEEDS_COMMENT;
#  855|   		DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
#  856|-> 		if (__connect (EXT (statp).nssocks[ns], nsap, slen) < 0) {
#  857|   		DIAG_POP_NEEDS_COMMENT;
#  858|   			__res_iclose(statp, false);', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/resolv/res_send.c:804: var_decl: Declaring variable "slen" without initializer.
glibc-2.39/resolv/res_send.c:856: uninit_use_in_call: Using uninitialized value "slen" when calling "__connect".
#  854|    DIAG_PUSH_NEEDS_COMMENT;
#  855|    DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
#  856|-> if (__connect (EXT (statp).nssocks[ns], nsap, slen) < 0) {
#  857|    DIAG_POP_NEEDS_COMMENT;
#  858|    __res_iclose(statp, false);', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/res_send.c:804: var_decl: Declaring variable "slen" without initializer.
glibc-2.39/resolv/res_send.c:856: uninit_use_in_call: Using uninitialized value "slen" when calling "__connect".
#  854|   		DIAG_PUSH_NEEDS_COMMENT;
#  855|   		DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
#  856|-> 		if (__connect (EXT (statp).nssocks[ns], nsap, slen) < 0) {
#  857|   		DIAG_POP_NEEDS_COMMENT;
#  858|   			__res_iclose(statp, false);
(Example-1) Reason Marked as False Positive:
whether slen is uninitialized or not correlates with whether EST(statp).nssocks[ns] is set on lines 808 and 815.  If slen is not initialized, the test on line 820 will be true and the function will exit.  Thus, slen will be initialized by line 856

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/resolv/getaddrinfo_a.c:39: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/resolv/getaddrinfo_a.c:55: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/resolv/getaddrinfo_a.c:173: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  171|   
#  172|   	  waitlist->counter = total;
#  173|-> 	  waitlist->sigev = *sig;
#  174|   	}
#  175|       }
(Example-2) Reason Marked as False Positive:
defsigev.sigev_notify = SIGEV_NONE prevents access to the uninitialized portions

', '2025-11-17 21:39:07.118829');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (492, 102, 'def95', 'UNINIT', 'glibc-2.39/rt/aio_suspend.c:119: var_decl: Declaring variable "requestlist" without initializer.
glibc-2.39/rt/aio_suspend.c:216: uninit_use: Using uninitialized value "requestlist[cnt]".
#  214|   	struct waitlist **listp;
#  215|   
#  216|-> 	assert (requestlist[cnt] != NULL);
#  217|   
#  218|   	/* There is the chance that we cannot find our entry anymore. This', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/rt/aio_suspend.c:119: var_decl: Declaring variable "requestlist" without initializer.
glibc-2.39/rt/aio_suspend.c:216: uninit_use: Using uninitialized value "requestlist[cnt]".
#  214|    struct waitlist **listp;
#  215|   
#  216|->  assert (requestlist[cnt] != NULL);
#  217|   
#  218|    /* There is the chance that we cannot find our entry anymore. This', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/aio_suspend.c:119: var_decl: Declaring variable "requestlist" without initializer.
glibc-2.39/rt/aio_suspend.c:216: uninit_use: Using uninitialized value "requestlist[cnt]".
#  214|   	struct waitlist **listp;
#  215|   
#  216|-> 	assert (requestlist[cnt] != NULL);
#  217|   
#  218|   	/* There is the chance that we cannot find our entry anymore. This
(Example-1) Reason Marked as False Positive:
cnt limits access to entries initialized on line 138

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:221: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  219|   
#  220|   	  waitlist->counter = total;
#  221|-> 	  waitlist->sigev = *sig;
#  222|   	}
#  223|       }
(Example-2) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents other code from trying to access any other fields

', '2025-11-17 21:39:07.11883');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (493, 102, 'def96', 'UNINIT', 'glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|->         __aio_notify_only (sig);
#  127|   
#  128|         return result;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|->         __aio_notify_only (sig);
#  127|   
#  128|         return result;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|->         __aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-1) Reason Marked as False Positive:
__aio_notify_only will only read the other members when the signal is other than SIGEV_NONE, and defsigev is SIGEV_NONE

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-2) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents __aio_notify_only from trying to access any other fields

', '2025-11-17 21:39:07.11883');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (494, 102, 'def97', 'UNINIT', 'glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|->  __aio_notify_only (sig);
#  127|   
#  128|         return result;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-1) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents __aio_notify_only from trying to access any other fields

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_signo" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-2) Reason Marked as False Positive:
__aio_notify_only will only read the other members when the signal is other than SIGEV_NONE, and defsigev is SIGEV_NONE

', '2025-11-17 21:39:07.11883');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (495, 102, 'def98', 'UNINIT', 'glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_signo" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_signo" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|->  __aio_notify_only (sig);
#  127|   
#  128|         return result;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_signo" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-1) Reason Marked as False Positive:
__aio_notify_only will only read the other members when the signal is other than SIGEV_NONE, and defsigev is SIGEV_NONE

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-2) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents __aio_notify_only from trying to access any other fields

', '2025-11-17 21:39:07.11883');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (496, 102, 'def99', 'UNINIT', 'glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:221: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  219|   
#  220|   	  waitlist->counter = total;
#  221|-> 	  waitlist->sigev = *sig;
#  222|   	}
#  223|       }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:221: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  219|   
#  220|   (waitlist->counter = total;
#  221|-> (waitlist->sigev = *sig;
#  222|   )
#  223|       }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:221: uninit_use: Using uninitialized value "*sig". Field "sig->sigev_value" is uninitialized.
#  219|   
#  220|   	  waitlist->counter = total;
#  221|-> 	  waitlist->sigev = *sig;
#  222|   	}
#  223|       }
(Example-1) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents other code from trying to access any other fields

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/rt/lio_listio-common.c:77: var_decl: Declaring variable "defsigev" without initializer.
glibc-2.39/rt/lio_listio-common.c:86: assign: Assigning: "sig" = "&defsigev", which points to uninitialized data.
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->_sigev_un" when calling "__aio_notify_only".
glibc-2.39/rt/lio_listio-common.c:126: uninit_use_in_call: Using uninitialized value "sig->sigev_value" when calling "__aio_notify_only".
#  124|   
#  125|         if (LIO_MODE (mode) == LIO_NOWAIT)
#  126|-> 	__aio_notify_only (sig);
#  127|   
#  128|         return result;
(Example-2) Reason Marked as False Positive:
defsigev is partially initialized with SIGEV_NONE, which prevents __aio_notify_only from trying to access any other fields

', '2025-11-17 21:39:07.118831');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (497, 102, 'def100', 'UNINIT', 'glibc-2.39/stdlib/strtod_l.c:519: var_decl: Declaring variable "den" without initializer.
glibc-2.39/stdlib/strtod_l.c:1466: uninit_use_in_call: Using uninitialized value "den[densize - 1L]" when calling "__builtin_clzll".
# 1464|        */
# 1465|   
# 1466|->     count_leading_zeros (cnt, den[densize - 1]);
# 1467|   
# 1468|       if (cnt > 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/stdlib/strtod_l.c:519: var_decl: Declaring variable "den" without initializer.
glibc-2.39/stdlib/strtod_l.c:1466: uninit_use_in_call: Using uninitialized value "den[densize - 1L]" when calling "__builtin_clzll".
# 1464|        */
# 1465|   
# 1466|->     count_leading_zeros (cnt, den[densize - 1]);
# 1467|   
# 1468|       if (cnt > 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/stdlib/strtod_l.c:519: var_decl: Declaring variable "den" without initializer.
glibc-2.39/stdlib/strtod_l.c:1466: uninit_use_in_call: Using uninitialized value "den[densize - 1L]" when calling "__builtin_clzll".
# 1464|        */
# 1465|   
# 1466|->     count_leading_zeros (cnt, den[densize - 1]);
# 1467|   
# 1468|       if (cnt > 0)
(Example-1) Reason Marked as False Positive:
den is initialized by the do loop at 1415 and memcpy at 1446

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/locale/programs/ld-collate.c:2109: var_decl: Declaring variable "weightpool" without initializer.
glibc-2.39/locale/programs/ld-collate.c:2175: assign: Assigning: "__o" = "&weightpool", which points to uninitialized data.
glibc-2.39/locale/programs/ld-collate.c:2175: uninit_use_in_call: Using uninitialized value "__o->extra_arg" when calling "_obstack_newchunk".
# 2173|     if (i > 0)
# 2174|       do
# 2175|->       obstack_1grow (&weightpool, ''\0'');
# 2176|       while (++i < LOCFILE_ALIGN);
# 2177|
(Example-2) Reason Marked as False Positive:
obstack_init() initialized it. extra_arg is only used if use_extra_arg is set, which only happens when extra_arg is set.

', '2025-11-17 21:39:07.118831');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (498, 102, 'def101', 'UNINIT', 'glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:205: uninit_use: Using uninitialized value "ad->ad_fullname".
#  203|     if (ad != NULL)
#  204|       {
#  205|->       if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|         if (ad->ad_servername != NULL)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:205: uninit_use: Using uninitialized value "ad->ad_fullname".
#  203|     if (ad != NULL)
#  204|       {
#  205|->       if (ad->ad_fullname != NULL)
#  206|    FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|         if (ad->ad_servername != NULL)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:205: uninit_use: Using uninitialized value "ad->ad_fullname".
#  203|     if (ad != NULL)
#  204|       {
#  205|->       if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|         if (ad->ad_servername != NULL)
(Example-1) Reason Marked as False Positive:
ad_fullname is set at line 150 and filled at line 164

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:207: uninit_use: Using uninitialized value "ad->ad_servername".
#  205|         if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|->       if (ad->ad_servername != NULL)
#  208|   	FREE (ad->ad_servername, ad->ad_servernamelen + 1);
#  209|         FREE (ad, sizeof (struct ad_private));
(Example-2) Reason Marked as False Positive:
memory pointed to by ad is initialized by memset on line 145

', '2025-11-17 21:39:07.118831');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (499, 102, 'def102', 'UNINIT', 'glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:207: uninit_use: Using uninitialized value "ad->ad_servername".
#  205|         if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|->       if (ad->ad_servername != NULL)
#  208|   	FREE (ad->ad_servername, ad->ad_servernamelen + 1);
#  209|         FREE (ad, sizeof (struct ad_private));', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:207: uninit_use: Using uninitialized value "ad->ad_servername".
#  205|         if (ad->ad_fullname != NULL)
#  206|    FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|->       if (ad->ad_servername != NULL)
#  208|    FREE (ad->ad_servername, ad->ad_servernamelen + 1);
#  209|         FREE (ad, sizeof (struct ad_private));', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:207: uninit_use: Using uninitialized value "ad->ad_servername".
#  205|         if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|->       if (ad->ad_servername != NULL)
#  208|   	FREE (ad->ad_servername, ad->ad_servernamelen + 1);
#  209|         FREE (ad, sizeof (struct ad_private));
(Example-1) Reason Marked as False Positive:
memory pointed to by ad is initialized by memset on line 145

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sunrpc/auth_des.c:137: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/sunrpc/auth_des.c:137: assign: Assigning: "ad" = "(struct ad_private *)malloc(1160UL)", which points to uninitialized data.
glibc-2.39/sunrpc/auth_des.c:205: uninit_use: Using uninitialized value "ad->ad_fullname".
#  203|     if (ad != NULL)
#  204|       {
#  205|->       if (ad->ad_fullname != NULL)
#  206|   	FREE (ad->ad_fullname, ad->ad_fullnamelen + 1);
#  207|         if (ad->ad_servername != NULL)
(Example-2) Reason Marked as False Positive:
ad_fullname is set at line 150 and filled at line 164

', '2025-11-17 21:39:07.118831');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (500, 102, 'def103', 'UNINIT', 'glibc-2.39/support/support_subprocess.c:32: var_decl: Declaring variable "result" without initializer.
glibc-2.39/support/support_subprocess.c:45: uninit_use: Using uninitialized value "result". Field "result.pid" is uninitialized.
#   43|     TEST_VERIFY (fflush (stderr) == 0);
#   44|   
#   45|->   return result;
#   46|   }
#   47|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/support/support_subprocess.c:32: var_decl: Declaring variable "result" without initializer.
glibc-2.39/support/support_subprocess.c:45: uninit_use: Using uninitialized value "result". Field "result.pid" is uninitialized.
#   43|     TEST_VERIFY (fflush (stderr) == 0);
#   44|   
#   45|->   return result;
#   46|   }
#   47|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/support/support_subprocess.c:32: var_decl: Declaring variable "result" without initializer.
glibc-2.39/support/support_subprocess.c:45: uninit_use: Using uninitialized value "result". Field "result.pid" is uninitialized.
#   43|     TEST_VERIFY (fflush (stderr) == 0);
#   44|   
#   45|->   return result;
#   46|   }
#   47|
(Example-1) Reason Marked as False Positive:
All callers of support_subprocess_init set pid before returning.

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|   	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> 	      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|   	    }
#  447|   	  break;
(Example-2) Reason Marked as False Positive:
declaration is in scope for all jumps to print_err, and fmt is set prior to each of those jumps

', '2025-11-17 21:39:07.118832');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (501, 102, 'def104', 'UNINIT', 'glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|   	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> 	      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|   	    }
#  447|   	  break;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|     strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|    }
#  447|    break;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/sysdeps/x86_64/dl-machine.h:435: skipped_decl: Jumping over declaration of "fmt".
glibc-2.39/sysdeps/x86_64/dl-machine.h:445: uninit_use_in_call: Using uninitialized value "fmt" when calling "_dl_error_printf".
#  443|   	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
#  444|   
#  445|-> 	      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);
#  446|   	    }
#  447|   	  break;
(Example-1) Reason Marked as False Positive:
declaration is in scope for all jumps to print_err, and fmt is set prior to each of those jumps

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/elf/dl-find_object.c:794: alloc_fn: Calling "malloc" which returns uninitialized memory. [Note: The source code implementation of the function has been overridden by a builtin model.]
glibc-2.39/elf/dl-find_object.c:794: assign: Assigning: "map_array" = "malloc(count * 8UL)", which points to uninitialized data.
glibc-2.39/elf/dl-find_object.c:804: uninit_use_in_call: Using uninitialized value "*map_array" when calling "_dl_find_object_link_map_sort".
#  802|     }
#  803|   
#  804|->   _dl_find_object_link_map_sort (map_array, count);
#  805|     bool ok = _dl_find_object_update_1 (map_array, count);
#  806|     free (map_array);
(Example-2) Reason Marked as False Positive:
map_array is initialized in the loop at line 797

', '2025-11-17 21:39:07.118832');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (502, 102, 'def105', 'UNINIT', 'glibc-2.39/timezone/zic.c:2018: var_decl: Declaring variable "typemap" without initializer.
glibc-2.39/timezone/zic.c:2226: uninit_use: Using uninitialized value "typemap[types[i]]".
# 2224|   		  putc(currenttype, fp);
# 2225|   		for (i = thistimei; i < thistimelim; ++i) {
# 2226|-> 		  currenttype = typemap[types[i]];
# 2227|   		  putc(currenttype, fp);
# 2228|   		}', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c: var_decl: Declaring variable "typemap" without initializer.
glibc-2.39/timezone/zic.c: uninit_use: Using uninitialized value "typemap[types[i]]".
#    putc(currenttype, fp);
#    for (i = thistimei; i < thistimelim; ++i) {
#->  currenttype = typemap[types[i]];
#    putc(currenttype, fp);
#    }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2018: var_decl: Declaring variable "typemap" without initializer.
glibc-2.39/timezone/zic.c:2226: uninit_use: Using uninitialized value "typemap[types[i]]".
# 2224|   		  putc(currenttype, fp);
# 2225|   		for (i = thistimei; i < thistimelim; ++i) {
# 2226|-> 		  currenttype = typemap[types[i]];
# 2227|   		  putc(currenttype, fp);
# 2228|   		}
(Example-1) Reason Marked as False Positive:
typemap is initialized at line 2146

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2602: var_decl: Declaring variable "starttime" without initializer.
glibc-2.39/timezone/zic.c:2749: uninit_use_in_call: Using uninitialized value "starttime" when calling "addtt".
# 2747|   				startttisut);
# 2748|   			if (usestart) {
# 2749|-> 				addtt(starttime, type);
# 2750|   				usestart = false;
# 2751|   			} else
(Example-2) Reason Marked as False Positive:
starttime is initialized on line 2631

', '2025-11-17 21:39:07.118832');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (503, 102, 'def106', 'UNINIT', 'glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "dstr" without initializer.
glibc-2.39/timezone/zic.c:2548: assign: Assigning: "dstrp" = "&dstr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2576: uninit_use_in_call: Using uninitialized value "dstrp->r_wday" when calling "stringrule".
# 2574|   	}
# 2575|   	result[len++] = '','';
# 2576|-> 	c = stringrule(result + len, dstrp, dstrp->r_save, zp->z_stdoff);
# 2577|   	if (c < 0) {
# 2578|   		result[0] = ''\0'';', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "dstr" without initializer.
glibc-2.39/timezone/zic.c:2548: assign: Assigning: "dstrp" = "&dstr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2576: uninit_use_in_call: Using uninitialized value "dstrp->r_wday" when calling "stringrule".
# 2574|    }
# 2575|    result[len++] = '','';
# 2576|->  c = stringrule(result + len, dstrp, dstrp->r_save, zp->z_stdoff);
# 2577|    if (c < 0) {
# 2578|        result[0] = ''\0'';', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "dstr" without initializer.
glibc-2.39/timezone/zic.c:2548: assign: Assigning: "dstrp" = "&dstr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2576: uninit_use_in_call: Using uninitialized value "dstrp->r_wday" when calling "stringrule".
# 2574|   	}
# 2575|   	result[len++] = '','';
# 2576|-> 	c = stringrule(result + len, dstrp, dstrp->r_save, zp->z_stdoff);
# 2577|   	if (c < 0) {
# 2578|   		result[0] = ''\0'';
(Example-1) Reason Marked as False Positive:
dstr.r_dycode is set to DC_DOM which avoids the conditional branch that uses r_wday

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "stdr" without initializer.
glibc-2.39/timezone/zic.c:2549: assign: Assigning: "stdrp" = "&stdr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2585: uninit_use_in_call: Using uninitialized value "stdrp->r_wday" when calling "stringrule".
# 2583|   	len += strlen(result + len);
# 2584|   	result[len++] = '','';
# 2585|-> 	c = stringrule(result + len, stdrp, dstrp->r_save, zp->z_stdoff);
# 2586|   	if (c < 0) {
# 2587|   		result[0] = ''\0'';
(Example-2) Reason Marked as False Positive:
stdr.r_dycode is set to DC_DOM which avoids the conditional branch that uses r_wday

', '2025-11-17 21:39:07.118833');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (508, 101, 'def3', 'RESOURCE_LEAK', 'graphite2-1.3.14/src/GlyphCache.cpp:130: alloc_fn: Storage is returned from allocation function "operator new[]".
graphite2-1.3.14/src/GlyphCache.cpp:130: var_assign: Assigning: "glyphs" = storage returned from "new graphite2::GlyphFace[this->_num_glyphs]".
graphite2-1.3.14/src/GlyphCache.cpp:135: noescape: Resource "glyphs[0]" is not freed or pointed-to in "read_glyph".
graphite2-1.3.14/src/GlyphCache.cpp:171: leaked_storage: Variable "glyphs" going out of scope leaks the storage it points to.
#  169|   	// the dtor needs to call delete[] on _glyphs[0] to release what was allocated
#  170|   	// as glyphs
#  171|->     }
#  172|   
#  173|       if (_glyphs && glyph(0) == 0)', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: graphite2-1.3.14/src/GlyphCache.cpp:130: alloc_fn: Storage is returned from allocation function "operator new[]".
graphite2-1.3.14/src/GlyphCache.cpp:130: var_assign: Assigning: "glyphs" = storage returned from "new graphite2::GlyphFace[this->_num_glyphs]".
graphite2-1.3.14/src/GlyphCache.cpp:135: noescape: Resource "glyphs[0]" is not freed or pointed-to in "read_glyph".
graphite2-1.3.14/src/GlyphCache.cpp:171: leaked_storage: Variable "glyphs" going out of scope leaks the storage it points to.
#  169|    // the dtor needs to call delete[] on _glyphs[0] to release what was allocated
#  170|    // as glyphs
#  171|->     }
#  172|   
#  173|       if (_glyphs && glyph(0) == 0)', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
graphite2-1.3.14/src/GlyphCache.cpp:130: alloc_fn: Storage is returned from allocation function "operator new[]".
graphite2-1.3.14/src/GlyphCache.cpp:130: var_assign: Assigning: "glyphs" = storage returned from "new graphite2::GlyphFace[this->_num_glyphs]".
graphite2-1.3.14/src/GlyphCache.cpp:135: noescape: Resource "glyphs[0]" is not freed or pointed-to in "read_glyph".
graphite2-1.3.14/src/GlyphCache.cpp:171: leaked_storage: Variable "glyphs" going out of scope leaks the storage it points to.
#  169|   	// the dtor needs to call delete[] on _glyphs[0] to release what was allocated
#  170|   	// as glyphs
#  171|->     }
#  172|   
#  173|       if (_glyphs && glyph(0) == 0)
(Example-1) Reason Marked as False Positive:
calling read_glyph on index 0 saved glyphs as _glyphs[0]. Setting _glyph_loader to nullptr here flags that the dtor needs to call delete[] on _glyphs[0] to release what was allocated as glyphs

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
graphite2-1.3.14/src/Pass.cpp:275: alloc_fn: Storage is returned from allocation function "realloc".
graphite2-1.3.14/src/Pass.cpp:275: var_assign: Assigning: "moved_progs" = storage returned from "realloc(this->m_progs, prog_pool_free - this->m_progs)".
graphite2-1.3.14/src/Pass.cpp:280: leaked_storage: Variable "moved_progs" going out of scope leaks the storage it points to.
#  278|           free(m_progs);
#  279|           m_progs = 0;
#  280|->         return face.error(e);
#  281|       }
#  282|
(Example-2) Reason Marked as False Positive:
moved_progs variable is getting used in next lines of code.

', '2025-11-17 21:39:07.142168');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (504, 102, 'def107', 'UNINIT', 'glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "stdr" without initializer.
glibc-2.39/timezone/zic.c:2549: assign: Assigning: "stdrp" = "&stdr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2585: uninit_use_in_call: Using uninitialized value "stdrp->r_wday" when calling "stringrule".
# 2583|   	len += strlen(result + len);
# 2584|   	result[len++] = '','';
# 2585|-> 	c = stringrule(result + len, stdrp, dstrp->r_save, zp->z_stdoff);
# 2586|   	if (c < 0) {
# 2587|   		result[0] = ''\0'';', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "stdr" without initializer.
glibc-2.39/timezone/zic.c:2549: assign: Assigning: "stdrp" = "&stdr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2585: uninit_use_in_call: Using uninitialized value "stdrp->r_wday" when calling "stringrule".
# 2583|    len += strlen(result + len);
# 2584|    result[len++] = '','';
# 2585|->  c = stringrule(result + len, stdrp, dstrp->r_save, zp->z_stdoff);
# 2586|    if (c < 0) {
# 2587|        result[0] = ''\0'';', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "stdr" without initializer.
glibc-2.39/timezone/zic.c:2549: assign: Assigning: "stdrp" = "&stdr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2585: uninit_use_in_call: Using uninitialized value "stdrp->r_wday" when calling "stringrule".
# 2583|   	len += strlen(result + len);
# 2584|   	result[len++] = '','';
# 2585|-> 	c = stringrule(result + len, stdrp, dstrp->r_save, zp->z_stdoff);
# 2586|   	if (c < 0) {
# 2587|   		result[0] = ''\0'';
(Example-1) Reason Marked as False Positive:
stdr.r_dycode is set to DC_DOM which avoids the conditional branch that uses r_wday

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2488: var_decl: Declaring variable "dstr" without initializer.
glibc-2.39/timezone/zic.c:2548: assign: Assigning: "dstrp" = "&dstr", which points to uninitialized data.
glibc-2.39/timezone/zic.c:2576: uninit_use_in_call: Using uninitialized value "dstrp->r_wday" when calling "stringrule".
# 2574|   	}
# 2575|   	result[len++] = '','';
# 2576|-> 	c = stringrule(result + len, dstrp, dstrp->r_save, zp->z_stdoff);
# 2577|   	if (c < 0) {
# 2578|   		result[0] = ''\0'';
(Example-2) Reason Marked as False Positive:
dstr.r_dycode is set to DC_DOM which avoids the conditional branch that uses r_wday

', '2025-11-17 21:39:07.118833');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (505, 102, 'def108', 'UNINIT', 'glibc-2.39/timezone/zic.c:2602: var_decl: Declaring variable "starttime" without initializer.
glibc-2.39/timezone/zic.c:2749: uninit_use_in_call: Using uninitialized value "starttime" when calling "addtt".
# 2747|   				startttisut);
# 2748|   			if (usestart) {
# 2749|-> 				addtt(starttime, type);
# 2750|   				usestart = false;
# 2751|   			} else', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: glibc-2.39/timezone/zic.c:2602: var_decl: Declaring variable "starttime" without initializer.
glibc-2.39/timezone/zic.c:2749: uninit_use_in_call: Using uninitialized value "starttime" when calling "addtt".
# 2747|   $startttisut);
# 2748|   if (usestart) {
# 2749|-> addtt(starttime, type);
# 2750|   usestart = false;
# 2751|   } else', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2602: var_decl: Declaring variable "starttime" without initializer.
glibc-2.39/timezone/zic.c:2749: uninit_use_in_call: Using uninitialized value "starttime" when calling "addtt".
# 2747|   				startttisut);
# 2748|   			if (usestart) {
# 2749|-> 				addtt(starttime, type);
# 2750|   				usestart = false;
# 2751|   			} else
(Example-1) Reason Marked as False Positive:
starttime is initialized on line 2631

** Example-2 **
(Example-2) Known False Positive:
Error UNINIT (CWE-457):
glibc-2.39/timezone/zic.c:2018: var_decl: Declaring variable "typemap" without initializer.
glibc-2.39/timezone/zic.c:2226: uninit_use: Using uninitialized value "typemap[types[i]]".
# 2224|   		  putc(currenttype, fp);
# 2225|   		for (i = thistimei; i < thistimelim; ++i) {
# 2226|-> 		  currenttype = typemap[types[i]];
# 2227|   		  putc(currenttype, fp);
# 2228|   		}
(Example-2) Reason Marked as False Positive:
typemap is initialized at line 2146

', '2025-11-17 21:39:07.118833');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (506, 101, 'def1', 'COMPILER_WARNING', 'graphite2-1.3.14/tests/endian/endiantest.cpp: scope_hint: In function int main(int, char**)
graphite2-1.3.14/tests/endian/endiantest.cpp:141:5: warning[-Wmisleading-indentation]: this if clause does not guard...
#  141 |     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#      |     ^~
graphite2-1.3.14/tests/endian/endiantest.cpp:145:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the if
#  145 |         if (r == 0) r = test_reads<uint64, uint32, uint16, uint8>(rounds);
#      |         ^~
#  139|   	int r = 0;
#  140|   
#  141|->     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#  142|          || !test_swaps<int64, int32, int16, int8>())
#  143|           return 5;', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: graphite2-1.3.14/tests/endian/endiantest.cpp: scope_hint: In function int main(int, char**)
graphite2-1.3.14/tests/endian/endiantest.cpp: warning[-Wmisleading-indentation]: this if clause does not guard...
#     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#     ...this statement, but the latter is misleadingly indented as if it were guarded by the if
#         if (r == 0) r = test_reads<uint64, uint32, uint16, uint8>(rounds);
#     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#          || !test_swaps<int64, int32, int16, int8>())
#           return 5;', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error COMPILER_WARNING (CWE-483):
graphite2-1.3.14/tests/endian/endiantest.cpp: scope_hint: In function int main(int, char**)
graphite2-1.3.14/tests/endian/endiantest.cpp:141:5: warning[-Wmisleading-indentation]: this if clause does not guard...
#  141 |     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#      |     ^~
graphite2-1.3.14/tests/endian/endiantest.cpp:145:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the if
#  145 |         if (r == 0) r = test_reads<uint64, uint32, uint16, uint8>(rounds);
#      |         ^~
#  139|   	int r = 0;
#  140|   
#  141|->     if   (!test_swaps<uint64, uint32, uint16, uint8>()
#  142|          || !test_swaps<int64, int32, int16, int8>())
#  143|           return 5;
(Example-1) Reason Marked as False Positive:
its just cosmetic issue of writing if statement

', '2025-11-17 21:39:07.142159');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (507, 101, 'def2', 'CPPCHECK_WARNING', 'graphite2-1.3.14/gr2fonttest/UtfCodec.h:197: error[returnDanglingLifetime]: Returning pointer that will be invalid when returning.
#  195|   
#  196|           reference         operator * () const throw() { return *this; }
#  197|->         pointer                operator ->() const throw() { return &operator *(); }
#  198|   
#  199|           operator codeunit_type * () const throw() { return cp; }', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: graphite2-1.3.14/gr2fonttest/UtfCodec.h: error[returnDanglingLifetime]: Returning pointer that will be invalid when returning.
#           reference         operator * () const throw() { return *this; }
#->         pointer                operator ->() const throw() { return &operator *(); }
#           operator codeunit_type * () const throw() { return cp; }', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error CPPCHECK_WARNING (CWE-562):
graphite2-1.3.14/gr2fonttest/UtfCodec.h:197: error[returnDanglingLifetime]: Returning pointer that will be invalid when returning.
#  195|   
#  196|           reference         operator * () const throw() { return *this; }
#  197|->         pointer                operator ->() const throw() { return &operator *(); }
#  198|   
#  199|           operator codeunit_type * () const throw() { return cp; }
(Example-1) Reason Marked as False Positive:
I think this is not true, its not invalid return pointer

', '2025-11-17 21:39:07.142167');
INSERT INTO public.mlops_issue_details (id, mlops_job_id, issue_id, issue_name, error_description, investigation_result, hint, justifications, recommendations, answer_relevancy, context, created_at) VALUES (509, 101, 'def4', 'RESOURCE_LEAK', 'graphite2-1.3.14/src/Pass.cpp:275: alloc_fn: Storage is returned from allocation function "realloc".
graphite2-1.3.14/src/Pass.cpp:275: var_assign: Assigning: "moved_progs" = storage returned from "realloc(this->m_progs, prog_pool_free - this->m_progs)".
graphite2-1.3.14/src/Pass.cpp:280: leaked_storage: Variable "moved_progs" going out of scope leaks the storage it points to.
#  278|           free(m_progs);
#  279|           m_progs = 0;
#  280|->         return face.error(e);
#  281|       }
#  282|', 'FALSE POSITIVE', 'The error is similar to one found in the provided known issues (Details in the full Justification)', 'The error is similar to one found in the provided context: graphite2-1.3.14/src/Pass.cpp:275: alloc_fn: Storage is returned from allocation function "realloc".
graphite2-1.3.14/src/Pass.cpp:275: var_assign: Assigning: "moved_progs" = storage returned from "realloc(this->m_progs, prog_pool_free - this->m_progs)".
graphite2-1.3.14/src/Pass.cpp:280: leaked_storage: Variable "moved_progs" going out of scope leaks the storage it points to.
#  278|           free(m_progs);
#  279|           m_progs = 0;
#  280|->         return face.error(e);
#  281|       }
#  282|', 'No fix required.', 0.0000, '*** Source Code Context ***


*** Examples ***
** Example-1 **
(Example-1) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
graphite2-1.3.14/src/Pass.cpp:275: alloc_fn: Storage is returned from allocation function "realloc".
graphite2-1.3.14/src/Pass.cpp:275: var_assign: Assigning: "moved_progs" = storage returned from "realloc(this->m_progs, prog_pool_free - this->m_progs)".
graphite2-1.3.14/src/Pass.cpp:280: leaked_storage: Variable "moved_progs" going out of scope leaks the storage it points to.
#  278|           free(m_progs);
#  279|           m_progs = 0;
#  280|->         return face.error(e);
#  281|       }
#  282|
(Example-1) Reason Marked as False Positive:
moved_progs variable is getting used in next lines of code.

** Example-2 **
(Example-2) Known False Positive:
Error RESOURCE_LEAK (CWE-772):
graphite2-1.3.14/src/GlyphCache.cpp:130: alloc_fn: Storage is returned from allocation function "operator new[]".
graphite2-1.3.14/src/GlyphCache.cpp:130: var_assign: Assigning: "glyphs" = storage returned from "new graphite2::GlyphFace[this->_num_glyphs]".
graphite2-1.3.14/src/GlyphCache.cpp:135: noescape: Resource "glyphs[0]" is not freed or pointed-to in "read_glyph".
graphite2-1.3.14/src/GlyphCache.cpp:171: leaked_storage: Variable "glyphs" going out of scope leaks the storage it points to.
#  169|   	// the dtor needs to call delete[] on _glyphs[0] to release what was allocated
#  170|   	// as glyphs
#  171|->     }
#  172|   
#  173|       if (_glyphs && glyph(0) == 0)
(Example-2) Reason Marked as False Positive:
calling read_glyph on index 0 saved glyphs as _glyphs[0]. Setting _glyph_loader to nullptr here flags that the dtor needs to call delete[] on _glyphs[0] to release what was allocated as glyphs

', '2025-11-17 21:39:07.142168');


--
-- Data for Name: mlops_job_metrics; Type: TABLE DATA; Schema: public; Owner: quarkus
--

INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (93, 93, 'libksba', 1.0000, 1.0000, 1.0000, 1.0000, 2, 0, 1, 0, '2025-11-13 15:40:16');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (94, 94, 'gzip', 0.9167, 0.8889, 1.0000, 0.9412, 8, 1, 3, 0, '2025-11-13 15:47:06');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (95, 95, 'libconfig', 1.0000, 1.0000, 1.0000, 1.0000, 2, 0, 0, 0, '2025-11-13 15:49:03');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (96, 96, 'libpcap', 1.0000, 1.0000, 1.0000, 1.0000, 3, 0, 0, 0, '2025-11-13 16:55:04');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (97, 97, 'adcli', 0.9833, 0.9737, 1.0000, 0.9867, 37, 1, 22, 0, '2025-11-13 17:06:19');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (98, 98, 'audit', 0.8571, 0.9231, 0.9231, 0.9231, 12, 1, 0, 1, '2025-11-13 17:08:10');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (99, 99, 'libpng', 1.0000, 1.0000, 1.0000, 1.0000, 11, 0, 1, 0, '2025-11-13 17:17:39');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (100, 100, 'cpio', 0.8788, 0.8788, 1.0000, 0.9355, 29, 4, 0, 0, '2025-11-13 17:23:42');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (101, 101, 'graphite2', 1.0000, 1.0000, 1.0000, 1.0000, 4, 0, 0, 0, '2025-11-13 18:26:25');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (102, 102, 'glibc', 0.9444, 0.9457, 0.9886, 0.9667, 87, 5, 15, 1, '2025-11-13 18:37:20');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (103, 103, 'libtalloc', 1.0000, 1.0000, 1.0000, 1.0000, 29, 0, 0, 0, '2025-11-13 18:43:36');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (104, 104, 'libuser', 1.0000, 1.0000, 1.0000, 1.0000, 8, 0, 0, 0, '2025-11-13 18:47:35');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (105, 105, 'mpdecimal', 0.8000, 0.9524, 0.8333, 0.8889, 20, 1, 0, 4, '2025-11-13 19:13:47');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (106, 106, 'nano', 0.7500, 0.8182, 0.9000, 0.8571, 9, 2, 0, 1, '2025-11-13 19:21:25');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (107, 107, 'ncurses', 0.7500, 1.0000, 0.7500, 0.8571, 3, 0, 0, 1, '2025-11-13 19:25:52');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (108, 108, 'rpcbind', 1.0000, 1.0000, 1.0000, 1.0000, 3, 0, 0, 0, '2025-11-13 19:28:40');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (109, 109, 'sqlite', 0.8750, 0.9294, 0.9186, 0.9240, 79, 6, 12, 7, '2025-11-13 20:38:41');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (110, 110, 'sysfsutils', 1.0000, 1.0000, 1.0000, 1.0000, 1, 0, 9, 0, '2025-11-13 20:44:22');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (111, 111, 'tpm2-tools', 0.5000, 0.5000, 1.0000, 0.6667, 1, 1, 0, 0, '2025-11-13 21:46:47');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (112, 112, 'texinfo', 0.9024, 0.7778, 1.0000, 0.8750, 14, 4, 23, 0, '2025-11-13 22:28:59');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (113, 113, 'unzip', 0.8636, 1.0000, 0.8125, 0.8966, 13, 0, 6, 3, '2025-11-13 23:11:56');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (114, 114, 'trace-cmd', 0.8406, 0.7632, 0.9355, 0.8406, 29, 9, 29, 2, '2025-11-13 23:13:01');
INSERT INTO public.mlops_job_metrics (id, mlops_job_id, package_name, accuracy, "precision", recall, f1_score, cm_tp, cm_fp, cm_tn, cm_fn, created_at) VALUES (115, 115, 'util-linux', 0.8400, 0.7949, 1.0000, 0.8857, 31, 8, 11, 0, '2025-11-14 00:05:00');


--
-- Name: mlops_batch_id_seq; Type: SEQUENCE SET; Schema: public; Owner: quarkus
--

SELECT pg_catalog.setval('public.mlops_batch_id_seq', 7, true);


--
-- Name: mlops_issue_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: quarkus
--

SELECT pg_catalog.setval('public.mlops_issue_details_id_seq', 509, true);


--
-- Name: mlops_job_id_seq; Type: SEQUENCE SET; Schema: public; Owner: quarkus
--

SELECT pg_catalog.setval('public.mlops_job_id_seq', 124, true);


--
-- Name: mlops_job_metrics_id_seq; Type: SEQUENCE SET; Schema: public; Owner: quarkus
--

SELECT pg_catalog.setval('public.mlops_job_metrics_id_seq', 124, true);


--
-- PostgreSQL database dump complete
--

\unrestrict YmCQje7rnIWNenrK8IEe1QayulRzxHuaC3qDxnHdbBpWi8wwmpDd2pFzDNnQG2b

